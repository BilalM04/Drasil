\chapter{ODE Data Represent}
In the Drasil framework, there is a single data structure containing all the information for all products, and we call it System Information. The giant System Information collects a multitude of pieces of information; whenever we need it, we extract the information from the System Information. In previous research, we store all ordinary differential equations (ODEs) information in the System Information. However, that information existed in the form of plain text. In other words, we explicitly wrote ODEs in the text without any advanced data structure. Although this method maintains the relationship of ODEs, it restricts any transformation of ODEs. Therefore, the Drasil team decide to create a new data structure to store ODEs information. This chapter will describe how to store an ODE in the Drasil framework. 

\section{Matrix Form}
In general, an equation contains a left-hand expression, a right-hand expression, and an equal sign. The left-hand and right-hand expressions connect by an equal sign. A linear ODE also has its left-hand and right-hand sides. Each side has its unique shape. We can write a linear ODE in the shape of

\begin{equation} \label{eq_matrixform}
	\boldsymbol{Ax} = \boldsymbol{b}
\end{equation}

On the left-hand side, A is an m * n matrix, and x is an n-vector . On the right-hand side, b is an m-vector. The A is commonly known as the coefficient matrix, b is the constant vector, and x is the unknown vector.

Given the following (example~\ref{eq_odeexmaple}),
\begin{equation} \label{eq_odeexmaple}
	y_t'' + (1 + K_d)y_t' + (20 + K_p)y_t = r_t K_p
\end{equation}

$y_t$ is the dependent variable, and $K_d$, $K_p$, and $r_t$ are constant variables. We can write this equation as following. 

\begin{equation} \label{eq_matrixformexmaple}
	\begin{bmatrix}
		1, & 1 + K_{d}, & 20 + K_{p}
	\end{bmatrix}
	\cdot
	\begin{bmatrix}
		y_{t}''  \\
		y_{t}'   \\
		y_{t}  
	\end{bmatrix}
	=
	\begin{bmatrix}
		r_{t} K_{p} 
	\end{bmatrix}
\end{equation}

The relationship between the matrix form~\ref{eq_matrixform} and the example~\ref{eq_matrixformexmaple} is not hard to find out. Firstly, the coefficient matrix A is 1 * 3 matrix that consists with $1$, $1 + K_d$, ane $20 + K_p$. Secondly, the unknown vector is a 3 * 1 vector with $y_t''$, $y_t'$, and $y_t$. Last, the constant vector is a 1 * 1 vector with $r_t K_p$. The matrix form~\ref{eq_matrixform} very well capture all the knowledge we need to present an ODE. Therefore, we decide to create a datatype called \verb|DifferentialModel| to preserve ODEs information. The \verb|DifferentialModel| has six records, and here are the representing code for \verb|DifferentialModel|.
\begin{haskell1}
data DifferentialModel = SystemOfLinearODEs {
	_indepVar :: UnitalChunk,
	_depVar :: ConstrConcept,
	_coefficients :: [[Expr]],
	_unknowns :: [Unknown],
	_dmConstants :: [Expr],
	_dmconc :: ConceptChunk
}
\end{haskell1}

Previous on this research, UnitalChunk, ConstrConcept, Expr, and ConceptChunk already existed in Drasil. The Unknown type created in this experiment.Their semantics will show up in Appendix A ~\ref{tab_demodeltype}

The \verb|_indepVar| represent the independent variable in an ODE, and it is usually time. The \verb|_depVar| represent the dependent variable in ODE. The \verb|_coefficients| is a list of list \verb|Expr|, and it represents the coefficient of the ODE. The \verb|_unknowns| is a list of \verb|Unknown|, each \verb|Unknown| indicate nth order of derivative of the dependent variable. The \verb|_dmConstants| is an \verb|Expr|, and it represents the constant vector. Last, the \verb|_dmconc| contains meta data of this model. To represent example~\ref{eq_matrixformexmaple} in \verb|DifferentialModel|, \verb|_indepVar| is time, \verb|_depVar| is $y_t$, \verb|_coefficients| is a 1 *3 matrix, \verb|_unknowns| is 3 * 1 vector, \verb|_dmConstants| is a 1 * 1 vector, and \verb|_dmconc| is \verb|ConceptChunk| that describe what is this model.

Currently, the \verb|DifferentialModel| only capture knowledge of ODEs with one dependent variable. This is a special case of the family of linear ODEs. Studying this special case will help the Drasil team better understand how to capture the knowledge of all ODEs, and eventually lead to solve a system of linear ODE with multiple dependent variables.

\section{Input Language}
\label{sec_input}
There are many reasons why we want to provide an input language for users to input ODE equations. One major reason is that it could be over complicated for users to input a single ODE in a matrix form, so introducing an input language could to simplify inputting a single ODE. What will this input language looks like? The example~\ref{eq_odeexmaple} represents a linear second-order ODE, and how to represent a linear nth-order ODE? Base on Paul's Online Notes~\citep{paullinearode}, all linear ODEs can be write in shape of 
\begin{equation} \label{eq_linearDE}
	a_n(t)y^n(t) + a_{n-1}(t)y^{n-1}(t) + \dots + a_1(t)y'(t) + a_0(t)y(t) = g(t)
\end{equation}

On the left-hand side, the expression is a collection of terms. Each term consist a coefficient and a derivative of the dependent variable. With ideas of term, coefficient, and derivative, we create new datatypes to mimic the mathematical expression of linear ODEs. The following is the detail of code for new datatypes and operators.

\begin{haskell1}
type Unknown = Integer
data Term = T{
	_coeff :: Expr,
	_unk :: Unknown
}
type LHS = [Term]

($^^) :: ConstrConcept -> Integer -> Unknown
($^^) _ unk' = unk'

($*) :: Expr -> Unknown -> Term
($*) = T

($+) :: [Term] -> Term -> LHS
($+) xs x  = xs ++ [x]
\end{haskell1}

The \verb|LHS|, short name for left-hand side, is a list of \verb|Term|. Each \verb|Term| has of a \verb|Expr| and \verb|Unknown|. Most of creation of new operators are inspire by a normal form of linear ODE~\ref{eq_linearDE}. Then, the \verb|$^^| operator connect a dependent variable and the order of its derivative. The \verb|$*| operator create a term by connecting a coefficient and an unknown variable. Last, the \verb|$^^| operator connect all terms together. Let write pseudo code for the example matrix form~\ref{eq_odeexmaple} in the newly introduced input lanuguge. The full detail of input lanuage for PD\_Contoller example will show up in Appendix ~\ref{appendix_a}.

\begin{haskell1}
lhs = [1 $* (y_t $^^ 2)] -- $\label{myline}$
	$+ (1 + K_d) $* (y_t $^^ 1)
	$+ (20 + K_p) $* (y_t $^^ 0)
rhs = r_t K_p
\end{haskell1}

\section{Two Constructors}
There are two constructors to create a \verb|DifferentialModel|. They are using for different design purposes. The first constructor is \verb|makeASystemDE|. A user can set the coefficient matrix, unknown vector, and constant vector by explicitly giving \verb|[[Expr]]|, \verb|[Unknown]|, and \verb|[Expr]|. There will be several guards to check wheather inputs are well-formed.

1. The dimension of coefficent matrix and constant vector need to match. The \verb|_coefficients| is a m * n matrix and \verb|_dmConstants| is a m vector. This guard make sure they have the same m dimension. If there is error says "Length of coefficients matrix should equal to the length of the constant vector", it means \verb|_coefficients| and \verb|_dmConstants| has different m dimension, and it violates mathematical rules.

2. The dimension of each row in coefficent matrix and unknown vector need to match. The \verb|_coefficients| use a list of list to represent a m * n matrix. It means each list in \verb|_coefficients| will have the same length n, and \verb|_unknowns| is an n-vector. Therefore, the length of each row in the \verb|_coefficients| should equal to the length of \verb|_unknowns|. If there is error says "The length of each row vector in coefficients need to equal to the length of unknowns vector", it means \verb|_coefficients|and \verb|_unknowns| violate mathematical rules.

3. The order of unknown vector need to be descending due to design decisions. We have no control on what user will give to us, and there are infinite ways to represent a linear equations in the matrix form~\ref{eq_matrixform}. We strictly ask user to input the unknown vector descending, so we can maintain the shape of a normal form of linear ODE~\ref{eq_linearDE}. This design choice will simplify the implementation for solving a linear ODE numerically in Chapter 3. If there is error says "The order of giving unknowns need to be descending", it means the order of unknown vector is not descending.

The following is the pseudo code show how to directly set the coefficient matrix, unknown vector, and constant vector for example~\ref{eq_odeexmaple}. The full detail of how to directly set the coefficient matrix, unknown vector, and constant vector for PD\_Contoller example will show up in Appendix~\ref{appendix_a}.

\begin{haskell1}
coefficent = [[1, 1 + K_d, 20 + K_p]]
unknowns   = [2, 1, 0]
constants  = [r_t K_p]
\end{haskell1}

The second constructor is called \verb|makeASingleDE|. This constructor uses the input language~\ref{sec_input} to simplify the input of a single ODE. In \verb|makeASingleDE|, the coefficient matrix, unknown vector, and constant vector are build base on data that restricts by the input language. Users no longer to set the data by directly giving values. All data for the coefficient matrix, unknown vector, and constant vector will be generated  accordingly. The constructor first create a descending unknown vector base on the highest number of its derivatives. For example, if the highest order of derivative in the left-hand side of equation is 2, then we will generate a list contains 2, 1 and 0. Then, we will create the coefficient matrix by finding its related coefficient base on the descending order of the unknown vector. One advantage of this design choice is that it increases the readability while inputting a single ODE. The second advantage is that users no longer required to input unknown vector in descending order. Any order of the unknown vector will be fine because we will generate the data of \verb|DifferentialModel|.

\section{Display Matrix}
After the \verb|DifferentialModel| obtain ODE information, we want to display them in software requirements specification (SRS). Previous, we mentioned the Drasil framework can generate software artifacts, and SRS is a part of them. There are two way to display ODEs.

1. We can display ODEs in a matrix form. The matrix form~\ref{eq_matrixformexmaple} demonstrate how the ODE will show up in a matrix from in the SRS. In the \verb|DifferentialModel|, we store the coefficient matrix in a list of list expression, the unknown vector in a list of integer, and the constant vector in a list of expression. It should be fairly straightforward for Drasil printer to display them by printing each part sequentially.

2. We also can display ODEs in a shape of a linear equation. The example~\ref{eq_odeexmaple} demonstrate how the ODE will show up in a shape of linear equation in the SRS. Display an ODE in a linear equation is a special case. When there is only a single ODE, it would be over complicated to display it in a matrix form. This is the same reason why we want to create an input language to better manage inputting a single ODE.

In the future, the Drasil team want to explore more variability of displaying an ODE. One topic highlighted in the discussion is displaying an ODE in a canonical form. However, many mathematicians has different opinions on what is a canonical form, and the name of canonical form has been using differently, such as normal form or standard form. More research on this part would help us better understand the knowledge of ODE.
