\chapter{ODE Data Represent}
In the Drasil framework, there is a single data structure containing all the information for all products, and we call it System Information. The giant System Information collects a multitude of pieces of information; whenever we need it, we extract the information from the System Information. In previous research, we store all ordinary differential equations (ODEs) information in the System Information. However, that information existed in the form of plain text. In other words, we explicitly wrote ODEs in the text without any advanced data structure. Although this method maintains the relationship of ODEs, it restricts any transformation of ODEs. Therefore, the Drasil team decide to create a new data structure to store ODEs information. This chapter will describe how to store an ODE in the Drasil framework. 

\section{Matrix Form}
In general, an equation contains a left-hand expression, a right-hand expression, and an equal sign. The left-hand and right-hand expressions connect by an equal sign. A linear ODE also has its left-hand and right-hand sides. Each side has its unique shape. We can write a linear ODE in the shape of

\begin{equation} \label{eq_matrixform}
	\boldsymbol{Ax} = \boldsymbol{b}
\end{equation}

On the left-hand side, A is an m * n matrix, and x is an n-vector. On the right-hand side, b is an m-vector. The A is commonly known as the coefficient matrix, b is the constant vector, and x is the unknown vector.

Given the ODE example~\ref{eq_odeexmaple} in PDContoller case study,
\begin{equation} \label{eq_odeexmaple}
	y_t'' + (1 + K_d)y_t' + (20 + K_p)y_t = r_t K_p
\end{equation}

$y_t$ is the dependent variable, and $K_d$, $K_p$, and $r_t$ are constant variables. We can write this equation as follows. 

\begin{equation} \label{eq_matrixformexmaple}
	\begin{bmatrix}
		1, & 1 + K_{d}, & 20 + K_{p}
	\end{bmatrix}
	\cdot
	\begin{bmatrix}
		y_{t}''  \\
		y_{t}'   \\
		y_{t}  
	\end{bmatrix}
	=
	\begin{bmatrix}
		r_{t} K_{p} 
	\end{bmatrix}
\end{equation}

The relationship between the matrix form~\ref{eq_matrixform} and the example~\ref{eq_matrixformexmaple} is not hard to find. Firstly, the coefficient matrix A is a 1 * 3 matrix that consists of $1$, $1 + K_d$, ane $20 + K_p$. Secondly, the unknown vector is a 3 * 1 vector with $y_t''$, $y_t'$, and $y_t$. Last, the constant vector is a 1 * 1 vector with $r_t K_p$. The matrix form~\ref{eq_matrixform} very well captures all the knowledge we need to present an ODE. Therefore, we decided to create a datatype called \verb|DifferentialModel| to preserve ODEs information. The \verb|DifferentialModel| has six records, and here is the representing code for \verb|DifferentialModel|.
\begin{haskell1}
data DifferentialModel = SystemOfLinearODEs {
	_indepVar :: UnitalChunk,
	_depVar :: ConstrConcept,
	_coefficients :: [[Expr]],
	_unknowns :: [Unknown],
	_dmConstants :: [Expr],
	_dmconc :: ConceptChunk
}
\end{haskell1}

Previous to this research, UnitalChunk, ConstrConcept, Expr, and ConceptChunk already existed in Drasil. We created an \verb|Unknown| type for this experiment. Their semantics will show up in Appendix A ~\ref{tab_demodeltype}

The \verb|_indepVar| represents the independent variable in an ODE, and it is usually time. The \verb|_depVar| represents the dependent variable in an ODE. The \verb|_coefficients| is a list of lists \verb|Expr|, and it represents the coefficient matrix in an ODE. The \verb|_unknowns| is a list of \verb|Unknown|, and it represents the unknown vector. Each \verb|Unknown| indicates an nth order of derivative of the dependent variable. The \verb|_dmConstants| is a list of \verb|Expr|, and it represents the constant vector. Last, the \verb|_dmconc| contains metadata of this model. To represent example~\ref{eq_matrixformexmaple} in \verb|DifferentialModel|, \verb|_indepVar| is time, \verb|_depVar| is $y_t$, \verb|_coefficients| is the 1 *3 matrix, \verb|_unknowns| is the 3 * 1 vector, \verb|_dmConstants| is the 1 * 1 vector, and \verb|_dmconc| is \verb|ConceptChunk| that describes what this model is.

Currently, the \verb|DifferentialModel| only captures the knowledge of ODEs with one dependent variable, and it is a special case of the family of linear ODEs. Studying this special case will help the Drasil team better understand how to capture the knowledge of all ODEs and eventually lead to solving a system of linear ODE with multiple dependent variables.

\section{Input Language}
\label{sec_input}
There are many reasons why we want to provide an input language for users to input ODE equations. One major reason is that it could be over complicated for users to input a single ODE in a matrix form, so introducing an input language could simplify inputting a single ODE. What will this input language look like? The example~\ref{eq_odeexmaple} represents a linear second-order ODE, and how to represent a linear nth-order ODE? Based on Paul's Online Notes~\citep{paullinearode}, we can write all linear ODEs in the shape of 
\begin{equation} \label{eq_linearDE}
	a_n(t)y^n(t) + a_{n-1}(t)y^{n-1}(t) + \dots + a_1(t)y'(t) + a_0(t)y(t) = g(t)
\end{equation}

On the left-hand side of the linear equation~\ref{eq_linearDE}, the expression is a collection of terms. Each term consists of a coefficient and a derivative of the dependent variable. With ideas of term, coefficient, and derivative, we create new data types to mimic the mathematical expression of a linear ODE. The following is the detail of the code for new data types and operators.

\begin{haskell1}
type Unknown = Integer
data Term = T{
	_coeff :: Expr,
	_unk :: Unknown
}
type LHS = [Term]

($^^) :: ConstrConcept -> Integer -> Unknown
($^^) _ unk' = unk'

($*) :: Expr -> Unknown -> Term
($*) = T

($+) :: [Term] -> Term -> LHS
($+) xs x  = xs ++ [x]
\end{haskell1}

For new types, the \verb|LHS|, the short name for the left-hand side, is a list of \verb|Term|. Each \verb|Term| has an \verb|Expr| and \verb|Unknown|. For new operators, they are inspired by the linear equation~\ref{eq_linearDE}. The \verb|$^^| operator connects a dummy dependent variable and the order of its derivative. We call it a dummy dependent variable because it is a placeholder to increase users' readability. The \verb|$*| operator creates a term by combining a coefficient matrix and an unknown variable. Last, the \verb|$+| operator connects all terms. Let's write pseudo code for the example matrix form~\ref{eq_odeexmaple} in the newly introduced input language. The full detail of the input language for the PDController example will show up in ~\ref{code_scexinputl}.

\begin{listing}
\begin{haskell1}
lhs = [1 $* (y_t $^^ 2)]
	$+ (1 + K_d) $* (y_t $^^ 1)
	$+ (20 + K_p) $* (y_t $^^ 0)
rhs = r_t K_p
\end{haskell1}
\captionof{listing}{Input language for the example~\ref{eq_odeexmaple}}
\label{code_exinputl}
\end{listing}

\section{Two Constructors}
There are two constructors to create a \verb|DifferentialModel|, which they use for different design purposes. The first constructor is \verb|makeASystemDE|. A user can set the coefficient matrix, unknown vector, and constant vector by explicitly giving \verb|[[Expr]]|, \verb|[Unknown]|, and \verb|[Expr]|. There will be several guards to check whether inputs are well-formed.

1. The coefficient matrix and constant vector dimension need to match. The \verb|_coefficients| is an m * n matrix, and \verb|_dmConstants| is an m vector. This guard makes sure they have the same m dimension. If an error says ``Length of coefficients matrix should equal to the length of the constant vector.'', it means \verb|_coefficients| and \verb|_dmConstants| has different m dimension, violating mathematical rules.

2. The dimension of each row in the coefficient matrix and unknown vector need to match. The \verb|_coefficients| use a list of lists to represent an m * n matrix. It means each list in \verb|_coefficients| will have the same length n, and \verb|_unknowns| is an n-vector. Therefore, the length of each row in the \verb|_coefficients| should equal the length of \verb|_unknowns|. If an error says, ``The length of each row vector in coefficients need to equal to the length of unknowns vector.'', it means \verb|_coefficients| and \verb|_unknowns| violate mathematical rules.

3. The order of the unknown vector needs to be descending due to design decisions. We have no control over what users will give to us, and there are infinite ways to represent a linear equation in the matrix form~\ref{eq_matrixform}. We strictly ask users to input the unknown vector descending, so we can maintain the shape of a normal form of linear ODE~\ref{eq_linearDE}. This design decision will simplify the implementation for solving a linear ODE numerically in Chapter 3. If an error says, ``The order of giving unknowns needs to be descending.'', it means the order of unknown vector is not descending.

The following pseudo-code shows how to directly set the example~\ref{eq_odeexmaple}'s coefficient matrix, unknown vector, and constant vector. The full detail of how to directly set the coefficient matrix, unknown vector, and constant vector for the PDContoller example will show up in the Appendix~\ref{code_scexmatrix}.

\begin{haskell1}
coefficent = [[1, 1 + K_d, 20 + K_p]]
unknowns   = [2, 1, 0]
constants  = [r_t K_p]
\end{haskell1}

The second constructor is called \verb|makeASingleDE|. This constructor uses the input language~\ref{sec_input} to simplify the input of a single ODE. In \verb|makeASingleDE|, we create the coefficient matrix, unknown vector, and constant vector based on restricted inputs. In other words, users can no longer set the data by directly giving values. The \verb|DifferentialModel| will generate all data for the coefficient matrix, unknown vector, and constant vector accordingly. The constructor first creates a descending unknown vector base on the highest number of its derivatives. 

To take the code~\ref{code_exinputl} as an example, the highest order of its derivative on the left-hand side of the equation is 2, so we will generate the unknown vector, and it is a list that contains 2, 1 and 0. Then, we will create the coefficient matrix by finding its related coefficient based on the descending order of the unknown vector. The main advantage of this design decision is that the \verb|DifferentialModel| will no longer require users to input the unknown vector in descending order. Any order of the unknown vector will be acceptable because we will generate relative data in \verb|DifferentialModel|. The pseudo-code~\ref{code_exinputl} shows how to use the input language to set the example~\ref{eq_odeexmaple}'s coefficient matrix, unknown vector, and constant vector. The full detail of how to use the input language set the coefficient matrix, unknown vector, and constant vector for the PDContoller example will show up in the Appendix ~\ref{code_scexinputl}.

\section{Display Matrix}
After a \verb|DifferentialModel| obtains ODE information, we want to display them in the software requirements specification (SRS). Previously, we mentioned the Drasil framework able to generate software artifacts, and SRS is a part of them. This section will discuss two ways to display ODEs in the SRS.

1. We can display ODEs in a matrix form. The matrix form~\ref{eq_matrixformexmaple} demonstrates how the ODE will appear in a matrix form in the SRS. In the \verb|DifferentialModel|, the coefficient matrix is a list of lists expression, the unknown vector is a list of integers, and the constant vector is a list of expressions. It should be fairly straightforward for the Drasil printer to display them by printing each part sequentially.

2. We also can display ODEs in a shape of a linear equation. The example~\ref{eq_odeexmaple} demonstrates how the ODE will show up in the shape of a linear equation in the SRS. Displaying a single ODE in a linear equation is a special case. When there is only one single ODE, it would be over complicated to display it in a matrix form. This is the same reason we want to create an input language to manage the input of a single ODE better.

In the future, the Drasil team wants to explore more variability in displaying ODEs. One topic highlighted in the discussion is showing an ODE in a canonical form. However, many mathematicians have different opinions on a canonical form, and the name of canonical form has been used differently, such as normal form or standard form. More research on this part would help us better understand the knowledge of ODE.
