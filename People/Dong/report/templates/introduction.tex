\chapter{Introduction}
From the Industrial Revolution (1760-1840) to the mass production of automobiles that we have today, human beings never lack innovation to improve the process. In the Industrial Revolution, we start to use machines to replace human labour. Today, we have been building assembly lines and robots in the automobile industry to reach a scale of massive production. Hardware automation has been relatively successful in the past one hundred years, and they have been producing mass products for people at a relatively low cost. With the success story of automating hardware, could software be the next one? Nowadays, the software is used every day in our daily life. Most software still requires a human being to write them. Programmers usually write software in a specific language and produce other byproducts during development time. Whether in an enterprise or research intuition, manually creating software prone to errors, and it is not as efficient as a code generator. In the long term, a stable code generator usually beats programmers in performance. They will eventually bring the cost down because of the labour cost reduction. Perhaps this is why human beings consistently seek to automate work. History demonstrates that we successfully automate hardware. With fairly well-understood knowledge of software, creating a comprehensive system to produce software is not impossible. Can you imagine that programmers no longer programming in the future world? In the future world, code generators will generate software. There will be a role called "code alchemist" who is responsible write the recipe for the code generator. The recipe will dictate what kind of software people want. In other words, the recipe is also a software requirement document that the code generator can understand. The recipe can exist in the form of a high-end programming language. Once the code generator receives the recipe, it will automatically produce software artifacts. The code generator exists in the form of a compiler. The described above is revolutionary if there is such a code generator, and the Drasil framework could be it.

The Drasil is a framework that generates software, including code, documentation, software requirement specification, user manual, axillary files, and so on. We call those artifacts software artifacts. By now, the Drasil framework targets generating software to overcome scientific problems. Recently, the Drasil team has been interested in expanding its knowledge to solve a high-order ordinary differential equation (ODE) through external libraries. There are two main reasons why we want to do that.

1. Scientists and researchers frequently use ODE as a research model in scientific problems, and this model describes the nature phenomenons. Building a research model in software is relatively common, and the software that the Drasil framework generates can solve scientific problems. Thus, expanding the Drasil framework's potential to solve all ODE would solve many scientific problems. Currently, the Drasil can only solve first-order ODEs.

2. Many external libraries are hard to write and embody much knowledge, so the Drasil team wants to re-use them instead of reproducing them. Among many external libraries, libraries that solve ODEs are probably the most important ones. Another reason is that the Drasil team is interested in how the Drasil framework interacts with external libraries. Once the team understands how to interact between the Drasil framework and external libraries, they will start to add more external libraries. In this way, it would unlock the potential to allow the Drasil framework to solve more scientific problems than before. 

However, the Drasil framework neither captures ODE knowledge nor solves high-order ordinary differential equations. The previous researcher researched to solve a first-order ODE, but it only covers a small area of the knowledge of ordinary differential equations. Adding high-order linear ODEs into the Drasil framework will expand the area where it has never reached before. Therefore, my research will incorporate high-order linear ODEs in a complex knowledge-based and generative environment that can link to externally provided libraries.

To solve a high-order linear ODE, we have to represent ODEs in the Drasil database. On the one hand, users can input an ODE as naturally as writing an ODE in mathematical expressions. On the other hand, they can display the ODE in conventional mathematical expressions. The data represented will preserve the relationship between each element in the equations. Then, we will analyze the commonality and variability of selected four external libraries. This analysis will lead us to know how external libraries solve ODEs, what their capabilities are, what options we have, and what interfaces look like. Last, we need to bridge the gap between the Drasil ODE data representation and external libraries. The Drasil ODE data representation can not directly communicate with external libraries. Each library has its standard in terms of solving ODEs. The existing gap requires a transformation from Drasil ODE data representation to a generic data form before solving ODE in each programming language. Finally, users can run software artifacts to get the numerical solution of the ODE.

Before conducting my research, the Drasil framework can solve explicit equations and numerically solve a first-order ODE. After my research, the Drasil framework will have full capability to solve a high-order linear ODE numerically. In addition, we will explore the possibility of solving a system of ODE numerically. We will introduce a new case study, the double pendulum. It contains an example that solves a system of high-order non-linear ODE.

Chapter 1 will cover how to represent the data of linear ODE in Drasil. Then, in Chapter 2, we will analyze external libraries. In Chapter 3, we will explore how to connect the Drasil ODE data representation with external libraries. Last, we will discuss a user's choice to solve ODE differently in the Drasil framework.