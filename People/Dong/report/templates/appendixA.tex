\chapter{Your Appendix}
\label{appendix_a}

This appendix provides detailed explanations of various parts of DifferentialModel.

\section{Constructors of DifferentialModel}

\begin{listing}
\begin{haskell1}
-- $K_d$ is qdDerivGain
-- $y_t$ is opProcessVariable
-- $K_p$ is qdPropGain
-- $r_t$ is qdSetPointTD
imPDRC :: DifferentialModel
imPDRC = makeASingleDE
	time
	opProcessVariable
	lhs
	rhs
	"imPDRC"
	(nounPhraseSP "Computation of the Process Variable as a function of time")
	EmptyS
	where 
	lhs = [exactDbl 1 `addRe` sy qdDerivGain $* (opProcessVariable $^^ 1)]
	$+ (exactDbl 1 $* (opProcessVariable $^^ 2))
	$+ (exactDbl 20 `addRe` sy qdPropGain $* (opProcessVariable $^^ 0))
	rhs = sy qdSetPointTD `mulRe` sy qdPropGain
\end{haskell1}
\captionof{listing}{Using input language for the example~\ref{eq_odeexmaple} in DifferentialModel}
\label{code_scexinputl}
\end{listing}

\begin{listing}
\begin{haskell1}
imPDRC :: DifferentialModel
imPDRC = makeASystemDE
	time
	opProcessVariable
	coeffs = [[exactDbl 1, exactDbl 1 `addRe` sy qdDerivGain, exactDbl 20 `addRe` sy qdPropGain]]
	unknowns = [2, 1, 0]
	constants = [sy qdSetPointTD `mulRe` sy qdPropGain]
	"imPDRC"
	(nounPhraseSP "Computation of the Process Variable as a function of time")
	EmptyS
\end{haskell1}
\captionof{listing}{Explicitly set values for the example~\ref{eq_odeexmaple} in DifferentialModel}
\label{code_scexmatrix}
\end{listing}

\section{Numerical Solution implementation}

\begin{listing}
\begin{python1}
def f(t, y_t):
  return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
\end{python1}
\captionof{listing}{Source code of solving PDController in Scipy}
\label{code_pythonscipy}
\end{listing}

In line 1, \verb|func_y_t| is a function output the numerical solution, and it is a list of numbers. In the line 2, the local function \verb|f| contains ODE. The line 3 shows local function return a list. Since we want to solve a system of ODE, the index one is the first ODE in this system, and the index two is the second ODE this system. By calling \verb|scipy.integrate.ode|, we pack ODE information in the generic interface. The line between 5 and 10, are procedure how to set configuration and collecting results. Theoretically, we can just return the \verb|r| in line 4 to present returning a function of ODE.

\begin{listing}
\begin{java1}
public void computeDerivatives(double t, double[] y_t, double[] dy_t) {
  dy_t[0] = y_t[1];
  dy_t[1] = -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p;
}
\end{java1}
\captionof{listing}{A linear system of first-order representation in ACM}
\label{code_javaacm}
\end{listing}

\begin{listing}
\begin{cplusplus1}
void ODE::operator()(vector<double> y_t, vector<double> &dy_t, double t) {
  dy_t.at(0) = y_t.at(1);
  dy_t.at(1) = -(1.0 + K_d) * y_t.at(1) + -(20.0 + K_p) * y_t.at(0) + r_t * K_p;
}	
\end{cplusplus1}
\captionof{listing}{A linear system of first-order representation in ODEINT}
\label{code_cplusplusodeint}
\end{listing}

\begin{listing}
\begin{csharp1}
Func<double, Vector, Vector> f = (t, y_t_vec) => {
  return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
};
\end{csharp1}
\captionof{listing}{Source code of solving PDController in OSLO}
\label{code_csharposlo}
\end{listing}
