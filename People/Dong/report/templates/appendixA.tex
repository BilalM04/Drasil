\chapter{Your Appendix}
\label{appendix_a}

This appendix provides detailed explanations of various parts of DifferentialModel.

\section{Type in DifferentialModel}
\begin{table}
	\begin{tabular}{ p{0.2\textwidth} p{0.7\textwidth} }
		\textbf{Type} & \textbf{Semantics} \\
		\toprule
		\verb|UnitalChunk| & concepts with quantities that must have a unit definition.\\
		\verb|ConstrConcept| & conceptual symbolic quantities with Constraints and maybe a reasonable value.\\
		\verb|Expr| & a type encode mathematical expression. \\
		\verb|ConceptChunk| & a concept that contains an idea, a definition, and an associated domain of knowledge\\
        \verb|Unknown|& synonym of Integer\\
		\bottomrule	
	\end{tabular}	
	\caption{Type use in DifferentialModel}	
	\label{tab_demodeltype}
\end{table}

\begin{listing}
\begin{haskell1}
-- $K_d$ is qdDerivGain
-- $y_t$ is opProcessVariable
-- $K_p$ is qdPropGain
-- $r_t$ is qdSetPointTD
lhs = [exactDbl 1 $* (opProcessVariable $^^ 2)]
	$+ (exactDbl 1 `addRe` sy qdDerivGain $* (opProcessVariable $^^ 1))
	$+ (exactDbl 20 `addRe` sy qdPropGain $* (opProcessVariable $^^ 0))
rhs = sy qdSetPointTD `mulRe` sy qdPropGain
\end{haskell1}
\captionof{listing}{Source code of input language for the example~\ref{eq_odeexmaple}}
\label{code_scexinputl}
\end{listing}

\begin{listing}
\begin{haskell1}
coeffs = [[exactDbl 1, exactDbl 1 `addRe` sy qdDerivGain, exactDbl 20 `addRe` sy qdPropGain]]
unknowns = [opProcessVariable $^^ 2, opProcessVariable $^^ 1, opProcessVariable $^^ 0]
constants = [sy qdSetPointTD `mulRe` sy qdPropGain]
\end{haskell1}
\captionof{listing}{Source code of directly setting for the example~\ref{eq_odeexmaple}}
\label{code_scexmatrix}
\end{listing}

\begin{listing}
\begin{python1}
def func_y_t(K_d, K_p, r_t, t_sim, t_step):
	def f(t, y_t):
		return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
	r = scipy.integrate.ode(f)
	r.set_integrator("dopri5", atol=Constants.Constants.AbsTol, rtol=Constants.Constants.RelTol)
	r.set_initial_value([0.0, 0.0], 0.0)
	y_t = [[0.0, 0.0][0]]
	while r.successful() and r.t < t_sim:
		r.integrate(r.t + t_step)
		y_t.append(r.y[0])
	return y_t
\end{python1}
\captionof{listing}{Source code of solving PDController in Scipy~\ref{eq_odeexmaple}}
\label{code_pythonscipy}
\end{listing}

In line 1, \verb|func_y_t| is a function output the numerical solution, and it is a list of numbers. In the line 2, the local function \verb|f| contains ODE. The line 3 shows local function return a list. Since we want to solve a system of ODE, the index one is the first ODE in this system, and the index two is the second ODE this system. By calling \verb|scipy.integrate.ode|, we pack ODE information in the generic interface. The line between 5 and 10, are procedure how to set configuration and collecting results. Theoretically, we can just return the \verb|r| in line 4 to present returning a function of ODE.

\begin{listing}
\begin{csharp1}
public static List<double> func_y_t(double K_d, double K_p, double r_t, double t_sim, double t_step) {
	List<double> y_t;
	Func<double, Vector, Vector> f = (t, y_t_vec) => {
		return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
	};
	Options opts = new Options();
	opts.AbsoluteTolerance = Constants.AbsTol;
	opts.RelativeTolerance = Constants.RelTol;
	Vector initv = new Vector(new double[] {0.0, 0.0});
	IEnumerable<SolPoint> sol = Ode.RK547M(0.0, initv, f, opts);
	IEnumerable<SolPoint> points = sol.SolveFromToStep(0.0, t_sim, t_step);
	y_t = new List<double> {};
	foreach (SolPoint sp in points) {
		y_t.Add(sp.X[0]);
	}
	return y_t;
}
\end{csharp1}
\captionof{listing}{Source code of solving PDController in OSLO~\ref{eq_odeexmaple}}
\label{code_csharposlo}
\end{listing}
