\chapter{Connect Model to Libraries}
In chapter 2, we stored the information of a higher-order linear ODE in the \verb|DifferentialModel|. This data type preserve the relationship of the ODE, and we can transform the ODE to other forms. In chapter 3, we discuss how to solve a system of first-order ODEs numerically in four selected external libraries. What we have not discussed is that how to close the gap between the \verb|DifferentialModel| and external libraries so the Drasil framework can generate a program to solve a high-order ODE numerically. All external libraries do not understands what is a \verb|DifferentialModel|, so this is the problem we are going to solve in this chapter. What we know is that most way for solving ODEs are intended for first-order ODEs, and we can covert most higher-order ODEs to a system of first-order ODEs~\citep{converthigherode}. Therefore, the methodology we use in this chapter is first transform a higher-order linear ODE to a system of first-order ODEs. Then, using the external libraries to solve the system of first-order ODEs. The original higher-order linear ODE is equivalent to the system of first-order ODEs. Thus, by transitivity, the numerical solution for the system of first-order ODEs is also the numerical solution of the higher-order ODE.

In this chapter, we will first discuss how to convert a higher-order linear ODE to a system of first order equations in theory. Then, we will talk about how to connect explicit equation with external libraries. Last, we will discuss how to generate explicit equation base on \verb|DifferentialModel|.

\section{Higher Order to First Order}
\label{se_hightofirst}
Given a higher-order ODE, we can write it in form of the equation~\ref{eq_isohighode}. We put the highest derivative $x^n$ on the left hand side, and the rest of terms on right hand side. On the right hand side, $f (t, x, x', x'', \dots, x^{n-1})$ means a function depends on variables t, x, x', \dots, and $x^{n-1}$. The t is independent variable and it is time. The x, x', \dots, and $x^{n-1}$ means the dependent variable x, first derivative of x, and until n-1 derivative.
\begin{equation} \label{eq_isohighode}
  x^n = f (t, x, x', x'', \dots, x^{n-1})
\end{equation}

Later, we introduce new variables, $y_{1}$, $y_{2}$, $\dots$, and $y_{n}$. The number of newly introduced dependent variable is equal to the highest order of the ODE. The new relationship show at below.
\begin{flalign} \label{eq_newvars}
  & y_{1} = x \\ \nonumber
  & y_{2} = x' \\ \nonumber
  & \dots \\ \nonumber
  & y_{n} = x^{n-1} 
\end{flalign}

Now, we can start differentiate $y_{1}$, $y_{2}$, $\dots$, and $y_{n}$ in equation~\ref{eq_newvars}. Then, we get new relationship between each variable.
\begin{flalign} \label{eq_diffvervars}
  & y_{1}' = x' = y_{2} \\ \nonumber
  & y_{2}' = x'' = y_{3} \\ \nonumber
  & \dots \\ \nonumber
  & y_{n-1}' = x^{n-1} = y^{n}\\ \nonumber
  & y_{n}' = x^{n} = f (t, y_{1}, y_{2}, \dots, y_{n})
\end{flalign}

The $f (t, y_{1}, y_{2}, \dots, y_{n})$ is a linear function, and we can rewrite them as the following
\begin{equation}\label{eq_linear}
h(t) + g_{1}(t) \cdot y_{1} + g_{2}(t) \cdot y_{2} + \dots + g_{n}(t) \cdot y_{n}
\end{equation}

Based on the equation~\ref{eq_diffvervars}, we can simplify equations by removing derivatives of x and replace $f (t, y_{1}, y_{2}, \dots, y_{n})$ with equation~\ref{eq_linear}. Then, we can get:
\begin{flalign} \label{eq_diffvervarslinear}
    & y_{1}' = y_{2} \\ \nonumber
    & y_{2}' = y_{3} \\ \nonumber
    & \dots \\ \nonumber
    & y_{n-1}' = y^{n}\\ \nonumber
    & y_{n}'= h(t) + g_{1}(t) \cdot y_{1} + g_{2}(t) \cdot y_{2} + ... + g_{n}(t) \cdot y_{n}
\end{flalign}

Last, we can rewrite Equation~\ref{eq_diffvervarslinear} in a matrix form.
\begin{equation} \label{eq_foodeexample}
	\begin{bmatrix}
		y_{1}' \\
    y_{2}' \\
    \dots  \\
    y_{n-1}' \\
    y_{n}'
	\end{bmatrix}
    = 
  \begin{bmatrix}
		0, & 1, & 0, & \dots, & 0 \\
    0, & 0, & 1, & \dots, & 0 \\
    \dots \\
    0, & 0, & 0, & \dots, & 1 \\
    g_{1}(t), & g_{2}(t), & g_{3}(t), & \dots, & g_{n}(t)
	\end{bmatrix}
    \cdot
  \begin{bmatrix}
		y_{1} \\
    y_{2} \\
    \dots  \\
    y_{n-1} \\
    y_{n}
	\end{bmatrix}
    + 
  \begin{bmatrix}
    0 \\
    0 \\
    \dots  \\
    0 \\
    h(t)
	\end{bmatrix}
\end{equation}

Lastly, we abstract Equation~\ref{eq_foodeexample} into a general form, Equation~\ref{eq_foode}. The \textbf{A} is a coefficient matrix, and \textbf{c} is a constant vector. The \textbf{X} is the unknown vector contains functions of the independent variable, often time. The \textbf{X}' is a vector that consist of first derivative of functions in \textbf{X}.
\begin{equation} \label{eq_foode}
    \boldsymbol{X}' = \boldsymbol{AX} + \boldsymbol{c}
\end{equation}

Once we completed the transformation and get a system of first-order ODE in shape of Equation~\ref{eq_foode}. We encode it in Drasil and pass it to Drasil Code Generator. In the \href{https://jacquescarette.github.io/Drasil/examples/pdcontroller/SRS/srs/PDController_SRS.html#Sec:IMs}{PDContoller case study}, we convert Example~\ref{eq_odeexmaple} to Example~\ref{ex_firstorderode}. Then, we generate a program to solve Example~\ref{ex_firstorderode} numerically. By transitivity, the numerical solution is valid for Example~\ref{eq_odeexmaple} as well.

\section{Connect Explicit Equations to Libraries}
\label{se_connecteetolib}

In previous research, conducted by Brooks, we write the ODEs in a text-based form and store it in a general data pool. Although, the Drasil printer is capable to print ODEs in a SRS, the Drasil Code Generator unable to understand the ODEs in a text-based form. To make study case work, we manually recreate an object (\verb|ODEInfo|) based on the original ODE. Then, the Drasil Code Generator take the new object and generate a solution program. The detail on 
how to generate external libraries in code can be found on Brooks's thesis~\citep{brooks}. However, the previous research only complete generating external libraries for a first-order ODE. For a higher-order ODE, even we convert it to a system of first-order ODE in \verb|ODEInfo|, the Code Generator still unable to generate proper software. The Code Generator unable to retrieve proper initial values when there are more than one initial value. Therefore, we change the type of the initial value to a new type which can hold for multiple values. 


\begin{listing}[ht]
\begin{haskell1}
-- Old 
data ODEInfo = ODEInfo {
  ...
  initVal :: CodeExpr
  ...
}

-- New 
data ODEInfo = ODEInfo {
  ...
  initVal :: [CodeExpr],
  ...
}
\end{haskell1}
\end{listing}

The \verb|ODEInfo| is a datatype store the initial value, we can change the type to be a list. This will enable to store multiple initial values in this data type. Then, we have to make sure the Code Generator know how to handle the type of initial values. 

\begin{listing}[ht]
\begin{haskell1}
-- Old 
initVal info

-- New 
matrix[initVal info]  
\end{haskell1}
\end{listing}

In Drasil Code Generator, we use matrix to represent a list. A list is a special case of matrix which dimension is 1. The info is a data type \verb|ODEInfo|, the code \verb|initVal info| retrieve the initVal from \verb|ODEInfo|. In the new code, the type of initVal is no longer \verb|CodeExpr| but a list of \verb|CodeExpr|. Therefore we change wrap \verb|initVal| in a \verb|matrix|.

\begin{listing}[ht]
\begin{python1}
# Old 
  r.set_initial_value(T_init, 0.0)
  T_W = [T_init]

# New 
  r.set_initial_value([T_init], 0.0)
  T_W = [[T_init][0]]
\end{python1}
\end{listing}

the \verb|set_initial_value| will take a list of initial values instead of just one. \verb|T_W| is collection of the numerical solution. Initial values also is a part of numerical solution, so we have to add the proper initial value to the list.

\begin{listing}[ht]
\begin{csharp1}
// Old 
Vector initv = new Vector(T_init);

// New 
Vector initv = new Vector(new double[] {T_init});
\end{csharp1}
\end{listing}

In Java and C\texttt{++}, the backend code already handle the initial value as a list, so there is no change in artifact for those two languages. 

The implementation unlocks the potential for Drasil to solve any higher-order ODE with its equivalent first-order ODE. This include a higher-order non-linear ODE. Despite the \href{https://jacquescarette.github.io/Drasil/examples/dblpendulum/SRS/srs/DblPendulum_SRS.html#Sec:IMs}{Double Pendulum case study} contains a higher-order non-linear ODE, the Drasil framework now can generate a program to solve it numerically. In the double pendulum case study, we eventually want to solve Equation~\ref{eq_dblpenhigh}. There are two second-order ODEs in one system. To solve this system of ODE, we can convert them into a system of first-order ODE. The transformation follow the methodology we discussed in Section~\ref{se_hightofirst}. We can covert Equation~\ref{eq_dblpenhigh} into Equation~\ref{eq_dblpenfirst}. However, we cannot show Equation~\ref{eq_dblpenfirst} in shape of Equation~\ref{eq_foode} because the ODE is not a linear ODE. Once the transformation complete, we can encode Equation~\ref{eq_dblpenfirst}, and ready pass it to the Drasil Code Generator.

\begin{flalign} \label{eq_dblpenhigh}
& \theta_{1}'' = \frac{-g(2m_{1}+m_{2})\sin \theta_{1}-m_{2}g\sin (\theta_{1}-2\theta_{2})-2\sin (\theta_{1}-\theta_{2})m_{2}({\theta_{2}'}^2L_{2}+{\theta_{1}'}^2L_{1}\cos (\theta_{1}-\theta_{2}))}{L_{1}(2m_{1}+m_{2}-m_{2}\cos (2\theta_{1}-2\theta_{2}))} \\ \nonumber
& \theta_{2}'' = \frac{2\sin (\theta_{1}-\theta_{2})({\theta_{1}'}^2L_{1}(m_{1}+m_{2})+g(m_{1}+m_{2})\cos \theta_{1} + {\theta_{2}'}^2L_{2}m_{2}\cos (\theta_{1}-\theta_{2}))}{L_{2}(2m_{1}+m_{2}-m_{2}\cos (2\theta_{1}-2\theta_{2}))}
\end{flalign}

\begin{flalign} \label{eq_dblpenfirst}
  & \theta_{1}' = \omega_{1} \\ \nonumber
  & \theta_{2}' = \omega_{2} \\ \nonumber
  & \omega_{1}' = \frac{-g(2m_{1}+m_{2})\sin \theta_{1}-m_{2}g\sin (\theta_{1}-2\theta_{2})-2\sin (\theta_{1}-\theta_{2})m_{2}({\omega{2}}^2L_{2}+{\omega{1}}^2L_{1}\cos (\theta_{1}-\theta_{2}))}{L_{1}(2m_{1}+m_{2}-m_{2}\cos (2\theta_{1}-2\theta_{2}))} \\ \nonumber
  & \omega_{2}' = \frac{2\sin (\theta_{1}-\theta_{2})({\omega_{1}}^2L_{1}(m_{1}+m_{2})+g(m_{1}+m_{2})\cos \theta_{1} + {\omega_{2}}^2L_{2}m_{2}\cos (\theta_{1}-\theta_{2}))}{L_{2}(2m_{1}+m_{2}-m_{2}\cos (2\theta_{1}-2\theta_{2}))}
\end{flalign}

The following is an example how we encode Equation~\ref{eq_dblpenfirst} in the Drasil. 
\begin{listing}[ht]
\begin{haskell1}
dblPenODEInfo :: ODEInfo
dblPenODEInfo = odeInfo
...
[3*π/7, 0, 3*π/4, 0]
[ ω₁,
  -g(2m₁ + m₂)sin θ₁ - m₂gsin (θ₁ - 2θ₂) - 2sin (θ₁ - θ₂)m₂(ω₂²L₂ + ω₁²L₁cos (θ₁ - θ₂)) / L₁(2m₁ + m₂ -m₂cos (2θ₁ - 2θ₂)),
  ω₂,
  2sin (θ₁ - θ₂)(ω₁²L₁(m₁ + m₂ ) + g(m₁ + m₂ )cos θ₁ + ω₂²L₂m₂cos (θ₁ - θ₂ )) / L₂(2m₁ + m₂ -m₂cos (2θ₁ - 2θ₂))
]
...
\end{haskell1}
\end{listing}

Once the \verb|dblPenODEInfo| is ready, we will pass it to the Drasil Code generator. We generate the program solve double pendulum in four languages. The detail of each artifacts captured ODE information will show in Appendix A (link)

The limitation with manually created \verb|ODEInfo| is that there we will write the ODE twice. In this case, we encode both Equation~\ref{eq_dblpenhigh} and Equation~\ref{eq_dblpenfirst} in Drasil. They both demonstrate the phenomena of double pendulum, and exist in an isomorphic ODE type. In the next section, we would like to discuss how to automate the transformation from a higher-order ODE to a system of first-order ODE.

\section{Generate Explicit Equations}
This process is not ideal because propagates duplicate information. We want to design the Drasil framework to be as fully automatic as possible, so we want to remove human interference.

talk the scope, only for a single high-order ODE, not for a system of high-order ODE

generate equations
reduce duplication

However, the Double Pendulum case study unable to utilize any function in \verb|DifferentialModel| because it was designed for a linear ODE. Further research is required.

\begin{equation} \label{eq_foodeexample}
	\begin{bmatrix}
		\highlight{yellow}{y_{1}'} \\
    \highlight{yellow}{y_{2}'} \\
    \highlight{yellow}{\dots} \\
    \highlight{yellow}{y_{n-1}'} \\
    \highlight{yellow}{y_{n}'}
	\end{bmatrix}
    = 
  \begin{bmatrix}
		\highlight{orange}{0}, & \highlight{orange}{1}, & \highlight{orange}{0}, & \highlight{orange}{\dots}, & \highlight{orange}{0} \\
    \highlight{orange}{0}, & \highlight{orange}{0}, & \highlight{orange}{1}, & \highlight{orange}{\dots}, & \highlight{orange}{0} \\
    \highlight{orange}{\dots} \\
    \highlight{orange}{0}, & \highlight{orange}{0}, & \highlight{orange}{0}, & \highlight{orange}{\dots}, & \highlight{orange}{1} \\
    \highlight{cyan}{g_{1}(t)}, & \highlight{cyan}{g_{2}(t)}, & \highlight{cyan}{g_{3}(t)}, & \highlight{cyan}{\dots}, & \highlight{cyan}{g_{n}(t)}
	\end{bmatrix}
    \cdot
  \begin{bmatrix}
		\highlight{yellow}{y_{1}} \\
    \highlight{yellow}{y_{2}} \\
    \highlight{yellow}{\dots} \\
    \highlight{yellow}{y_{n-1}} \\
    \highlight{yellow}{y_{n}}
	\end{bmatrix}
    + 
  \begin{bmatrix}
    \highlight{lightgray}{0} \\
    \highlight{lightgray}{0} \\
    \highlight{lightgray}{\dots} \\
    \highlight{lightgray}{0} \\
    \highlight{red}{h(t)}
	\end{bmatrix}
\end{equation}

generate yellow X' and X
In the yellow highlight part, They highlighted the X' and X in Equation~\ref{eq_foode}. X' and X are fairly predictable. The length of X' and X depend on how many new dependent variables introduces. If the higher-order ODE is second-order, there will be two new dependent variables be introduced and the length of X' and X will be 2. If the higher-order ODE is nth-order, there will be n new dependent variables be introduced and the length of X' and X will be n. For X', known it is n-th order ODE, we parameterize $y'$ from 1 to n. For X, known it is n-th order ODE, we parameterize $y$ from 1 to n.

generate orange identity matrix 
The A contain highlighted in orange and blue. The orange highlighted the identity matrix. The identity matrix has its pattern. The first row contains minimum 0, 1, and (n-2)th 0 append to [0, 1]. If there is a second identity row, it contain 0, 0 ,1 and append (n-3)th 0 to [0, 0 ,1]. The identity matrix has n-1 rows with n length.

generate gray identity in c
the minimum [0, h(t)], and (n-2) add before [0, h(t)]

generate cyan and red
blue and red can be determine by known relation with 

\begin{equation}
  y_{n}' = x^{n} = f (t, y_{1}, y_{2}, \dots, y_{n}) = h(t) + g_{1}(t) \cdot y_{1} + g_{2}(t) \cdot y_{2} + ... + g_{n}(t) \cdot y_{n}
\end{equation}
