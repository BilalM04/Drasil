\chapter{External libraries}
The external library comes from an outside source, and it is not originate from the source project. Thus, we will generate interfaces to interact with selected libraries. Most libraries are language dependent, and the Drasil framework can generate five different languages, includes Python, Java, C++, C\#, and Swift. Among those five languages, four programming languages have ODE libraries to solving ODEs. In Python, Scipy Library~\citep{scipy} is a well-known scientific libraries to solving scientific problems, and it has support to solve ODEs. In Java, there is a library called Apache Commons Maths~\citep{apache}, and it is a supplementary library to solve mathematical and statistical problems which build-in Java programming language does not available. It has support to solve ODEs as well. There are two less known libraries work as ODE solver in C++ and C\#, and they are ODEINT Library~\citep{odeint} and OSLO Library~\citep{oslo} respectively. However, we did not find a suitable library for Swift. 

All four selected libraries have some commonalities. Firstly, they provide numerical solution for a system of first-order ODEs. Secondly, they has similar interface for solving ODEs numerically. Last, they has options for selecting different algorithms to solve an ODE. Beside commonalities, they has variability as well. Some libraries provide options to output ODE's solution as a function or a generic class that similar to a function. Outside of external libraries, it is could be a challenge to manage different external libraries inside the Drasil framework. In this Chapter, we will first discuss the commonalities and variabilities of four libraries. Next, we will discuss how the Drasil team manage those libraries.

\section{Numerical Solutions}
The backend mechanism of how each library to get a numerical solution is following by the following ideology. In a ODE, the independent variable is usually time. One way to get get a numerical solution is to get the point value in a certain time point. Therefore, we treat the ODE as an initial value problem. For example, we can assume the start time is zero, and the time interval is a fixed time range. At the time zero, the initial value is given by users. In the next time point, previous time plus a fixed time range, libraries will calculate the numerical solution in this time point. At a certain time point, the next time point would excess the total simulation time of this ODE, then the program will stop. To get a numerical solution in a certain time range, we still need to collect the numerical value in each iteration. 

All four external libraries have is that they provide numerical solutions for a system of first-order ODEs. The following is mathematical expression for a system of first-order ODEs. 

\begin{equation} \label{eq_foode}
    X' = AX + c
\end{equation}

X is the unknown vector that consist of dependent variables. X' is the vector that consist of first derivative of dependent variables. The A is a coefficient matrix, and c is a constant vector. 

% In each implementation, we can treat the dependent values as a list. The first index of the this array indicates the first dependent variable, and the second index of this array indicates the second dependent variable, and so on. Each dependent variable will have its initial value. For example, if there are two dependent variables, there will be two initial values.

\section{Algorithm Options}
algorithm options

improvement: provide range other than a fixed point 

\section{Function vs Points}
The ODE provide mathematical expression for describing a function over time. The numerical solution can instantiate an ODE, but it only provides a partial solution for the ODE. If we are interested in the continuous change of the function, numerous values points will not help. Instead of providing points, providing a function would be a better choice to represent the ODE. In the Drasil framework, users have an option to generate a runnable program or a library. The runnable program will contain main function, so users can run this artifact in the local machine. If it is a library, other outside program can utilize the generated library. Outputting the ODE as a function inclined equal to generate a library.

Not all libraries have options to represent the ODE as a function. Among four libraries, Scipy Library and OSLO Library have similar option to support out put a function. In Scipy library, we can return a generic interface called \verb|scipy.integrate.ode|~\citep{scipyfun}. It is a generic interface can store information preserve the ODE, and later if we want to solve the ODE, we can add other ODE related configuration information afterward.

\begin{python1}
def func_y_t(K_d, K_p, r_t, t_sim, t_step):
    def f(t, y_t):
        return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
    r = scipy.integrate.ode(f)
    r.set_integrator("dopri5", atol=Constants.Constants.AbsTol, rtol=Constants.Constants.RelTol)
    r.set_initial_value([0.0, 0.0], 0.0)
    y_t = [[0.0, 0.0][0]]
    while r.successful() and r.t < t_sim:
        r.integrate(r.t + t_step)
        y_t.append(r.y[0])
    return y_t
\end{python1}

In line 1, \verb|func_y_t| is a function output the numerical solution, and it is a list of numbers. In the line 2, the local function \verb|f| contains ODE. The line 3 shows local function return a list. Since we want to solve a system of ODE, the index one is the first ODE in this system, and the index two is the second ODE this system. By calling \verb|scipy.integrate.ode|, we pack ODE information in the generic interface. The line between 5 and 10, are procedure how to set configuration and collecting results. Theoretically, we can just return the \verb|r| in line 4 to present returning a function of ODE.

\begin{csharp1}
public static List<double> func_y_t(double K_d, double K_p, double r_t, double t_sim, double t_step) {
    List<double> y_t;
    Func<double, Vector, Vector> f = (t, y_t_vec) => {
        return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
    };
    Options opts = new Options();
    opts.AbsoluteTolerance = Constants.AbsTol;
    opts.RelativeTolerance = Constants.RelTol;
    Vector initv = new Vector(new double[] {0.0, 0.0});
    IEnumerable<SolPoint> sol = Ode.RK547M(0.0, initv, f, opts);
    IEnumerable<SolPoint> points = sol.SolveFromToStep(0.0, t_sim, t_step);
    y_t = new List<double> {};
    foreach (SolPoint sp in points) {
        y_t.Add(sp.X[0]);
    }
    return y_t;
}
\end{csharp1}
The function \verb|Ode.RK547M| return an enumerable sequence of solution points, it is a endless sequence of solution points. Later on, we can call \verb|SolveFromToStep| to return a list of points base on start time, end time, and time interval. What \verb|Ode.RK547M| return can be treat as a function of ODE.

\section{Management Libraries}
symbolic links