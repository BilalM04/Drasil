\chapter{External libraries}
The external library comes from an outside source, and it is not originate from the source project. Most libraries are language dependent, and the Drasil framework can generate five different languages, includes Python, Java, C++, C\#, and Swift. Among those five languages, four programming languages have ODE libraries to solving ODEs. In Python, Scipy Library~\citep{scipy} is a well-known scientific libraries for solving scientific problems, and it has support to solve ODEs. In Java, there is a library called Apache Commons Maths(ACM)~\citep{apache}, and it is a supplementary library for solving mathematical and statistical problems which build-in Java programming language does not available. It has support to solve ODEs as well. There are two less known libraries that can solve an ODE in C++ and C\#, and they are ODEINT Library~\citep{odeint} and OSLO Library~\citep{oslo} respectively. Last, we did not find a suitable library for Swift. For those four selected libraries, they have some commonalities and variabilities. Firstly, they all provide a numerical solution for a linear system of first-order ODEs. Each library can output a value of the dependent value at a certain time. We can collect those values in a time range. Secondly, they all provide different algorithms for solving ODEs numerically, we will conduct a rough commonalities analysis on available algorithm. A completed commonality analysis would be too time-consuming, and it is out the scope of my study. Last, Scipy and OSLO Library have potential to output a numerical solution as a function. This discovery will benefit the Drasil framework to generate a library rather than a executable standalone program. Beside commonalities and variabilities, the Drasil team have to learn how to manage external libraries in the Drasil framework.

In this Chapter, we will discuss some topics related to commonalities and variabilities of four libraries, includes numerical solutions, algorithms options and outputting a function. Last, we will discussed how we handle dependencies.

\section{Numerical Solutions}
Numerical solutions use algorithms to make approximation for mathematical equations. All numerical solution are approximation, and some numerical solutions utilize better algorithm can produce a better result than others. All selected libraries provides numerical solution for a linear system of first order ODE. We can write a linear system of first order ODE in shape of 
\begin{equation} \label{eq_foode}
    \boldsymbol{X}' = \boldsymbol{AX} + \boldsymbol{c}
\end{equation}

The \textbf{A} is a coefficient matrix, and c is a constant vector. The \textbf{X} is the unknown vector contains functions of the independent variable, often time. The \textbf{X}' is a vector that consist of first derivative of functions in \textbf{X}. 

The backend mechanism of how each library to get a numerical solution is following by the following ideology. In a ODE, the independent variable is usually time. One way to get get a numerical solution is to get the point value in a certain time point. Therefore, we treat the ODE as an initial value problem. For example, we can assume the start time is zero, and the time interval is a fixed time range. At the time zero, the initial value is given by users. In the next time point, previous time plus a fixed time range, libraries will calculate the numerical solution in this time point. At a certain time point, the next time point would excess the total simulation time of this ODE, then the program will stop. To get a numerical solution in a certain time range, we still need to collect the numerical value in each iteration. 

% In each implementation, we can treat the dependent values as a list. The first index of the this array indicates the first dependent variable, and the second index of this array indicates the second dependent variable, and so on. Each dependent variable will have its initial value. For example, if there are two dependent variables, there will be two initial values.

\section{Algorithm Options}
In reality, we can solve an ODE in many algorithms, such as Adams method. Those four external libraries also provide many algorithms to solve an ODE, and we classified them into five categories, a family of Adams methods, a family of BDF methods, a family of Runge-Kutta methods, a family of Euler method, and Bulirsch-Stoer method, in the Table~\ref{tab_algoexlib}. Moreover, the detail of available algorithm for each library will show up in appendixA.

\begin{table}
    \begin{tabular}{|l||*{5}{c|}}\hline
        \backslashbox{Algorithm}{Library}
        &\makebox[6em]{Scipy-Python}&\makebox[6em]{ACM-Java}&\makebox[6em]{ODEINT-C++}&\makebox[6em]{OSLO-C\#}\\\hline\hline
        Family of Adams & \checkmark & \checkmark & \checkmark &\\\hline
        Family of BDF & \checkmark &&& \checkmark \\\hline
        Family of Runge-Kutta & \checkmark & \checkmark & \checkmark & \checkmark \\\hline
        Gragg-Bulirsch-Stoer && \checkmark & \checkmark &\\\hline
        Family of Euler && \checkmark & \checkmark &\\\hline
    \end{tabular}
	\caption{Algorithm supports for external libraries}	
	\label{tab_algoexlib}
\end{table}

During investigation of algorithms, we found some algorithms use a fixed step size for calculating numerical solution, and others instead of using adaptive size (reference). This discovery can further influence the design choice of solving ODE numerically in the Drasil framework. Currently, Drasil treat all step sizes as a fixed value, and it would be ideal to allow the step size be either fixed or adaptive.

\section{Function vs Points}
The ODE provide mathematical expression for describing a function over time. The numerical solution can instantiate an ODE, but it only provides a partial solution for the ODE. If we are interested in the continuous change of the function, numerous values points will not help. Instead of providing points, providing a function would be a better choice to represent the ODE. In the Drasil framework, users have an option to generate a runnable program or a library. The runnable program will contain main function, so users can run this artifact in the local machine. If it is a library, other outside program can utilize the generated library. Outputting the ODE as a function inclined equal to generate a library.

Not all libraries have options to represent the ODE as a function. Among four libraries, Scipy Library and OSLO Library have similar option to support out put a function. In Scipy library, we can return a generic interface called \verb|scipy.integrate.ode|~\citep{scipyfun}. It is a generic interface can store information preserve the ODE, and later if we want to solve the ODE, we can add other ODE related configuration information afterward. In OSLO library, the function \verb|Ode.RK547M| return an enumerable sequence of solution points, it is a endless sequence of solution points. Later on, we can call \verb|SolveFromToStep| to return a list of points base on start time, end time, and time interval. What \verb|Ode.RK547M| return can be treat as a function of ODE.

\section{Management Libraries}
Once the Drasil framework generate code, the program relay on external libraries to complete calculating ODEs. In the current setting, the Drasil framework keep copies of external libraries in the repository. It is not practical because the amount of space external libraries occupied. Moreover, external libraries do not share across study cases, and each study case will have its copy of external libraries. This research surfaces the current way handles dependencies in Drasil framework is problematic, and the team would like to find a better way to handle dependency. We use a temporary solution, symbolic links, to share external libraries without duplications. By creating a symbolic link file, external libraries become sharable. The team will conduct further study to tackle this problem.
