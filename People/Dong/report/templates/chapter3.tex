\chapter{External libraries}
The external library comes from an outside source, and it is not originate from the source project. Most libraries are language dependent, and the Drasil framework can generate five different languages, includes Python, Java, C++, C\#, and Swift. Among those five languages, four programming languages have ODE libraries to solving ODEs. In Python, Scipy Library~\citep{scipy} is a well-known scientific libraries for solving scientific problems, and it has support to solve ODEs. In Java, there is a library called Apache Commons Maths(ACM)~\citep{apache}, and it is a supplementary library for solving mathematical and statistical problems which build-in Java programming language does not available. It has support to solve ODEs as well. There are two less known libraries that can solve an ODE in C++ and C\#, and they are ODEINT Library~\citep{odeint} and OSLO Library~\citep{oslo} respectively. Last, we did not find a suitable library for Swift. For those four selected libraries, they have some commonalities and variabilities. Firstly, they all provide a numerical solution for a linear system of first-order ODEs. Each library can output a value of the dependent value at a certain time. We can collect those values in a time range. Secondly, they all provide different algorithms for solving ODEs numerically, we will conduct a rough commonalities analysis on available algorithm. A completed commonality analysis would be too time-consuming, and it is out the scope of my study. Last, Scipy and OSLO Library have potential to output a numerical solution as a function. This discovery will benefit the Drasil framework to generate a library rather than a executable standalone program. Beside commonalities and variabilities, the Drasil team have to learn how to manage external libraries in the Drasil framework.

In this Chapter, we will discuss some topics related to commonalities and variabilities of four libraries, includes numerical solutions, algorithms options and outputting a function. Last, we will discussed how we handle dependencies.

\section{Numerical Solutions}
Numerical solutions use algorithms to make approximation for mathematical equations. All numerical solution are approximation, and some numerical solutions utilize better algorithm can produce a better result than others. All selected libraries provides numerical solution for a linear system of first-order ODE as an initial value problem (IVP). The initial value requires an initial condition which specify the value of the function at the start point, and it is contrasting to boundary value problem (BVP). In this research, we are going to solve each scientific problem as an IVP. Let see how to solve a linear system of first-order ODE with an example. Here is an example of a linear system of first-order ODE.
\begin{flalign} \label{ex_firstorderode}
& x_{1}(t)' = x_{2}(t) \\ \nonumber
& x_{2}(t)' = -(1 + K_{d})x_{2}(t) - (20 + K_{p})x_{1}(t) + r_{t} K_{p} 
\end{flalign}

In example~\ref{ex_firstorderode} , there are two dependent variables $x_1$ and $x_2$. The $x_1(t)$ is the function of the independent variable, time, which produces dependent variables $x_1$ over time. The $x_2(t)$ is also the function of the independent variable, time, which produces dependent variables $x_2$ over time. The $x_1'$(t) is the first-order derivative of $x_1$(t). The $x_2'$(t) is the first-order derivative of $x_2$(t). The $K_d$ , $K_p$, and $r_t$ are constant variables, and they remain the same meaning in the example~\ref{eq_odeexmaple} and the example~\ref{ex_firstorderode}. We can encode the example~\ref{ex_firstorderode} in all four libraries.

In the Python, we can write the example as following code:
\begin{python1}
def f(t, y_t):
    return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
\end{python1}

In the Java, we can write the example as following code:
\begin{java1}
public void computeDeriv(double t, double[] y_t, double[] dy_t) {
    dy_t[0] = y_t[1];
    dy_t[1] = -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p;
}
\end{java1}

In the C++, we can write the example as following code:
\begin{cplusplus1}
void ODE::operator()(vector<double> y_t, vector<double> &dy_t, double t) {
    dy_t.at(0) = y_t.at(1);
    dy_t.at(1) = -(1.0 + K_d) * y_t.at(1) + -(20.0 + K_p) * y_t.at(0) + r_t * K_p;
}	
\end{cplusplus1}

In the C\#, we can write the example as following code:
\begin{csharp1}
Func<double, Vector, Vector> f = (t, y_t_vec) => {
    return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
};
\end{csharp1}

Once we capture the information of the system of ODE, we have to given initial condition for solving an ODE as an IVP. To solve the example~\ref{ex_firstorderode}, we have to give the initial value for both $x_1$ and $x_2$. Overall, an ODE is a simulation, and it simulates the change of dependent values over time. Before we start the simulation, there are other configurations need to specify, include start time of the simulation, end time of the simulation, time step between each iteration. We can also given values for the absolute tolerance and related tolerance to each libraries. Those two tolerances control the accuracy of the solution. As we mentioned before, all numerical solutions are approximation. High tolerance produce less accurate solutions, and smaller tolerances produce more accurate solutions. Last, we have to collect the numerical value for each iteration. The full detail on how each libraries solve the example~\ref{ex_firstorderode} will show up in Appendix~\ref{numsol}.

\section{Algorithm Options}
In reality, we can solve an ODE in many algorithms, and those four libraries provide many algorithms. We roughly classified available algorithms into four categories base on the type of algorithm they use. They are a family of Adams methods, a family of backward differentiation formula methods (BDF), a family of Runge-Kutta (RK) methods, and other methods. The commonality analysis on available algorithms is just an approximation, and it is not completed. To get a completed commonality analysis will require some help from domain experts in ODE area. It will far out of my study, so we only provide a rough classification in this study. Although the commonality is not completed, the team still benefit from the current analysis. Not only a future student can quickly access information of which algorithm is available in relative language, but also it remains us that we can increase the consistency of artifacts by providing one to one mapping for each algorithm in four libraries. For example, if a user explicitly choose a family of Adams methods as the targeted algorithm, all available libraries should use a family of Adams methods to solve the ODE. Unfortunately, not all libraries provide a family of Adams methods. Here in the table~\ref{tab_algoexlib}, it shows the availability of approximation of a family of algorithm in each library. The full detail of available algorithm for each library will show up in Appendix~\ref{alg_externallib}.

\begin{sidewaystable}
\begin{adjustbox}{width=\columnwidth,center}
\begin{tabular}{p{0.18\textwidth} | p{0.22\textwidth} p{0.22\textwidth} p{0.29\textwidth} p{0.25\textwidth}}\hline
    \backslashbox{Algorithm}{Library}
    &\textbf{Scipy-Python}&\textbf{ACM-Java}&\textbf{ODEINT-C++}&\textbf{OSLO-C\#}\\
    \toprule
    Family of Adams & 
        \begin{itemize}[wide]
        \item Implicit Adams
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Adams Bashforth
        \item Adams Moulton
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Adams Bashforth Moulton
        \end{itemize} &\\ \hline
    Family of BDF & 
        \begin{itemize}[wide]
        \item BDF
        \end{itemize} &&& 
        \begin{itemize}[wide]
        \item Gearâ€™s BDF
        \end{itemize} \\ \hline
    Family of RK & 
        \begin{itemize}[wide]
        \item Dormand Prince (4)5 
        \item Dormand Prince 8(5,3) 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Explicit Euler
        \item 2ed order
        \item 4th order
        \item Gill fourth order
        \item 3/8 fourth order
        \item Luther sixth order
        \item Higham and Hall 5(4)
        \item Dormand Prince 5(4) 
        \item Dormand Prince 8(5,3) 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Explicit Euler
        \item Implicit Euler
        \item Symplectic Euler
        \item 4th order
        \item Dormand Prince 5
        \item Fehlberg 78
        \item Controlled Error Stepper
        \item Dense Output Stepper
        \item Rosenbrock 4
        \item Symplectic RKN McLachlan 6
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Dormand Prince RK547M
        \end{itemize} \\ \hline
    Others && 
        \begin{itemize}[wide]
        \item Gragg Bulirsch Stoer 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Gragg Bulirsch Stoer 
        \end{itemize} &\\
    \bottomrule	
\end{tabular}
\end{adjustbox}
\caption{Algorithms support in external libraries}	
\label{tab_algoexlib}
\end{sidewaystable}

Last, there are some improvements the Drasil team can make the solution of ODE better. For example, we found some algorithms use a fixed step size for calculating numerical solution, and others instead of using adaptive step size. We add the step size with current time value to calculate the next value of dependent variables. A fixed step size mean the step size is the same in each iteration. A adaptive step size means the step size is not always the same, and it could change base on other factors. This discovery can further influence the design choice of solving ODE numerically in the Drasil framework. Currently, Drasil treat all step sizes as a fixed value, and it would be ideal to allow the step size be either fixed or adaptive in future.

\section{Function vs Points}
The ODE provide mathematical expression for describing a function over time. The numerical solution can instantiate an ODE, but it only provides a partial solution for the ODE. If we are interested in the continuous change of the function, numerous values points will not help. Instead of providing points, providing a function would be a better choice to represent the ODE. In the Drasil framework, users have an option to generate a runnable program or a library. The runnable program will contain main function, so users can run this artifact in the local machine. If it is a library, other outside program can utilize the generated library. Outputting the ODE as a function inclined equal to generate a library.

Not all libraries have options to represent the ODE as a function. Among four libraries, Scipy Library and OSLO Library have similar option to support out put a function. In Scipy library, we can return a generic interface called \verb|scipy.integrate.ode|~\citep{scipyfun}. It is a generic interface can store information preserve the ODE, and later if we want to solve the ODE, we can add other ODE related configuration information afterward. In OSLO library, the function \verb|Ode.RK547M| return an enumerable sequence of solution points, it is a endless sequence of solution points. Later on, we can call \verb|SolveFromToStep| to return a list of points base on start time, end time, and time interval. What \verb|Ode.RK547M| return can be treat as a function of ODE.

\begin{listing}[ht]
\begin{python1}
def func_y_t(K_d, K_p, r_t, t_sim, t_step):
    def f(t, y_t):
        return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
    
    r = scipy.integrate.ode(f)
    r.set_integrator("dopri5", atol=Constants.Constants.AbsTol, rtol=Constants.Constants.RelTol)
    r.set_initial_value([0.0, 0.0], 0.0)
    y_t = [[0.0, 0.0][0]]
    while r.successful() and r.t < t_sim:
        r.integrate(r.t + t_step)
        y_t.append(r.y[0])
    
    return y_t
\end{python1}
\label{code_pythonscipy}
\captionof{listing}{Source code of solving PDController in Scipy}
\end{listing}

In line 1, \verb|func_y_t| is a function output the numerical solution, and it is a list of numbers. In the line 2, the local function \verb|f| contains ODE. The line 3 shows local function return a list. Since we want to solve a system of ODE, the index one is the first ODE in this system, and the index two is the second ODE this system. By calling \verb|scipy.integrate.ode|, we pack ODE information in the generic interface. The line between 5 and 10, are procedure how to set configuration and collecting results. Theoretically, we can just return the \verb|r| in line 4 to present returning a function of ODE.

\begin{listing}[ht]
\begin{csharp1}
public static List<double> func_y_t(double K_d, double K_p, double r_t, double t_sim, double t_step) {
    List<double> y_t;
    Func<double, Vector, Vector> f = (t, y_t_vec) => {
        return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
    };
    Options opts = new Options();
    opts.AbsoluteTolerance = Constants.AbsTol;
    opts.RelativeTolerance = Constants.RelTol;
    
    Vector initv = new Vector(new double[] {0.0, 0.0});
    IEnumerable<SolPoint> sol = Ode.RK547M(0.0, initv, f, opts);
    IEnumerable<SolPoint> points = sol.SolveFromToStep(0.0, t_sim, t_step);
    y_t = new List<double> {};
    foreach (SolPoint sp in points) {
        y_t.Add(sp.X[0]);
    }
    
    return y_t;
}
\end{csharp1}
\captionof{listing}{Source code of solving PDController in OSLO}
\label{code_csharposlo}
\end{listing}

\section{Management Libraries}
Once the Drasil framework generate code, the program relay on external libraries to complete calculating ODEs. In the current setting, the Drasil framework keep copies of external libraries in the repository. It is not practical because the amount of space external libraries occupied. Moreover, external libraries do not share across study cases, and each study case will have its copy of external libraries. This research surfaces the current way handles dependencies in Drasil framework is problematic, and the team would like to find a better way to handle dependency. We use a temporary solution, symbolic links, to share external libraries without duplications. By creating a symbolic link file, external libraries become sharable. The team will conduct further study to tackle this problem.
