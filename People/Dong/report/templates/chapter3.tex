\chapter{External libraries}
The external library comes from an outside source and does not originate from the source project. Most libraries are language-dependent, and the Drasil framework can generate five different languages, including Python, Java, C++, C\#, and Swift. Among those five languages, four programming languages have ODE libraries for solving ODEs. In Python, Scipy Library~\citep{scipy} is a well-known scientific library for solving scientific problems and has support for solving ODEs. In Java, a library is called Apache Commons Maths(ACM)~\citep{apache}.It is a supplementary library for solving mathematical and statistical problems, which build-in Java programming language is unavailable. It has support to solve ODEs as well. Two less known libraries can solve an ODE in ODEINT Library~\citep{odeint} C++ and OSLO Library~\citep{oslo} C\#. Last, we did not find a suitable library for Swift. For those four selected libraries, they have some commonalities and variabilities. Firstly, they all provide a numerical solution for a linear system of first-order ODEs. Each library can output a value of the dependent value at a specific time. We can collect those values in a time range. Secondly, they all provide different algorithms for solving ODEs numerically, and we will conduct a rough commonalities analysis of available algorithms. A completed commonality analysis would be too time-consuming and out of the scope of my study. Last, Scipy and OSLO Library have the potential to output a numerical solution as a function. This discovery will benefit the Drasil framework to generate a library rather than a standalone executable  program. Besides commonalities and variabilities, the Drasil team has to learn how to manage external libraries in the Drasil framework.

This chapter will discuss topics related to the commonalities and variabilities of four libraries, including numerical solutions, algorithms options and outputting a function. Last, we will discuss how we handle dependencies.

\section{Numerical Solutions}
Numerical solutions use algorithms to make approximations for mathematical equations. All numerical solutions are approximations, and some numerical solutions that utilize better algorithms can produce a better result than others. All selected libraries provide numerical solution for a linear system of first-order ODE as an initial value problem (IVP). The initial value requires an initial condition that specifies the function's value at the start point, contrasting with boundary value problem (BVP). In this research, we will solve each scientific problem as an IVP. Let's see how to solve a linear system of first-order ODE with an example. Here is an example of a linear system of first-order ODE.
\begin{flalign} \label{ex_firstorderode}
& x_{1}(t)' = x_{2}(t) \\ \nonumber
& x_{2}(t)' = -(1 + K_{d})x_{2}(t) - (20 + K_{p})x_{1}(t) + r_{t} K_{p} 
\end{flalign}

In example~\ref{ex_firstorderode}, there are two dependent variables, $x_1$ and $x_2$. The $x_1(t)$ is the function of the independent variable, time, which produces dependent variables $x_1$ over time. The $x_2(t)$ is the function of the independent variable, time, which produces dependent variables $x_2$ over time. The $x_1$ is the process variable, and the $x_2$ is the first derivative with respect to the time of the process variable $x_1$. The $x_1'$(t) is the first directive of the function $x_1(t)$, and the $x_2'$(t) is the first derivative of the function $x_2$(t). The $K_d$ , $K_p$, and $r_t$ are constant variables, and they remain the same meaning in example~\ref{eq_odeexmaple} and example~\ref{ex_firstorderode}. We can encode the example~\ref{ex_firstorderode} in all four libraries.

In Python, we can write the example as the following code:
\begin{python1}
def f(t, y_t):
    return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
\end{python1}
In this example, the y\_t is a list of dependent variables. The index 0 of y\_t is the dependent variable $x_1$, and the index 1 of y\_t is the dependent variable $x_2$. The y\_t[1] represent the first equation $x_{1}(t)' = x_{2}(t)$ in the example~\ref{ex_firstorderode}. The -(1.0 + K\_d) * y\_t[1] + -(20.0 + K\_p) * y\_t[0] + r\_t * K\_p represents the second equation, $x_{2}(t)' = -(1 + K_{d})x_{2}(t) - (20 + K_{p})x_{1}(t) + r_{t} K_{p}$, in the example~\ref{ex_firstorderode}. In Java, we can write the example as the following code:
\begin{java1}
public void computeDeriv(double t, double[] y_t, double[] dy_t) {
    dy_t[0] = y_t[1];
    dy_t[1] = -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p;
}
\end{java1}

In C++, we can write the example as the following code:
\begin{cplusplus1}
void ODE::operator()(vector<double> y_t, vector<double> &dy_t, double t) {
    dy_t.at(0) = y_t.at(1);
    dy_t.at(1) = -(1.0 + K_d) * y_t.at(1) + -(20.0 + K_p) * y_t.at(0) + r_t * K_p;
}	
\end{cplusplus1}

In C\#, we can write the example as the following code:
\begin{csharp1}
Func<double, Vector, Vector> f = (t, y_t_vec) => {
    return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
};
\end{csharp1}

Once we capture the information of the system of ODE, we have to give an initial condition for solving an ODE as an IVP. To solve the example~\ref{ex_firstorderode}, we must provide the initial value for both $x_1$ and $x_2$. Overall, an ODE is a simulation, and it simulates a function of time. Before we start the simulation, other configurations need to specify, including the start time, end time of the simulation, time step between each iteration. We can also provide values for each library's absolute and relative tolerance. Those two tolerances control the accuracy of the solution. As we mentioned before, all numerical solutions are approximations. High tolerance produces less accurate solutions, and smaller tolerances produce more accurate solutions. Last, we have to collect the numerical value for each iteration. The full detail on how each library solves the example~\ref{ex_firstorderode} will show up in Appendix~\ref{numsol}.

\section{Algorithm Options}
In reality, we can solve an ODE in many algorithms, and those four libraries provide many algorithms. We roughly classified available algorithms into four categories based on the type of algorithm they use. They are a family of Adams methods, a family of backward differentiation formula methods (BDF), a family of Runge-Kutta (RK) methods, and other methods. The commonality analysis on available algorithms is just an approximation and incomplete. Getting a completed commonality analysis will require some help from domain experts in the ODE area. It will be far out of my study, so we only provide a rough classification in this study. Although the commonality is incomplete, the team still benefits from the current analysis. Not only can a future student quickly access information on which algorithm is available in each language, but also the analysis remains us that we can increase the consistency of artifacts by providing one-to-one mapping for each algorithm in four libraries. For example, if a user explicitly chooses a family of Adams methods as the targeted algorithm, all available libraries should use a family of Adams methods to solve the ODE. Unfortunately, not all libraries provide a family of Adams methods. Here table~\ref{tab_algoexlib} shows the availability of a family of an algorithm in each library. The full detail of each library's available algorithm will show in Appendix~\ref{alg_externallib}.

\begin{sidewaystable}
\begin{adjustbox}{width=\columnwidth,center}
\begin{tabular}{p{0.18\textwidth} | p{0.22\textwidth} p{0.22\textwidth} p{0.29\textwidth} p{0.25\textwidth}}\hline
    \backslashbox{Algorithm}{Library}
    &\textbf{Scipy-Python}&\textbf{ACM-Java}&\textbf{ODEINT-C++}&\textbf{OSLO-C\#}\\
    \toprule
    Family of Adams & 
        \begin{itemize}[wide]
        \item Implicit Adams
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Adams Bashforth
        \item Adams Moulton
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Adams Bashforth Moulton
        \end{itemize} &\\ \hline
    Family of BDF & 
        \begin{itemize}[wide]
        \item BDF
        \end{itemize} &&& 
        \begin{itemize}[wide]
        \item Gearâ€™s BDF
        \end{itemize} \\ \hline
    Family of RK & 
        \begin{itemize}[wide]
        \item Dormand Prince (4)5 
        \item Dormand Prince 8(5,3) 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Explicit Euler
        \item 2ed order
        \item 4th order
        \item Gill fourth order
        \item 3/8 fourth order
        \item Luther sixth order
        \item Higham and Hall 5(4)
        \item Dormand Prince 5(4) 
        \item Dormand Prince 8(5,3) 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Explicit Euler
        \item Implicit Euler
        \item Symplectic Euler
        \item 4th order
        \item Dormand Prince 5
        \item Fehlberg 78
        \item Controlled Error Stepper
        \item Dense Output Stepper
        \item Rosenbrock 4
        \item Symplectic RKN McLachlan 6
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Dormand Prince RK547M
        \end{itemize} \\ \hline
    Others && 
        \begin{itemize}[wide]
        \item Gragg Bulirsch Stoer 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Gragg Bulirsch Stoer 
        \end{itemize} &\\
    \bottomrule	
\end{tabular}
\end{adjustbox}
\caption{Algorithms support in external libraries}	
\label{tab_algoexlib}
\end{sidewaystable}

Last, there are some improvements the Drasil team can make the ODE solution better. For example, we found some algorithms use a fixed step size for calculating numerical solutions, and others instead of using adaptive step size. We add the step size with the current time value to calculate the next value of dependent variables. A fixed step size means the step size is the same in each iteration. An adaptive step size means the step size is not always the same and could change base on other factors. In table~\ref{tab_algacm}, the ACM library divides algorithms into one that uses a fixed step and the other that uses an adaptive step. This discovery can further influence the design choice of solving ODE numerically in the Drasil framework. Currently, Drasil treats all step sizes as a fixed value, and it would be ideal to allow the step size to be either fixed or adaptive in future.

\section{Function vs Points}
The ODE provides a mathematical expression for describing a function of time. The numerical solution can instantiate an ODE, but it only provides a partial solution for the ODE. If we are interested in the continuous change of the function, the numerical solution will not help. Instead of providing points, providing a function of time would be a better choice to represent the ODE. In the Drasil framework, users have an option to generate a runnable program or a library. The runnable program will contain the main function so users can run generated code directly without integration. If the generated code is a library, other outside programs can utilize the generated library. Thus, outputting the ODE as a function is inclined equally to generate a library. Not all libraries have options to represent the ODE as a function of time. Among four libraries, Scipy Library and OSLO Library have similar options to support outputting a function. In the Scipy library, we can return a generic interface called \verb|scipy.integrate.ode|~\citep{scipyfun} which is a generic interface that can store ODE's information. Later if we want to solve the ODE, we can add other ODE-related configuration information afterward. The following is the full detail of how to solve the example~\ref{ex_firstorderode} in the Scipy library.

\begin{listing}[ht]
\begin{python1}
def func_y_t(K_d, K_p, r_t, t_sim, t_step):
    def f(t, y_t):
        return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
    
    r = scipy.integrate.ode(f)
    r.set_integrator("dopri5", atol=Constants.Constants.AbsTol, rtol=Constants.Constants.RelTol)
    r.set_initial_value([0.0, 0.0], 0.0)
    y_t = [[0.0, 0.0][0]]
    while r.successful() and r.t < t_sim:
        r.integrate(r.t + t_step)
        y_t.append(r.y[0])
    
    return y_t
\end{python1}
\label{code_pythonscipy}
\captionof{listing}{Source code of solving PDController in Scipy}
\end{listing}

Between line 2 and line 3, we encode the ODE equation of the example~\ref{ex_firstorderode} in a list. In line 5, we call \verb|scipy.integrate.ode| to pack ODE information in the generic interface. In line 6, we set the configuration setting for algorithm choices and how much absolute tolerance and relative tolerance. In line 7, we set initial values and the start time. In line 8, we initialize the result collection. We put initial values in a list, then specify which initial value we want to put in the result collection. In line 9, the while loop represents the whole iteration to calculate the ODE.  Line 10 adds the time step in each iteration. In this example, we are only interested in collecting the process variable $x_1$, so we only collect the process variable in line 11. Last, we return the collection of results in line 13.

With the workflow described above, the \verb|scipy.integrate.ode(f)| capture all the information of the ODE. We can output the class \verb|scipy.integrate.ode| as a function of time in a generated library. If there is an outside source that wants to use this function, they can write a proper interface to connect the function with their programs. 

In the OSLO library, the function \verb|Ode.RK547M| returns an enumerable sequence of solution points, and it is an endless sequence of solution points. Later, we can call \verb|SolveFromToStep| to return a list of points based on start time, end time, and time interval. We can treat the return of \verb|Ode.RK547M| as a function of time. The code~\ref{code_csharposlo} shows the full detail of how to solve the example~\ref{ex_firstorderode} in the OSLO library.

\begin{listing}[ht]
\begin{csharp1}
public static List<double> func_y_t(double K_d, double K_p, double r_t, double t_sim, double t_step) {
    List<double> y_t;
    Func<double, Vector, Vector> f = (t, y_t_vec) => {
        return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
    };
    Options opts = new Options();
    opts.AbsoluteTolerance = Constants.AbsTol;
    opts.RelativeTolerance = Constants.RelTol;
    
    Vector initv = new Vector(new double[] {0.0, 0.0});
    IEnumerable<SolPoint> sol = Ode.RK547M(0.0, initv, f, opts);
    IEnumerable<SolPoint> points = sol.SolveFromToStep(0.0, t_sim, t_step);
    y_t = new List<double> {};
    foreach (SolPoint sp in points) {
        y_t.Add(sp.X[0]);
    }
    
    return y_t;
}
\end{csharp1}
\captionof{listing}{Source code of solving PDController in OSLO}
\label{code_csharposlo}
\end{listing}

Between line 3 and line 4, we encode the ODE equation of the example~\ref{ex_firstorderode} in a \verb|Vector|. Between line 7 and line 8, we set the absolute and relative tolerance in the \verb|Options| class. In line 10, we initialize initial values. Next, in line 11, we use \verb|Ode.RK547M| to get an endless sequence of points. In line 12, we use \verb|SolveFromToStep| to get a partial solution base on the start time, the final time, and the time step. Last, between line 13 and line 15, it runs a for loop to collect the process variable $x_1$ at index 0.

With the workflow we described above, the \verb|Ode.RK547M(0.0, initv, f, opts)| captures the information of the ODE, and the return object represents a total solution of the ODE. Anyone who is interested in a partial solution can use \verb|SolveFromToStep| to filter out to a partial solution. Therefore,
we can output the result of \verb|Ode.RK547M| as a function of time in a generated library. If there is an outside source that wants to use this function, they can write a proper interface to connect the function with their programs. 

\section{Management Libraries}
Once the Drasil framework generates code, the generated code relies on external libraries to complete calculating ODEs. In the current setting, the Drasil framework keeps copies of external libraries in the repository. It is not practical because of the amount of space external libraries occupy. Moreover, external libraries do not share across study cases, and each study case will have its copy of external libraries. This research uncovers the current way of handling dependencies in the Drasil framework is problematic, and the team would like to find a better way to handle dependency. We use a temporary solution, symbolic links, to share external libraries without duplications. By creating a symbolic link file, external libraries become sharable. The team will conduct further studies to tackle this problem.
