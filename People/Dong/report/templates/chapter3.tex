\chapter{External libraries}
The external library comes from an outside source, and it is not originate from the source project. Most libraries are language dependent, and the Drasil framework can generate five different languages, includes Python, Java, C++, C\#, and Swift. Among those five languages, four programming languages have ODE libraries to solving ODEs. In Python, Scipy Library~\citep{scipy} is a well-known scientific libraries for solving scientific problems, and it has support to solve ODEs. In Java, there is a library called Apache Commons Maths(ACM)~\citep{apache}, and it is a supplementary library for solving mathematical and statistical problems which build-in Java programming language does not available. It has support to solve ODEs as well. There are two less known libraries that can solve an ODE in C++ and C\#, and they are ODEINT Library~\citep{odeint} and OSLO Library~\citep{oslo} respectively. Last, we did not find a suitable library for Swift. For those four selected libraries, they have some commonalities and variabilities. Firstly, they all provide a numerical solution for a linear system of first-order ODEs. Each library can output a value of the dependent value at a certain time. We can collect those values in a time range. Secondly, they all provide different algorithms for solving ODEs numerically, we will conduct a rough commonalities analysis on available algorithm. A completed commonality analysis would be too time-consuming, and it is out the scope of my study. Last, Scipy and OSLO Library have potential to output a numerical solution as a function. This discovery will benefit the Drasil framework to generate a library rather than a executable standalone program. Beside commonalities and variabilities, the Drasil team have to learn how to manage external libraries in the Drasil framework.

In this Chapter, we will discuss some topics related to commonalities and variabilities of four libraries, includes numerical solutions, algorithms options and outputting a function. Last, we will discussed how we handle dependencies.

\section{Numerical Solutions}
Numerical solutions use algorithms to make approximation for mathematical equations. All numerical solution are approximation, and some numerical solutions utilize better algorithm can produce a better result than others. All selected libraries provides numerical solution for a linear system of first-order ODE as an initial value problem (IVP). The initial value requires an initial condition which specify the value of the function at the start point, and it is contrasting to boundary value problem (BVP). In this research, we are going to solve each scientific problem as an IVP. Let see how to solve a linear system of first-order ODE with an example. Here is an example of a linear system of first-order ODE.
\begin{flalign} \label{ex_firstorderode}
& x_{1}(t)' = x_{2}(t) \\ \nonumber
& x_{2}(t)' = -(1 + K_{d})x_{2}(t) - (20 + K_{p})x_{1}(t) + r_{t} K_{p} 
\end{flalign}

In example~\ref{ex_firstorderode} , there are two dependent variables $x_1$ and $x_2$. The $x_1(t)$ is the function of the independent variable, time, which produces dependent variables $x_1$ over time. The $x_2(t)$ is also the function of the independent variable, time, which produces dependent variables $x_2$ over time. The $x_1$ is the process variable, and the $x_2$ is the first derivative with respect to time of the process variable $x_1$. The $x_1'$(t) is the first directive of the function $x_1(t)$, and the $x_2'$(t) is the first derivative of the function $x_2$(t). The $K_d$ , $K_p$, and $r_t$ are constant variables, and they remain the same meaning in the example~\ref{eq_odeexmaple} and the example~\ref{ex_firstorderode}. We can encode the example~\ref{ex_firstorderode} in all four libraries.

In the Python, we can write the example as following code:
\begin{python1}
def f(t, y_t):
    return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
\end{python1}
In this example, the y\_t is a list of dependent variable. The index 0 of y\_t is the dependent variable $x_1$, and the index 1 of y\_t is the dependent variable $x_2$. The y\_t[1] represent the first equation $x_{1}(t)' = x_{2}(t)$ in the example~\ref{ex_firstorderode}. The -(1.0 + K\_d) * y\_t[1] + -(20.0 + K\_p) * y\_t[0] + r\_t * K\_p represents the second equation, $-(1 + K_{d})x_{2}(t) - (20 + K_{p})x_{1}(t) + r_{t} K_{p}$, in the example~\ref{ex_firstorderode}. In the Java, we can write the example as following code:
\begin{java1}
public void computeDeriv(double t, double[] y_t, double[] dy_t) {
    dy_t[0] = y_t[1];
    dy_t[1] = -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p;
}
\end{java1}

In the C++, we can write the example as following code:
\begin{cplusplus1}
void ODE::operator()(vector<double> y_t, vector<double> &dy_t, double t) {
    dy_t.at(0) = y_t.at(1);
    dy_t.at(1) = -(1.0 + K_d) * y_t.at(1) + -(20.0 + K_p) * y_t.at(0) + r_t * K_p;
}	
\end{cplusplus1}

In the C\#, we can write the example as following code:
\begin{csharp1}
Func<double, Vector, Vector> f = (t, y_t_vec) => {
    return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
};
\end{csharp1}

Once we capture the information of the system of ODE, we have to given initial condition for solving an ODE as an IVP. To solve the example~\ref{ex_firstorderode}, we have to give the initial value for both $x_1$ and $x_2$. Overall, an ODE is a simulation, and it simulates a function of time. Before we start the simulation, there are other configurations need to specify, include start time of the simulation, end time of the simulation, time step between each iteration. We can also given values for the absolute tolerance and relative tolerance to each libraries. Those two tolerances control the accuracy of the solution. As we mentioned before, all numerical solutions are approximation. High tolerance produce less accurate solutions, and smaller tolerances produce more accurate solutions. Last, we have to collect the numerical value for each iteration. The full detail on how each libraries solve the example~\ref{ex_firstorderode} will show up in Appendix~\ref{numsol}.

\section{Algorithm Options}
In reality, we can solve an ODE in many algorithms, and those four libraries provide many algorithms. We roughly classified available algorithms into four categories base on the type of algorithm they use. They are a family of Adams methods, a family of backward differentiation formula methods (BDF), a family of Runge-Kutta (RK) methods, and other methods. The commonality analysis on available algorithms is just an approximation, and it is not completed. To get a completed commonality analysis will require some help from domain experts in ODE area. It will far out of my study, so we only provide a rough classification in this study. Although the commonality is not completed, the team still benefit from the current analysis. Not only a future student can quickly access information of which algorithm is available in relative language, but also it remains us that we can increase the consistency of artifacts by providing one to one mapping for each algorithm in four libraries. For example, if a user explicitly choose a family of Adams methods as the targeted algorithm, all available libraries should use a family of Adams methods to solve the ODE. Unfortunately, not all libraries provide a family of Adams methods. Here in the table~\ref{tab_algoexlib}, it shows the availability of approximation of a family of algorithm in each library. The full detail of available algorithm for each library will show up in Appendix~\ref{alg_externallib}.

\begin{sidewaystable}
\begin{adjustbox}{width=\columnwidth,center}
\begin{tabular}{p{0.18\textwidth} | p{0.22\textwidth} p{0.22\textwidth} p{0.29\textwidth} p{0.25\textwidth}}\hline
    \backslashbox{Algorithm}{Library}
    &\textbf{Scipy-Python}&\textbf{ACM-Java}&\textbf{ODEINT-C++}&\textbf{OSLO-C\#}\\
    \toprule
    Family of Adams & 
        \begin{itemize}[wide]
        \item Implicit Adams
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Adams Bashforth
        \item Adams Moulton
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Adams Bashforth Moulton
        \end{itemize} &\\ \hline
    Family of BDF & 
        \begin{itemize}[wide]
        \item BDF
        \end{itemize} &&& 
        \begin{itemize}[wide]
        \item Gearâ€™s BDF
        \end{itemize} \\ \hline
    Family of RK & 
        \begin{itemize}[wide]
        \item Dormand Prince (4)5 
        \item Dormand Prince 8(5,3) 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Explicit Euler
        \item 2ed order
        \item 4th order
        \item Gill fourth order
        \item 3/8 fourth order
        \item Luther sixth order
        \item Higham and Hall 5(4)
        \item Dormand Prince 5(4) 
        \item Dormand Prince 8(5,3) 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Explicit Euler
        \item Implicit Euler
        \item Symplectic Euler
        \item 4th order
        \item Dormand Prince 5
        \item Fehlberg 78
        \item Controlled Error Stepper
        \item Dense Output Stepper
        \item Rosenbrock 4
        \item Symplectic RKN McLachlan 6
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Dormand Prince RK547M
        \end{itemize} \\ \hline
    Others && 
        \begin{itemize}[wide]
        \item Gragg Bulirsch Stoer 
        \end{itemize} & 
        \begin{itemize}[wide]
        \item Gragg Bulirsch Stoer 
        \end{itemize} &\\
    \bottomrule	
\end{tabular}
\end{adjustbox}
\caption{Algorithms support in external libraries}	
\label{tab_algoexlib}
\end{sidewaystable}

Last, there are some improvements the Drasil team can make the solution of ODE better. For example, we found some algorithms use a fixed step size for calculating numerical solution, and others instead of using adaptive step size. We add the step size with current time value to calculate the next value of dependent variables. A fixed step size mean the step size is the same in each iteration. A adaptive step size means the step size is not always the same, and it could change base on other factors. In table~\ref{tab_algacm}, the ACM library divides algorithms into one that use fixed step and the other that use adaptive step. This discovery can further influence the design choice of solving ODE numerically in the Drasil framework. Currently, Drasil treat all step sizes as a fixed value, and it would be ideal to allow the step size be either fixed or adaptive in future.

\section{Function vs Points}
The ODE provide mathematical expression for describing a function of time. The numerical solution can instantiate an ODE, but it only provides a partial solution for the ODE. If we are interested in the continuous change of the function, the numerical solution would not help. Instead of providing points, providing a function of time would be a better choice to represent the ODE. In the Drasil framework, users have an option to generate a runnable program or a library. The runnable program will contain main function, so users can run generated code directly without any integration. If the generated code is a library, other outside programs can utilize the generated library. Thus, outputting the ODE as a function inclined equal to generate a library. Not all libraries have options to represent the ODE as a function of time. Among four libraries, Scipy Library and OSLO Library have similar option to support outputting a function. In Scipy library, we can return a generic interface called \verb|scipy.integrate.ode|~\citep{scipyfun}. It is a generic interface can store information which preserve the ODE, and later if we want to solve the ODE, we can add other ODE related configuration information afterward. The following is the full detail of how to solve the example~\ref{ex_firstorderode} in the Scipy library.

\begin{listing}[ht]
\begin{python1}
def func_y_t(K_d, K_p, r_t, t_sim, t_step):
    def f(t, y_t):
        return [y_t[1], -(1.0 + K_d) * y_t[1] + -(20.0 + K_p) * y_t[0] + r_t * K_p]
    
    r = scipy.integrate.ode(f)
    r.set_integrator("dopri5", atol=Constants.Constants.AbsTol, rtol=Constants.Constants.RelTol)
    r.set_initial_value([0.0, 0.0], 0.0)
    y_t = [[0.0, 0.0][0]]
    while r.successful() and r.t < t_sim:
        r.integrate(r.t + t_step)
        y_t.append(r.y[0])
    
    return y_t
\end{python1}
\label{code_pythonscipy}
\captionof{listing}{Source code of solving PDController in Scipy}
\end{listing}

Between the line 2 and line 3, we encode the ODE equation of the example~\ref{ex_firstorderode} in a list. In line 5, we call \verb|scipy.integrate.ode| to pack ODE information in the generic interface. In the line 6, we set configuration setting for what algorithms we use, how much are absolute tolerance and relative tolerance. In the line 7, we set initial values and the start time. In the line 8, we initialize the result collection. We put initial values in a list, then specify which initial value we want to put in the result collection. In the line 9, the while loop represent the whole iteration to calculate the ODE. The line 10 add the time step in each iteration. In this example, we only interested in collecting the process variable $x_1$, so we only collect the process variable in line 11. Last, we return the collection of result in line 13.

With the workflow we described above, the \verb|scipy.integrate.ode(f)| capture all the information of the ODE. We can output the class \verb|scipy.integrate.ode| as a function of time in a generated library. If there is an outside source want to use this function, they can write a proper interface to connect the function with their programs. 

In OSLO library, the function \verb|Ode.RK547M| return an enumerable sequence of solution points, it is a endless sequence of solution points. Later on, we can call \verb|SolveFromToStep| to return a list of points base on start time, end time, and time interval. What \verb|Ode.RK547M| return can be treat as a function of time. The code~\ref{code_csharposlo} shows the full detail of how to solve the example 3.1.1 in the OSLO library.

\begin{listing}[ht]
\begin{csharp1}
public static List<double> func_y_t(double K_d, double K_p, double r_t, double t_sim, double t_step) {
    List<double> y_t;
    Func<double, Vector, Vector> f = (t, y_t_vec) => {
        return new Vector(y_t_vec[1], -(1.0 + K_d) * y_t_vec[1] + -(20.0 + K_p) * y_t_vec[0] + r_t * K_p);
    };
    Options opts = new Options();
    opts.AbsoluteTolerance = Constants.AbsTol;
    opts.RelativeTolerance = Constants.RelTol;
    
    Vector initv = new Vector(new double[] {0.0, 0.0});
    IEnumerable<SolPoint> sol = Ode.RK547M(0.0, initv, f, opts);
    IEnumerable<SolPoint> points = sol.SolveFromToStep(0.0, t_sim, t_step);
    y_t = new List<double> {};
    foreach (SolPoint sp in points) {
        y_t.Add(sp.X[0]);
    }
    
    return y_t;
}
\end{csharp1}
\captionof{listing}{Source code of solving PDController in OSLO}
\label{code_csharposlo}
\end{listing}

Between the line 3 and line 4, we encode the ODE equation of the example~\ref{ex_firstorderode} in a \verb|Vector|. In the line 7 and line 8, we set the absolute tolerance and relative tolerance in the \verb|Options| class. In line 10, we initialize initial values. Next, in line 11, we use \verb|Ode.RK547M| to get an endless sequence of points. In line 12, we use \verb|SolveFromToStep| to get partial solution base on the start time, the final time, and time step. Last between line 13 and line 15, it run a for loop to collect the process variable $x_1$ at index 0.

With the workflow we described above, the \verb|Ode.RK547M(0.0, initv, f, opts)| capture the information of the ODE, and the return object represent a full solution of the ODE. If anyone who is interested in a partial solution, they can use \verb|SolveFromToStep| to filter out to a partial solution. Therefore,
we can output the result of \verb|Ode.RK547M| as a function of time in a generated library. If there is an outside source want to use this function, they can write a proper interface to connect the function with their programs. 

\section{Management Libraries}
Once the Drasil framework generate code, the program relay on external libraries to complete calculating ODEs. In the current setting, the Drasil framework keep copies of external libraries in the repository. It is not practical because the amount of space external libraries occupied. Moreover, external libraries do not share across study cases, and each study case will have its copy of external libraries. This research surfaces the current way handling dependencies in Drasil framework is problematic, and the team would like to find a better way to handle dependency. We use a temporary solution, symbolic links, to share external libraries without duplications. By creating a symbolic link file, external libraries become sharable. The team will conduct further study to tackle this problem.
