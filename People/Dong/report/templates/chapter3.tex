\chapter{External libraries}
The external library comes from an outside source, and it is not originate from the source project. Thus, we will generate interfaces to interact with selected libraries. Most libraries are language dependent, and the Drasil framework can generate five different languages, includes Python, Java, C++, C\#, and Swift. Among those five languages, four programming languages have ODE libraries to solving ODEs. In Python, Scipy Library~\citep{scipy} is a well-known scientific libraries to solving scientific problems, and it has support to solve ODEs. In Java, there is a library called Apache Commons Maths(ACM)~\citep{apache}, and it is a supplementary library to solve mathematical and statistical problems which build-in Java programming language does not available. It has support to solve ODEs as well. There are two less known libraries work as ODE solver in C++ and C\#, and they are ODEINT Library~\citep{odeint} and OSLO Library~\citep{oslo} respectively. However, we did not find a suitable library for Swift. 

All four selected libraries have some commonalities. Firstly, they provide numerical solution for a system of first-order ODEs. Secondly, they has similar interface for solving ODEs numerically. Last, they has options for selecting different algorithms to solve an ODE. Beside commonalities, they has variability as well. Some libraries provide options to output ODE's solution as a function or a generic class that similar to a function. Outside of external libraries, it is could be a challenge to manage different external libraries inside the Drasil framework. In this Chapter, we will first discuss the commonalities and variabilities of four libraries. Next, we will discuss how the Drasil team manage those libraries.

\section{Numerical Solutions}
The backend mechanism of how each library to get a numerical solution is following by the following ideology. In a ODE, the independent variable is usually time. One way to get get a numerical solution is to get the point value in a certain time point. Therefore, we treat the ODE as an initial value problem. For example, we can assume the start time is zero, and the time interval is a fixed time range. At the time zero, the initial value is given by users. In the next time point, previous time plus a fixed time range, libraries will calculate the numerical solution in this time point. At a certain time point, the next time point would excess the total simulation time of this ODE, then the program will stop. To get a numerical solution in a certain time range, we still need to collect the numerical value in each iteration. 

All four external libraries have is that they provide numerical solutions for a system of first-order ODEs. The following is mathematical expression for a system of first-order ODEs. 

\begin{equation} \label{eq_foode}
    X' = AX + c
\end{equation}

X is the unknown vector that consist of dependent variables. X' is the vector that consist of first derivative of dependent variables. The A is a coefficient matrix, and c is a constant vector. 

% In each implementation, we can treat the dependent values as a list. The first index of the this array indicates the first dependent variable, and the second index of this array indicates the second dependent variable, and so on. Each dependent variable will have its initial value. For example, if there are two dependent variables, there will be two initial values.

\section{Algorithm Options}
In reality, we can solve an ODE in many algorithms, such as Adams method. Those four external libraries also provide many algorithms to solve an ODE, and we classified them into five categories, a family of Adams methods, a family of BDF methods, a family of Runge-Kutta methods, a family of Euler method, and Bulirsch-Stoer method, in the Table~\ref{tab_algoexlib}. Moreover, the detail of available algorithm for each library will show up in appendixA.

\begin{table}
    \begin{tabular}{|l||*{5}{c|}}\hline
        \backslashbox{Algorithm}{Library}
        &\makebox[6em]{Scipy-Python}&\makebox[6em]{ACM-Java}&\makebox[6em]{ODEINT-C++}&\makebox[6em]{OSLO-C\#}\\\hline\hline
        Family of Adams & \checkmark & \checkmark & \checkmark &\\\hline
        Family of BDF & \checkmark &&& \checkmark \\\hline
        Family of Runge-Kutta & \checkmark & \checkmark & \checkmark & \checkmark \\\hline
        Gragg-Bulirsch-Stoer && \checkmark & \checkmark &\\\hline
        Family of Euler && \checkmark & \checkmark &\\\hline
    \end{tabular}
	\caption{Algorithm supports for external libraries}	
	\label{tab_algoexlib}
\end{table}

During investigation of algorithms, we found some algorithms use a fixed step size for calculating numerical solution, and others instead of using adaptive size (reference). This discovery can further influence the design choice of solving ODE numerically in the Drasil framework. Currently, Drasil treat all step sizes as a fixed value, and it would be ideal to allow the step size be either fixed or adaptive.

\section{Function vs Points}
The ODE provide mathematical expression for describing a function over time. The numerical solution can instantiate an ODE, but it only provides a partial solution for the ODE. If we are interested in the continuous change of the function, numerous values points will not help. Instead of providing points, providing a function would be a better choice to represent the ODE. In the Drasil framework, users have an option to generate a runnable program or a library. The runnable program will contain main function, so users can run this artifact in the local machine. If it is a library, other outside program can utilize the generated library. Outputting the ODE as a function inclined equal to generate a library.

Not all libraries have options to represent the ODE as a function. Among four libraries, Scipy Library and OSLO Library have similar option to support out put a function. In Scipy library, we can return a generic interface called \verb|scipy.integrate.ode|~\citep{scipyfun}. It is a generic interface can store information preserve the ODE, and later if we want to solve the ODE, we can add other ODE related configuration information afterward. In OSLO library, the function \verb|Ode.RK547M| return an enumerable sequence of solution points, it is a endless sequence of solution points. Later on, we can call \verb|SolveFromToStep| to return a list of points base on start time, end time, and time interval. What \verb|Ode.RK547M| return can be treat as a function of ODE.

\section{Management Libraries}
Once the Drasil framework generate code, the program relay on external libraries to complete calculating ODEs. In the current setting, the Drasil framework keep copies of external libraries in the repository. It is not practical because the amount of space external libraries occupied. Moreover, external libraries do not share across study cases, and each study case will have its copy of external libraries. This research surfaces the current way handles dependencies in Drasil framework is problematic, and the team would like to find a better way to handle dependency. We use a temporary solution, symbolic links, to share external libraries without duplications. By creating a symbolic link file, external libraries become sharable. The team will conduct further study to tackle this problem.
