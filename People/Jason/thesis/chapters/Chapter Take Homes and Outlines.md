# Chapter "Take Homes" and Outlines

1. Introduction:

    Take home: 

    Outline:
	
2. Ideology:

    Take home: Software artifacts are the result of the communication of product
    owners. The quality of their communication will be a direct reflection of
    the quality of the created software artifacts.

    Outline:

3. Drasil:

    Take home: We can generalize and generate families of software artifacts by
    capturing and formalizing knowledge, using domain-specific languages to make
    them feel "natural."
    
    Alternative take home: Formalizing knowledge (captured in the form of a
    series of domain-specific languages) and their relationships allows us to
    form families of software artifacts, from which a user can create specific
    artifacts by making choices.

    Outline:

4. Framing Theories:

    Take home: Since humans can infer knowledge from small "views" of a larger
    picture, transferring equational knowledge using equations is possible
    amongst those familiar with the specific "views". For example, transferring
    `y = m * x + b` is easy for us to recognize as the equation of a line, but
    changing the variables or the form (e.g., using point-slope form, intercept
    form, etc.) will make it more difficult. To formalize the translation of
    specific kinds of theories into various forms (e.g., different forms,
    teaching material, solving software, etc.), the implicit information, which
    we would infer from theories, needs to become explicit. Through making the
    implicit information, explicit, we are able to formalize more relationships
    between theories and other things (such as views and uses of them).

    Outline:

5. Typing Expressions:

    Take home: Expression formation has specific rules we follow, or else the
    expression we write are invalid/incomprehensible (and these validity rules
    also apply to the programming language artifacts we generate). To ease the
    cognitive stress of writing valid/comprehensible expressions, we can create
    validation checks and make them static. In doing this, we will know which
    expressions are valid or not, before attempting to use them for code
    generation.

    Outline:

6. Knowledge Management:

    Take home: In working with many domains of knowledge, we naturally work with
    many types of knowledge (chunks). As we continue to teach Drasil about each
    domain, the globe of types expands. However, the existing method of storing
    these chunks only allows for a limited number of types to be recorded
    (ChunkDB). To remedy this, we may ignore the type of stored chunks and rely
    on typed references that can interpret the chunks as originally needed.

    Outline:

7. Future Work:

    Outline:

8. Conclusion:

    Outline:

I imagine the "take home" of the "Conclusion" chapter would be a re-statement of
the introductions, and I couldn't quite think of a prime "take home" yet for the
"Future Work".
