% ModelKinds -- Theory types / discrimination -- ``Expressions in context''

In order for Drasil to generate software artifacts that solve problems, it must
have a way of discussing the space your problem lies in, and the ways it can be
transformed into the working calculation steps that a software artifact can
follow to solve your problem.

\originalExprHaskell

The original smart constructors were specific to Expr:

\originalFewExprSmartConstructorsHaskell

Theories were transcribed using ``RelationConcepts'':

\originalRelationConcept

Where ``Relations'' are merely an alias for Expr:

\originalRelation{}

\theoriesWithoutModelKinds

We split up Expr into 3 kinds of expression languages that better fit our needs.

\section{Problem}

\begin{itemize}

	\item In modelling any problem, one will, of course, model the work of their
		  pencil and paper. Thankfully, with scientific problems, the
		  well-understood ones will be codified\cite{well-understood}, and as
		  such, are a good fit for Drasil, as it is intended to automatically
		  generate software that performs calculations for a specific problem in
		  the universe of generic programs supported.

	\item In most, if not all, physics problems, a common language of mathematic
	      calculation. In Drasil, this language is written as an \acf{adt}: 
		  
		  \currentExprHaskell

	\item Here, we explain that a mathematical expression is defined by the
	      above \acf{ast}. The language contains the commonly found operations
	      in a well-understood physics textbook (here, with a focus on
	      graduate-level scientific problems).

	\item It's important that each knowledge encoding in Drasil exposes as much
	      information as reasonably possible (and useful). \todo{This is still
	      very vague} We want to expose the ``specifications'' of each piece of
	      knowledge that we are encoding so that transformers and generators may
	      appropriately make use of contained knowledge.

	\item With mathematical models, it's very easy to write ``difficult to
	      interpret'' expressions, and create expressions for which aren't
	      directly calculable (i.e., things that require an extra paper and
	      pencil/mental mathematics before performing), either without extra
	      surrounding information or simply too ``difficult'' (areas where we
	      might find choices are especially difficult).

	\item Since we want to generate code that represents calculations of all
	      sorts, it's important that the mathematical expression language we use
	      to write calculations expose sufficient information to the generator
	      in a concise and easy-to-digest manner.

	\item For example, assuming the following expressions are written using the
	      existing mathematical Expr language in Drasil...
	      \begin{itemize}

		      \item While \(y = x\) might conventionally be seen as ``y is equal
		            to x'', we might want, in our model, for it to be understood
		            as ``x is defined by y'' but displayed differently.

		      \item \(a = b = c = ... = d\) can be ambiguously read ...

		      \item Truth statements such as \(y < x\) might be usable in
		            asserting constraints at software runtime, but it's
		            difficult to find a place for it to belong without extra
		            context.

		      \item \intodo{List problems}

	      \end{itemize}

\end{itemize}

\section{Requirements \& properties of a good solution}

\begin{itemize}

	\item Expressions are great for viewing, but not for a computer to
	      systematically use to generate things.

	\item Theories should expose more information about themselves so that we
	      can directly interpret them without needing to traverse over an
	      expression.

	\item Specifically, more expressions should be usable in code generation,
	      amongst other things.

\end{itemize}

\section{Solution}

\begin{itemize}

	\item Mathematical expressions may have definitive meanings at different
	      levels of interpretation. Splitting our focal expression language into
	      3 variants is easy thanks to GADTs and TTF \cite{carette2009finally};
	      CodeExpr, ModelExpr, and Expr. This will allow us to restrict terms to
	      the different levels of interpretation through a common type (either
	      using the GADT, or the TTF constraints).

	\item Replacing ``RelationConcepts'':

	      \begin{itemize}

		      \item Using raw expressions to transcribe whole mathematical
		            theories and data structures leads to many problems and
		            difficulties in interpretation alone.

		      \item Replacing raw expressions with ``encodings one step higher''
		            that can push out the same raw expressions as a property of
		            the higher-level encodings will allow us to quickly
		            identify, discriminate, and efficiently use the information
		            originally contained in the expressions better. This is done
		            through replacing ``RelationConcepts'' with ``ModelKinds'':

			  \item \currentModelKindsHaskell
			  
			  \item \intodo{Discuss EquationalModels, EquationalRealms,
			  	    EquationalConstraints, DEModel, NewDEModel, etc.}

	      \end{itemize}

\end{itemize}

\subsection{Continued}

\intodo{Remaining problems}
