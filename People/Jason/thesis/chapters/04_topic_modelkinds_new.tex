\chapter{Classifying Theories}
\label{chap:framing-theories}

\begin{writingdirectives}
    \item What are they?
    \item What are theories used for?
    \item How are they captured in Drasil?
    \item Current problems? Solutions?
\end{writingdirectives}

In this chapter, we will focus on improving inspection and interpretation
capabilities of theories in Drasil. Specifically, with focus on interpreting
them for generating software artifacts.

\section{Theories}
\label{chap:framing-theories:sec:theories}

As mentioned in \Cref{chap:drasil}, the \acs{srs} template
\cite{SmithAndLai2005} breaks up software requirements and problems into a
series of well-understood components, providing developers with concrete
solution requirements they must satisfy, and domain experts with justification
for problem solutions. Notably, the \acs{srs} relates a programs \textit{inputs}
to a set of \textit{outputs} using a set of \textit{theories}. The inputs and
outputs are sets of variables, with data that need to be somehow fed into the
program, or calculated and output by the program. The theories connect the input
variables to the output by forming a \textit{solution/calculation path}. There
are at least 3 kinds of theories\footnote{There's also a 4th kind: Data
Definitions, intended for explaining how input variables should be interpreted
by the solution program, thus also explaining how they should be formatted; they
are typically intended to be implementation-focused, rather than theoretical.}:
Theory Models, General Definitions, and Instance Models. Theory Models and
General Definitions provide justification for the mathematics of the solution:
the Instance Models. The Instance Models, specifically, together form the
calculation path.

For example, Drasils \porthref{\acs{projectile} case
study}{https://jacquescarette.github.io/Drasil/examples/projectile/SRS/srs/Projectile_SRS.html}
describes how to estimate if a launcher, aligned at a particular angle, will hit
a target from a specific distance. The \acs{srs} requires users to fill in the:
\begin{enumerate}
    \item input variables:
          \begin{enumerate}
              \item \(p_\mathit{target}\), the targets distance from the
                    launcher,
              \item \(v_\mathit{launch}\), the projectile launch speed,
              \item and \(\theta\), the launch angle.
          \end{enumerate}
    \item output variables:
          \begin{enumerate}
              \item \(s\), a message, explaining if the projectile hit the
                    target, fell short, or went long,
              \item and \(d_\mathit{offset}\), the expected distance between the
                    target position and the landing position.
          \end{enumerate}
    \item and theories, connecting the inputs to the outputs:
          \begin{enumerate}
              \item \({t_{\text{flight}}}=\frac{2 {v_{\text{launch}}}
                        \sin\left(\theta{}\right)}{\mathbf{g}}\), estimating
                    flight time with \(v_{\mathit{launch}}\) and \(\theta\),
              \item \({p_{\text{land}}}=\frac{2 {v_{\text{launch}}}^{2}
                        \sin\left(\theta{}\right)
                        \cos\left(\theta{}\right)}{\mathbf{g}}\), a calculation
                    of the landing position,
              \item \({d_{\text{offset}}}={p_{\text{land}}}-{p_{\text{target}}}\),
                    calculation of distance between the targets position and the
                    expected landing position of the projectile,
              \item and \(s=\begin{cases} \text{``The target was hit.''}, &
              |\frac{{d_{\text{offset}}}}{{p_{\text{target}}}}| < \varepsilon{}
              \\
              \text{``The projectile fell short.''}, & {d_{\text{offset}}} < 0 \\
              \text{``The projectile went long.''},  & {d_{\text{offset}}} >
              0\end{cases}\), \newline{}calculating the output message.
          \end{enumerate}
\end{enumerate}

From these 3 key bodies of information along with some supporting background
knowledge (such as assumptions, constants, etc.), Drasil forms a calculation
path, deriving the output variables from the input variables using the instance
models\footnote{And, less importantly, data definitions.}. Here, Drasil
approximately recognizes that to calculate the outputs, it approximately needs
to follow a path along the lines of the order of presented theories. With it,
Drasil is able to generate representational code. For example, \acsp{projectile}
generates \refOriginalJavaProjectileMain{} for one of the Java-flavoured
artifacts. In \refOriginalJavaProjectileMain{}, it uses a
\inlineCode{java}{write_output} method to output the calculated output variables
after calculating them using the relevant theories\footnote{Note:
\(t_\text{flight}\) is seemingly unused in the generated code, but it is used in
the derivation of \(p_\text{land}\). However, it being ``unused'' is irrelevant
to this work.}.

\originalJavaProjectileMain{}

In order to build the quantities, one does it similar to
\refOriginalQuantityDictExampleHaskell{}. Similarly, in order to build the
theories, Drasil also has a \acs{dsl}, \RelationConcept{}s
(\refOriginalRelationConcept{}); they are used in Drasils representation of
Instance Models, and allow users to couple a mathematical relation (encoded
using \Relation{}s), a natural language description of the relation, and a name.

\originalRelationConcept{}

Notably, the \Relation{}s are any mathematical relation. To make use of them,
Drasil tries to analyze them (\refOriginalRelToQDHaskell{}) to understand their
capabilities, and, where designated, attempt to generate code fragments through
\acs{gool}. Unfortunately, this analysis is brittle, relying on Drasils users
encoding their theory knowledge in precise forms.

\originalRelToQDHaskell{}

As we can see in \refOriginalRelToQDHaskell{}, the current analysis only covers
relations of the form \(x = f(a, b, c, \ldots{})\). Here arises 2 notable
issues:
\begin{enumerate}
    \item[\namedlabel{mk:issue:1}{Issue 1}] it only handles one theory scenario:
    variable definitions,
    \item[\namedlabel{mk:issue:2}{Issue 2}] and, for those definitions, it
    requires a specific form.
\end{enumerate}

As a result of \ref{mk:issue:1}, we aren't able to encode adequately all the
theories we're interested in using, and want to generate representational code
of. In particular, as Drasil is heavily guided by physics-focused case studies,
\acsp{ode} are desired! When we want to use \acsp{ode} in the solution of a
problem, extra information is required. For example, we might need to give
Drasil (and/or developers) information about a desired approximation formula
with particular ``settings.'' Drasil does circumvent this issue for \acsp{ode},
but we would like to reconcile the half-measures and push all necessary
information back in to the theory encodings.

Assuming we wanted to describe the theory of a line, there are many ways we can
describe the equation: polynomial (\(a \cdot{} x + b \cdot{} y + c = 0\)),
slope-intercept form (\(y = m \cdot{} x + b\)), point-slope form (\(y_1 - y_2 =
m(x_1 - x_2)\)), and so on. However, as a result of \ref{mk:issue:2}, we are
forced to use ``simple'' slope-intercept form, even though we are aware of other
forms and may prefer to describe it in other forms.

\imptodo{Continue writing here!}

\section{Classifying by Structure}
\label{chap:framing-theories:sec:classifying-and-structuring}


\imptodo{Now, recall, the theories are supposed to expose sufficient information
    such that a developer can use them to immediately write code. Similarly, it
    should also expose enough information such that we can describe how it
    translates to code.}
