\chapter{Future Work}
\label{chap:futureWork}

\intodo{Rewrite point form notes in Future Work chapter.}

\begin{itemize}

      \item Addressing Chapter 6\ldots{}

      \item Still many problems!
            \intodo{Move nearly everything below to the Future Work chapter.}
            \begin{itemize}

                  \item How do we explain ``Data.Typeable''?

                  \item And ``HasUID''?

                  \item And ``HasChunkRefs''?

                  \item And ``Dumpable''?

            \end{itemize}

      \item Well, at the very least, now we're able to merge the ``chunk'' maps
            and fix many of the pre-existing problems (we're almost there!).
            However, now we're relying too much on Haskell. How do we explain
            those parts?

      \item Also, what are \UID{}s really? Do their information carry any real
            information? \textit{Rigid designators}.

\end{itemize}

\section{Future Work}

\subsection{Encodings}

\begin{itemize}

      \item With the above new definition of ``chunks'', they still remain a
            very vague idea, and still \textit{deeply embedded} (a place to
            recognize an encoding might be appropriate!) in Haskell.

      \item What are the kinds of chunks that can exist? What can be in a chunk,
            and what are we missing from the existing list of chunks?

      \item The problem with that is that we lose a lot of information by
            writing Haskell, and leaving the knowledge in the form of Haskell.

      \item We need to de-embed all chunks so that we can obtain a tangible
            understanding of them.

      \item Through de-embedding the chunks, we will also be forced to de-embed
            everything with it. This is including the ways in which we transform
            and generate ``new''-ish knowledge (not necessarily new types/kinds
            of knowledge, but new instances of types).

\end{itemize}


\begin{enumerate}

      \item What is a ``chunk''?
            \begin{itemize}

                  \item A ``chunk instance'' is a single \textit{term} of a
                        language.
                        
                  \item A ``chunk type'' is a language itself.
                  
            \end{itemize}

      \item What is a ``transformer''?
            \begin{itemize}

                  \item A ``transformer'' is a conversion of a term written in a
                        language into another term, potentially in another
                        language.
                        
                  \item Transformers rely on a well-understood dissection of
                        knowledge (contained in a chunk type/language) in order
                        transform it (potentially with other terms/information
                        as well) into another term.
                        
            \end{itemize}

\end{enumerate}


\begin{itemize}

      \item This document will contain knowledge regarding the Expression language
            that is shown in Haskell code, but not quite in our encodings. To
            further improve Drasil, one of the next ``obvious'' steps is to
            transcribe the knowledge involved with writing any language down as
            well. An excruciating amount of knowledge is everywhere.

      \item The unit and dimension related to numbers is another project on its
            own. It will need to be added to calculate the units of operations and
            ensure that representations are appropriate for their (precision vs
            accuracy as Dr. Smith mentioned).

\end{itemize}
