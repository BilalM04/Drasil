\chapter{Drasil}
\label{chap:drasil}

\begin{writingdirectives}

      \item What is Drasil?
      \begin{enumerate}
            \item What does it do?
            \item Where can we find information about it?
            \item What are its successes?
      \end{enumerate}

      \item How does Drasil work?
      \begin{enumerate}
            \item SRS? Generation?
            \item Specifically, what are its current problems?
      \end{enumerate}

\end{writingdirectives}

\drasilLogoImg{}

\section{What is it? What can it do?}
\label{chap:drasil:sec:what-is-it-what-can-it-do}

Principally investigated by \porthref{Dr. Jacques
      Carette}{https://www.cas.mcmaster.ca/~carette/} and \porthref{Dr. Spencer
      Smith}{https://www.cas.mcmaster.ca/~smiths/},
\porthref{Drasil}{https://jacquescarette.github.io/Drasil/} is a software suite
for generating software for well-understood problems through a knowledge-first
approach \cite{Drasil2021}. Drasil captures the background knowledge involved
with software development to make it \textit{reusable}, improve
\textit{maintainability} of software, and strengthen \textit{traceability}
between desired ``software artifacts''\footnote{``Software artifacts'' being any
      file with a well-defined structure, such as plaintext files, Python code,
      \LaTeX{} code, \acs{html}, or \acs{json}.} and the background knowledge
\cite{SzymczakEtAl2016}. Currently, Drasil focuses on generating software
artifacts for \ACF{scs}, where it has been shown to improve software qualities,
such as \textit{verifiability}, \textit{reliability}, and \textit{usability}
\cite{Smith2018}.

\roughNetworkOfDomains{}

Drasils knowledge-capture approach to software development allows users to
remove themselves from the discussion of ``code'' and focus on the important
bits: the problem the code solves and how ``code'' ultimately relates to
it\footnote{Drasil allows users to ``keep at a safe distance'' from software,
      but only so far as Drasil has encoded the terminology the users rely on for
      conveying their problem to Drasil.}. Drasil relies on a \textit{network of
      domains} \cite{Czarnecki2005} to capture the knowledge required to generate
artifacts for a series of case studies (\refCaseStudiesTable{}) that Drasil
builds and uses to navigate development. Roughly, the network is as per
\refRoughNetworkOfDomains{}, where nodes are the major categories of
domains\footnote{In other words, each node contains its own subdomain as well}
and arrows are mappings between them. The case studies use structured \ACF{srs}
\cite{SmithAndLai2005} abstraction to describe scientific problems and the
background knowledge necessary for developers to manually build software.
Through sufficient capture of the background scientific knowledge\footnote{Such
      as the key theories, input and output variables, and assumptions.}, Drasil
generates software artifacts that solve the precise problem descriptions
(\refCaseStudiesCodeTable{}). One notable success of the knowledge capture is
the reusability of it to regenerate artifacts in different, but similarly
applicable, languages. For example, the \acs{glassbr} case study had
\porthref{software
      artifacts}{https://github.com/smiths/caseStudies/tree/master/CaseStudies/glass}
manually built. Once the knowledge was codified in Drasil, the same knowledge
allows re-creation in \porthref{other
      languages}{https://github.com/JacquesCarette/Drasil/tree/master/code/stable/glassbr}.

\caseStudiesTable{}

Drasil is able to generate a host of \ACF{oo} programming language source codes
through compiling to \ACF{gool} \cite{MacLachlan2020}, which compiles to several
\acs{oo} languages (such as Java, Python, C/C$++$, C\#, and Swift\footnote{Note
      that Swift was not discussed in \cite{MacLachlan2020}, but the renderer was
      built by Brooks as well.}). Drasil also contains renderers for printing
\acs{html} files, Makefiles, basic Markdown (enough for ``READMEs''), GraphViz
DOT \cite{Gansner1993} diagrams, and plaintext, \LaTeX{} documents. \acs{srs}
abstractions are renderable in either \LaTeX{} or \acs{html}.

\section{How does it work? How is it used?}
\label{chap:drasil:sec:how-does-it-work-how-is-it-used}

As mentioned in \Cref{chap:drasil:sec:what-is-it-what-can-it-do}, Drasil relies
on building a tree of knowledge that contains sufficient information such that
software artifacts can be ``grown'' from them. The individual pieces of
knowledge are known as \textit{chunks} and are encoded as either \ACFP{adt} or
\ACFP{gadt}. Drasil, and all knowledge captured in Drasil, is deeply embedded in
Haskell \cite{Haskell2010} \porthref{source
code}{https://github.com/JacquesCarette/Drasil/}\footnote{The source code
compiles against \acs{ghc} 8.8.4 \cite{GHC884} and uses \acs{ghc} language
extensions.}. Each chunk has a \textit{type} which defines its structural
information. Chunks contain information encoded with various \ACFP{dsl}. The
network of domains (roughly, \refRoughNetworkOfDomains{}) is made up of a series
of chunks connecting and discussing one another, similar to how we might discuss
abstract concepts.

The ``coherent \acs{srs} abstraction'' of \refRoughNetworkOfDomains{} is
modelled after the \textit{Smith et al.} formal \acs{srs} template
\cite{SmithAndLai2005}, while the ``scientific knowledge'' higher up is a set of
interconnected chunks (and, hence, \acsp{dsl}). The ``scientific knowledge''
chunks are used to fill in the ``gaps'' of the \acs{srs} template. For example,
if we wanted to encode a variable, \(\hat{q}_{\text{tol}}\), representing a real
number, ``Tolerable load,'' we might write it as:

\originalQuantityDictExampleHaskell{}

\imptodo{Continue writing here!}

\begin{enumerate}

      \item Drasil provides users with a formal \ACF{srs} template\footnote{The
                  \textit{Smith et al.} \cite{SmithAndLai2005} template, in
                  particular.} for describing their software. The template
            breaks up common scientific problems into a series of
            theories, justification, variables, assumptions, and more to
            ultimately make up a coherent ``story'' describing a problem.

            \begin{enumerate}

                  \item The template contains ``holes'' for user entry. The
                        entries each use a \acs{dsl} to input information.

                  \item Filled in \acs{srs} document are, within reason,
                        automatically checked for consistency and coherence.

            \end{enumerate}

      \item Drasil is built in Haskell \cite{Haskell2010}, and case studies are
            embedded directly in the Haskell code as well, allowing us to use
            Haskells rich tooling for creating \ACFP{dsl}.
            \begin{enumerate}

                  \item A series of \acsp{dsl} are used to represent encoded
                        knowledge and their relationships to other pieces of
                        knowledge, and input data into Drasil.

                  \item The capture of domain-specific knowledge is what sets
                        \acsp{dsl} apart from general-purpose programming
                        languages.

                  \item Domain-specific abstractions create opportunities for
                        domain-specific \textit{interpretation and
                              transformation} (e.g., optimization, analysis, error
                        checking, tool support, etc.) \cite{Czarnecki2005}.

                  \item Drasil relies on a \textit{network of domains} (a
                        network of domain knowledge connected by \aclp{dsl}) to
                        enable the complex information transformation needed to
                        convert an \acs{srs} document into code.

            \end{enumerate}

      \item In Drasil, \textit{chunks} are the fragments of
            knowledge\footnote{At times, we will also refer to chunks as
                  ``knowledge fragments,'' or, similarly, ``fragments of knowledge.''}
            that carry semantically meaningful information`'.
            \begin{enumerate}
                  \item Haskell records and \ACFP{adt} are used to encode
                        chunks, and functions and instantiated typeclasses are
                        used to describe relationships chunks share with each
                        other.

                  \item Each chunk has a \textit{type} denoting the category of
                        knowledge it belongs to, and containing structural and
                        capability information about instances of it.

                  \item By connecting and intertwining chunks into large
                        cohesive stories, we're able to form a network of domain
                        models \cite{Czarnecki2005}.

                  \item Roughly, the above diagram shows how Drasils
                        \textit{Smith et al.} knowledge transformer works, with
                        each node representing a domain of knowledge, and each
                        arrow representing a mapping between them.

                  \item Realistically, each node in the diagram represent an
                        encompassing domain of \acsp{dsl}, they all contain
                        their own network of domain knowledge\footnote{In other
                              words, each node is merely the ``domain'' of a series of
                              \acsp{dsl}. Thus, the diagram is not an accurate
                              depiction of all \acsp{dsl} that actually exist in
                              Drasil.}.
            \end{enumerate}

      \item Through compiling the abstracted calculation sequences to \ACF{gool}
            \cite{Carette2019}, Drasil is able to generate a host of \acs{oo}
            programming language source codes.

      \item Generating software artifacts requires understanding what things you
            \textit{can say} in desired artifacts, what things you \textit{want
                  and need to say}, and how you can transform the latter into the
            former.

      \item Some case studies aren't capable of generating representational
            code\footnote{``Representational code'' meaning software that solves
                  the problem the related \acs{srs} abstraction describes.} because
            they aren't fully filled out yet, but, we won't focus on those here.

      \item Here, we will focus on a critical common denominator between them:
            capturing mathematical knowledge for reliable \acs{srs} artifact
            generation.

\end{enumerate}

\caseStudiesCodeTable{}

Some case studies (\acs{gamephysics}, \acs{hghc}, and \acs{ssp}) are still
actively being developed, but are left incomplete at the time of writing.

The \acs{glassbr}, \acs{projectile}, \acs{pdcontroller}, and \acs{nopcm} case
studies each are capable of generating representational software.

\acs{nopcm} is usable in all languages supported by \acs{gool} except for Swift
due to the lack of a Drasil-supported \acs{ode} solving library for the Swift
\acs{gool} renderer.

\acs{pdcontroller} was built outside the normal means of Drasils case studies
development, being built by Naveen Ganesh Muralidharan \cite{DrasilPR2289Naveen}
for a class he took at McMaster University. Code generation for
\acs{pdcontroller} is not impossible, it just requires more investigation for
the needs of the case study. However, both the issues related to \acs{nopcm} and
\acs{pdcontroller} are outside the scope of this work.
