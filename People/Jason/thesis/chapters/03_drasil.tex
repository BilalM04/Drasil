\chapter{Drasil}
\label{chap:drasil}

\begin{writingdirectives}

      \item What is Drasil?
      \begin{enumerate}
            \item What does it do?
            \item Where can we find information about it?
            \item What are its successes?
      \end{enumerate}

      \item How does Drasil work?
      \begin{enumerate}
            \item SRS? Generation?
            \item Specifically, what are its current problems?
      \end{enumerate}

\end{writingdirectives}

\begin{enumerate}

      \item Drasil is deeply embedded in Haskell \cite{Haskell2010}, relying on
            Stack \cite{HaskellStack}, and compiling against \acs{ghc} 8.8.4
            \cite{GHC884}.

      \item \porthref{Dr. Jacques
                  Carette}{https://www.cas.mcmaster.ca/~carette/} and
            \porthref{Dr. Spencer
                  Smith}{https://www.cas.mcmaster.ca/~smiths/} are the principal
            investigators of Drasil.

\end{enumerate}

\drasilLogoImg{}

\section{What is it? What can it do?}
\label{chap:drasil:sec:what-is-it}

\begin{enumerate}

      \item \porthref{Drasil}{https://jacquescarette.github.io/Drasil/} is a
            software suite for generating software for well-understood problems.

      \item In particular, Drasil focuses on generating software artifacts for
            \ACF{scs} described using a precise \ACF{srs}.

      \item Drasil is able to generate a host of \ACF{oo} programming language
            source codes.

      \item Drasil is currently capable of generating usable software through
            compiling to \ACF{gool}, which can produce Java, C++, Python, C\#
            \cite{MacLachlan2020}, and Swift\footnote{not discussed in
                  MacLachlan's Master's thesis, but created by him as well, and
                  available similarly}.

      \item Drasil also contains renderers for HTML, Makefile, basic Markdown
            (enough for README), GraphViz DOT (graph description language)
            \cite{Gansner1993}, plaintext documents, \LaTeX{}, and \TeX{}.

      \item Users of Drasil are quite far-removed from the inner workings and
            ``lower-level''\footnote{While we often think of abstractions as
                  being ``higher'' and ``lower'' level than others, we should be
                  careful to only discuss them with respect to a particular aspect, as
                  not all things may be sensibly related with this dichotomy.}
            abstractions of resultant software artifacts.

      \item Drasil allows scientists to ``keep at a safe distance'' from
            software, but only so far as Drasil has encoded the terminology the
            scientist relies on for conveying their problem to Drasil.

      \item Drasil has already been shown to increase productivity of building
            and maintaining reliable and traceable software artifacts
            \cite{SzymczakEtAl2016}, and, in particular, for \acs{scs}
            \cite{Smith2018}.

            \begin{enumerate}
                  \item In particular, as a result of capturing the semantic
                        meaning of scientific problems (through the \acs{srs}
                        ``story'' guiding), we're also able to generate the same
                        \acs{scs} using other programming languages and tools.
            \end{enumerate}

      \item For example, the \ACF{glassbr} case study had \porthref{software
                  artifacts}{https://github.com/smiths/caseStudies/tree/master/CaseStudies/glass}
            manually written, but, thanks to Drasil capturing semantic meaning,
            Drasil is capable of
            \porthref{re-generating}{https://github.com/JacquesCarette/Drasil/tree/master/code/stable/glassbr}
            the same software solution with extra options, including modularity,
            logging, programming language, and more.

      \item In order to make this (re-)generation and options-variability
            possible, Drasil needed an encoding of the semantic meaning of the
            manually-built artifacts. Thankfully, generating original \acs{srs}
            documents in more typesetting flavours (\LaTeX{}/\TeX{} and
            \acs{html}) is relatively uncomplicated.

      \item As such, each case study is capable of generating an \acs{srs}
            document in at least 2 flavours.

\end{enumerate}

\caseStudiesTable{}












\section{How does it work?}
\label{chap:drasil:sec:how-does-it-work}

\begin{enumerate}

      \item Drasil provides users with a formal \ACF{srs} template\footnote{The
                  \textit{Smith et al.} \cite{SmithAndLai2005} template, in
                  particular.} for describing their software. The template
            breaks up common scientific problems into a series of
            theories, justification, variables, assumptions, and more to
            ultimately make up a coherent ``story'' describing a problem.

            \begin{enumerate}

                  \item The template contains ``holes'' for user entry. The
                        entries each use a \acs{dsl} to input information.

                  \item Filled in \acs{srs} document are, within reason,
                        automatically checked for consistency and coherence.

            \end{enumerate}

      \item Drasil is built in Haskell \cite{Haskell2010}, and case studies are
            embedded directly in the Haskell code as well, allowing us to use
            Haskells rich tooling for creating \ACFP{dsl}.
            \begin{enumerate}

                  \item A series of \acsp{dsl} are used to represent encoded
                        knowledge and their relationships to other pieces of
                        knowledge, and input data into Drasil.

                  \item The capture of domain-specific knowledge is what sets
                        \acsp{dsl} apart from general-purpose programming
                        languages.

                  \item Domain-specific abstractions create opportunities for
                        domain-specific \textit{interpretation and
                              transformation} (e.g., optimization, analysis, error
                        checking, tool support, etc.) \cite{Czarnecki2005}.

                  \item Drasil relies on a \textit{network of domains} (a
                        network of domain knowledge connected by \aclp{dsl}) to
                        enable the complex information transformation needed to
                        convert an \acs{srs} document into code.

            \end{enumerate}

      \item In Drasil, \textit{chunks} are the fragments of
            knowledge\footnote{At times, we will also refer to chunks as
                  ``knowledge fragments,'' or, similarly, ``fragments of knowledge.''}
            that carry semantically meaningful information`'.
            \begin{enumerate}
                  \item Haskell records and \ACFP{adt} are used to encode
                        chunks, and functions and instantiated typeclasses are
                        used to describe relationships chunks share with each
                        other.

                  \item Each chunk has a \textit{type} denoting the category of
                        knowledge it belongs to, and containing structural and
                        capability information about instances of it.

                  \item By connecting and intertwining chunks into large
                        cohesive stories, we're able to form a network of domain
                        models \cite{Czarnecki2005}.

                  \item \roughNetworkOfDomains{}

                  \item Roughly, the above diagram shows how Drasils
                        \textit{Smith et al.} knowledge transformer works, with
                        each node representing a domain of knowledge, and each
                        arrow representing a mapping between them.

                  \item Realistically, each node in the diagram represent an
                        encompassing domain of \acsp{dsl}, they all contain
                        their own network of domain knowledge\footnote{In other
                              words, each node is merely the ``domain'' of a series of
                              \acsp{dsl}. Thus, the diagram is not an accurate
                              depiction of all \acsp{dsl} that actually exist in
                              Drasil.}.
            \end{enumerate}

      \item Through compiling the abstracted calculation sequences to \ACF{gool}
            \cite{Carette2019}, Drasil is able to generate a host of \acs{oo}
            programming language source codes.

      \item Generating software artifacts requires understanding what things you
            \textit{can say} in desired artifacts, what things you \textit{want
                  and need to say}, and how you can transform the latter into the
            former.

      \item Some case studies aren't capable of generating representational
            code\footnote{``Representational code'' meaning software that solves
                  the problem the related \acs{srs} abstraction describes.} because
            they aren't fully filled out yet, but, we won't focus on those here.

      \item Here, we will focus on a critical common denominator between them:
            capturing mathematical knowledge for reliable \acs{srs} artifact
            generation.

\end{enumerate}

\caseStudiesCodeTable{}

Some case studies (\acs{gamephysics}, \acs{hghc}, and \acs{ssp}) are still
actively being developed, but are left incomplete at the time of writing.

The \acs{glassbr}, \acs{projectile}, \acs{pdcontroller}, and \acs{nopcm} case
studies each are capable of generating representational software.

\acs{nopcm} is usable in all languages supported by \acs{gool} except for Swift
due to the lack of a Drasil-supported \acs{ode} solving library for the Swift
\acs{gool} renderer.

\acs{pdcontroller} was built outside the normal means of Drasils case studies
development, being built by Naveen Ganesh Muralidharan \cite{DrasilPR2289Naveen}
for a class he took at McMaster University. Code generation for
\acs{pdcontroller} is not impossible, it just requires more investigation for
the needs of the case study. However, both the issues related to \acs{nopcm} and
\acs{pdcontroller} are outside the scope of this work.
