\footnotetext[1]{\url{https://jacquescarette.github.io/Drasil/}}

\todo{Can I edit my own quote? Dr. Smith previously had some notes on this.}
\begin{mdleftbar}
      ``Drasil is a framework for generating families of software artifacts from
      a coherent knowledge base, following its mantra, ``Generate All The
      Things!''. Drasil uses a series of variably sized \ACFP{dsl} to describe
      various fragments of knowledge that domain experts and users alike may use
      to piece together fragments of knowledge into a coherent ``story''.
      Through forming some coherent ``story'' in a domain captured by Drasil, a
      representational software artifact may be generated. Drasil currently
      focuses on \ACF{scs}, following Smith and Lai's \ACF{srs} template as
      described in \cite{SmithAndLai2005}. Behind the scenes of the \acs{srs}, a
      mathematical language is used to describe various theories, and have
      representational software constructed via compiling to \ACF{gool}
      \cite{Carette2019}. Through encoding knowledge in Drasil, an increase in
      productivity (and maintainability) in building reliable and traceable
      software artifacts is observed \cite{SzymczakEtAl2016}, specifically in
      \acs{scs} \cite{Smith2018}. Drasil's source code (Haskell), case studies,
      and documentation studies can be found on its
      \porthreftm{website}{https://jacquescarette.github.io/Drasil/}.''
      \cite{Balaci2021Poster}
\end{mdleftbar}

\section{An Exploration}

Originally known as \ACF{lss} \todo{cite LSS}, Drasil is an exploration of this
ideology described in \Cref{chap:ideology}. Drasil's largest domain of knowledge
covered originates from \acs{lss}: \acl{scs}. \porthref{Dr. Jacques
      Carette}{https://www.cas.mcmaster.ca/~carette/} and \porthref{Dr. Spencer
      Smith}{https://www.cas.mcmaster.ca/~smiths/} are the principal investigators of
Drasil. Drasil is deeply embedded in Haskell \cite{Haskell2010}, relying on
Stack \todo{cite Stack}, and compiling against \acs{ghc} 8.8.4 \cite{GHC884}.
Haskell is the language of choice for various reasons, but the most important
reasons are regarding its paradigm: purely functional, with immutable data and a
strong, sound type system based on Church's type theory (a.k.a., simple type
theory) \todo{cite Church's type theory}.

Drasil is currently capable of generating usable software through compiling to
\ACF{gool}, which is capable of producing Java, C++, Python, C\#
\cite{MacLachlan2020}, and Swift (not discussed in MacLachlan's Master's thesis,
but created by him as well, and available similarly). Drasil contains renderers
for HTML, Makefile, basic Markdown (enough for README), GraphViz DOT (graph
description language) \cite{Gansner1993}, plaintext documents, \LaTeX{}, and
\TeX{}. Drasil's source code is publicly available on
\porthref{GitHub}{https://github.com/JacquesCarette/Drasil}, and Drasil's
documentation
(\porthref{user-facing}{https://jacquescarette.github.io/Drasil/docs/index.html},
and
\porthref{internal}{https://jacquescarette.github.io/Drasil/docs/full/index.html})
is available on the Drasil project
\porthref{homepage}{https://jacquescarette.github.io/Drasil/}. A public Drasil
wiki is hosted on the \porthref{same GitHub
      project}{https://github.com/JacquesCarette/Drasil/wiki}, containing information
on potential future Drasil projects, Drasil-related papers, a
\porthref{developer workspace configuration and ``quick start''
      guide}{https://github.com/JacquesCarette/Drasil/wiki/New-Workspace-Setup}, and a
guide for \porthref{building your own project with
      Drasil}{https://github.com/JacquesCarette/Drasil/wiki/Creating-Your-Project-in-Drasil}.

\section{Methodology}

Drasils development is typically guided by case studies, focusing on building
scientific software based on solving undergraduate-level physics problems. A
``control'' program and \acs{srs} are manually created and used as a baseline
target for the final artifact. Development is focused on creating a system of
justification for each component of the baseline program, following a
``bottom-up'' agile \todo{Double check if it is indeed an agile approach}
development approach. Drasil has been constructed following the demands and
requirements of eight (8) case studies:

\caseStudiesTable

\subsection{Knowledge Dissection and Capture via ``Bottom-Up'' Gathering}

Once baseline/target artifacts are constructed, the essence of the artifacts are
dissected and broken into various \textit{fragments} of knowledge. The fragments
of knowledge are continuously broken up and understood (via captured through
creating knowledge encodings) until a sufficient holistic understanding is
formed, generalized, and proven to be capable of re-generating the baseline
artifacts. Hopefully, at the end, the baseline artifacts will have their flaws
highlighted and resolved in the resolved in the produced artifacts.

\subsubsection{Example}

The most immediate fragments of relevant knowledge are those that discuss the
produced artifacts. Naturally, Drasil is limited to software-based side effects,
but focused on producing \textit{files} on a computer.

The case studies are focused on constructing scientific software that follow a
precise \acs{srs} \cite{SmithAndLai2005}. Therefore, all artifacts are produced
with the goal of providing a user with a (i) \acl{srs}, and (ii) a usable
software that adheres to the \acl{srs}.

The encodings of the desired artifact files are next most important. For
example, an \acs{srs} artifact is typically a file that an end-user will be
viewing (read-only). Thus, a PDF is appropriate, but also inappropriate due to
its complexity, and, hence, we look to constructing \acs{srs} documents using a
series of files built with a textual markup language, and designating that a
secondary compiler should be used to compile the files into a PDF. Naturally,
\LaTeX and \TeX are the immediately desired textual markup languages for their
usability in scientific scenes, portability, and free nature, unlike proprietary
languages. For a software artifact, there are likely a few relevant fragments,
but those most immediately important are the language (programming or otherwise)
of the software artifacts and the method to use the software artifact.
Generating a Java program will require for Drasil to have a working encoding of
Java programs, and a means of directing users on how to use a residual Java
program.

Once satisfactory encodings of file types are formed, we must look to the
purpose of the files and justify their existence. While a JSON file is strictly
for data serialization and deserialization, a Java file is either the ``entry''
to a program (via it's \texttt{main} method) or a file that might be some useful
to, and/or used in, a Java program. Therefore, we must create a system of
reasoning for why files belong where they do (this might be a part of the
language encoding itself as well). For executable software artifacts, the desire
is to have an end-user \textit{execute} the final software artifacts produced,
and thus we must gain information on what the user expects, desires, and, where
feasible, creating a conceptual understanding how a program meets their
expectations and desires. With each of Drasil's case studies, a series of
\textit{inputs} are provided to an executable program, and the program is
expected to produce \textit{outputs} that somehow make use of the inputs.
Drasils case studies form a system of relations for each study that relates the
inputs to the outputs.

As Drasil is focused on forming scientific software, the ``system of relations''
is generally a language of forming a sequence of mathematical calculations.
Knowledge is continuously captured until a sufficient fundamental knowledge-base
is formed such that a user may generate families of software problems using any
relevant domain knowledge.

This approach requires that there is sufficient implicit and explicit knowledge
around the \acs{srs} document such that a user/developer/machine may follow it,
without any external assistance (e.g., to clear up ambiguities).

\intodo{Use the below notes somehow, or get rid of them!}

\begin{itemize}

      \item Generating scientific software artifacts
            \begin{itemize}

                  \item Develop a stable framework for laying cookie-cutter
                        problems.

                  \item Make it as simple as using a projectional editor.

            \end{itemize}

      \item Typically, the pieces of knowledge that are ``closer'' to the final
            stages of the generation process have a ``lower informational
            density''.

\end{itemize}

\begin{figure}[H]
      \centering
      \caption{Drasils Logo}
      \label{fig:drasilLogo}
      \includegraphics[width=0.6\linewidth]{\drasilLogo}
\end{figure}

\drasilPersonification

\section{Architecture}

Drasil collects foundational knowledge about a \acs{srs} inside a
\textit{ChunkDB}, a funnel for \textit{Chunks}, our language/knowledge encodings
(also known as ``knowledge fragments'', and will be used interchangeably for the
purposes of this work). In Haskell, \Chunk{}s are any data that one may register
in the \ChunkDB{}:

\intodo{Code snippet: ChunkDB original definition.}

A \ChunkDB{} is currently limited to the above chunks, but one should assume
that more data types are also \textit{chunks} because this is merely a temporary
restriction at the moment. Relating back to the ideology (as discussed in
\autoref{chap:ideology}), in Drasil, the \ChunkDB{} is where the knowledge is
collected, placed, and grown (generated). \textit{Transformers} are used to
operate on the \Chunk{}s in the \ChunkDB{}. The transformers take in some
knowledge, optional \textit{refinement} information, and convert it into some
other knowledge fragment. Oddly\todo{Is it odd though? Or expected?}, these
transformations are seemingly ``against the grain'' of the ``bottom-up''
information gathering, whereby areas of precise and highly specific fragments of
knowledge have their key components used in generating something in another
language. The produced fragments are directed by the developer. By composing a
series of miniature, bite-sized, transformations, we are able to create large
and highly complex (but well-thought-out and understood).

The largest, most prominent transformer used in Drasil is that of the SmithEtAl
knowledge transformer. Currently represented using the entry point to Haskell
programs, the \inlineHs{main :: IO ()} function is representative of the
transformation capabilities of our understanding of our case studies into
sufficient \acs{srs} documents, and ready-to-use software.

\intodo{Code snippet: ``main'' function of GlassBR.}

\todo{Ref. ``main'' function code snippet above.} displays an example, from the
\acs{glassbr} case study, of what a transformer looks like in Drasil. This
transformer takes knowledge collected, configures a ``print job''/transformation
for the desired outputs as prescribed by an orchestrating developer, and
performs an \inlineHs{IO ()} effect that dumps an \acs{srs} and a software
artifact to the host computer, in the local working directory. \todo{continue
here}

\intodo{Code snippet: ``PrintingInformation'' \& ``SystemInformation''}

\intodo{Code snippet: ``genSRS''}

\intodo{Code snippet: ``genCode''}

\intodo{coloured diagram showing flow of information and how general information
      flow works}

\caseStudiesCodeTable

\begin{itemize}

      \item Uses a series of \ACFP{dsl} to build up the knowledge-base and
            ``story'' of a scene/project, until sufficient knowledge is built
            such that a generator may take the whole story and generate
            representational software artifacts.
            \intodo{I should add an example of the encoding of a theory.}

      \item Generates \acs{oo} programs; \acs{gool} is used to generate code in
            C++/C, Java, Python, Swift, and C\#.

      \item Doxygen, Markdown, HTML, TeX, Makefile, CSS, and more
            non-programming software artifacts.

      \item Creates a ``calculation path'' for a series of $x = f(a,b,c,...)$
            formed equations (e.g., simple LHS = complex RHS), and ODEs
            supported by python libraries.

      \item Multiple code generating examples (each with their own
            requirements):
            \begin{itemize}
                  \item GlassBR
                  \item NoPCM
                  \item PDController
                  \item Projectile
            \end{itemize}

      \item The calculation path relies (implicitly) on:
            \begin{itemize}

                  \item The Exprs of the RelationConcept being of the form: $x =
                              f(a,b,c,...)$

                  \item The ODEs being described by the expression language, but
                        we do not rely on being able to generate representing
                        computational code due to needing extra external
                        information (e.g., we require a supplementary packet of
                        information [ODEInfo]).

            \end{itemize}

\end{itemize}
