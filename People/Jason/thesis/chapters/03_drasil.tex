\footnotetext[1]{\url{https://jacquescarette.github.io/Drasil/}}

\todo{Can I edit my own quote? Dr. Smith previously had some notes on this.}
\begin{mdleftbar}
      ``Drasil is a framework for generating families of software artifacts from
      a coherent knowledge base, following its mantra, ``Generate All The
      Things!''. Drasil uses a series of variably sized \ACFP{dsl} to describe
      various fragments of knowledge that domain experts and users alike may use
      to piece together fragments of knowledge into a coherent ``story''.
      Through forming some coherent ``story'' in a domain captured by Drasil, a
      representational software artifact may be generated. Drasil currently
      focuses on \ACF{scs}, following Smith and Lai's \ACF{srs} template as
      described in \cite{SmithAndLai2005}. Behind the scenes of the \acs{srs}, a
      mathematical language is used to describe various theories, and have
      representational software constructed via compiling to \ACF{gool}
      \cite{Carette2019}. Through encoding knowledge in Drasil, an increase in
      productivity (and maintainability) in building reliable and traceable
      software artifacts is observed \cite{SzymczakEtAl2016}, specifically in
      \acs{scs} \cite{Smith2018}. Drasil's source code (Haskell), case studies,
      and documentation studies can be found on its
      \porthreftm{website}{https://jacquescarette.github.io/Drasil/}.''
      \cite{Balaci2021Poster}
\end{mdleftbar}

\section{An Exploration}

Originally known as \ACF{lss}\todo{Cite LSS}, Drasil is an exploration of this
ideology described in \Cref{chap:ideology}. Drasil's largest domain of knowledge
covered originates from \acs{lss}: \acl{scs}. \porthref{Dr. Jacques
      Carette}{https://www.cas.mcmaster.ca/~carette/} and \porthref{Dr. Spencer
      Smith}{https://www.cas.mcmaster.ca/~smiths/} are the principal investigators of
Drasil. Drasil is deeply embedded in Haskell \cite{Haskell2010}, relying on
Stack\todo{Cite Stack}, and compiling against \acs{ghc} 8.8.4 \cite{GHC884}.
Haskell is the language of choice for various reasons, but the most important
reasons are regarding its paradigm: purely functional, with immutable data and a
strong, sound type system based on Church's type theory (a.k.a., simple type
theory)\todo{Cite Church's type theory, and somewhere that notes that Haskell is
      indeed based on it}. This provides a sound system developers may use to
classify, create, and work with knowledge.

Drasil is currently capable of generating usable software through compiling to
\ACF{gool}, which is capable of producing Java, C++, Python, C\#
\cite{MacLachlan2020}, and Swift (not discussed in MacLachlan's Master's thesis,
but created by him as well, and available similarly). Drasil contains renderers
for HTML, Makefile, basic Markdown (enough for README), GraphViz DOT (graph
description language) \cite{Gansner1993}, plaintext documents, \LaTeX{}, and
\TeX{}. Drasil's source code is publicly available on
\porthref{GitHub}{https://github.com/JacquesCarette/Drasil}, and Drasil's
documentation
(\porthref{user-facing}{https://jacquescarette.github.io/Drasil/docs/index.html},
and
\porthref{internal}{https://jacquescarette.github.io/Drasil/docs/full/index.html})
is available on the Drasil project
\porthref{homepage}{https://jacquescarette.github.io/Drasil/}. Drasils public
wiki is hosted on the same \porthref{GitHub
      repository}{https://github.com/JacquesCarette/Drasil/wiki}, containing
information on potential future Drasil projects, Drasil-related papers, a
\porthref{developer workspace configuration and ``quick start''
      guide}{https://github.com/JacquesCarette/Drasil/wiki/New-Workspace-Setup}, and a
guide for \porthref{building your own project with
      Drasil}{https://github.com/JacquesCarette/Drasil/wiki/Creating-Your-Project-in-Drasil}.

\section{Methodology}

Drasils development is strongly influenced by its case studies, which focus on
building scientific software based on solving undergraduate-level physics
problems. A ``control'' program and \acs{srs} are manually created and used as a
baseline target for the final artifact. Development is focused on creating a
system of justification for each component of the baseline program, following a
``bottom-up'' agile \todo{Double check if it is indeed an agile approach}
development approach. Drasil has been constructed following the demands and
requirements of eight (8) case studies:

\caseStudiesTable

\subsection{Knowledge Dissection and Capture via ``Bottom-Up'' Gathering}

Once baseline/target artifacts are constructed, the essence of the artifacts are
dissected and broken into various \textit{fragments} of knowledge. The fragments
of knowledge are continuously broken up and explored/understood (via capture
through creating knowledge encodings in Haskell) until a sufficient holistic
understanding is formed, generalized, and proven to be capable of re-generating
the baseline artifacts. Hopefully, at the end, the baseline artifacts will have
their flaws highlighted and resolved in the produced artifacts.

In the end of the bottom-up gathering approach, there will need to be knowledge
encodings for, at least:

\begin{enumerate}

      \item the artifact-knowlege encodings -- Java, JSON, Python, HTML, SVG,
            etc. all use a different language.

      \item the meta-level knowledge encodings -- information lost in the
            implementations of specific programs needs to be regained so that we
            can reconstruct it in the original (and other) languages, where
            possible.

\end{enumerate}

To some degree, the artifact-knowledge encodings may be thought of as a
``phenomenon'' to Drasil. They may become part of the meta-level knowledge
encodings as well, but they are also generally where the side-effects of Drasil
appear, and file artifacts created.

\subsection{Overview}

The most immediate fragments of relevant knowledge are those that discuss the
produced artifacts. Naturally, Drasil is limited to software-based side effects,
but focused on producing \textit{files} on a computer.

The case studies are focused on constructing scientific software that follow a
precise \acs{srs} \cite{SmithAndLai2005}\todo{Discuss Dr.Smiths template a bit
      more, I need to explain the sections quickly}. Therefore, all artifacts are
produced with the goal of providing a user with a (i) \acl{srs}, and (ii) a
usable software that adheres to the \acl{srs}.

The encodings of the desired artifact files are next most important. For
example, an \acs{srs} artifact is typically a file that an end-user will be
viewing (read-only). Thus, a PDF is appropriate, but also inappropriate due to
its complexity, and, hence, we look to constructing \acs{srs} documents using a
series of files built with a textual markup language, and designating that a
secondary compiler should be used to compile the files into a PDF. Naturally,
\LaTeX{}, \TeX{}, and \acs{html} are the immediately desired textual markup
languages for their usability in scientific scenes, portability, large
user-base, and free nature (as opposed to proprietary languages). For a software
artifact, there are likely a few relevant fragments, but those most immediately
important are the language (programming or otherwise) of the software artifacts
and the method to use and compile the software artifact. Generating a Java
program will require for Drasil to have a working encoding of Java programs, and
a means of directing users on how to use a residual Java program.

Once satisfactory encodings of file types are formed, we must look to the
purpose of the files and justify their existence. While a JSON file is strictly
for data serialization and deserialization, a Java file is either the ``entry''
to a program (via it's \texttt{main} method) or a file that might be some useful
to, and/or used in, a Java program. Therefore, we must create a system of
reasoning for why files belong where they do (this might be a part of the
language encoding itself as well). For executable software artifacts, the desire
is to have an end-user \textit{execute} the final software artifacts produced,
and thus we must gain information on what the user expects, and desires. Where
feasible, also creating a conceptual understanding how a program meets their
expectations and desires. With each of Drasil's case studies, a series of
\textit{inputs} are provided to an executable program, and the program is
expected to produce \textit{outputs} that somehow make use of the inputs.
Drasils case studies form a system of relations for each study that relates the
inputs to the outputs.

As Drasil is focused on forming scientific software that adheres to a specific
\acs{srs} template \cite{SmithAndLai2005}, the ``system of relations'' is
generally a language of forming a sequence of mathematical calculations.
Knowledge is continuously captured until a sufficient fundamental knowledge-base
is formed such that a user may generate families of software problems using any
relevant domain knowledge. In Drasils case studies, the knowledge capture is
heavily influenced by the \acs{srs} template \cite{SmithAndLai2005}.

This approach requires that there is sufficient implicit and explicit knowledge
around the \acs{srs} document such that a user/developer/machine may follow it,
without any external assistance (e.g., to clear up ambiguities). This ultimately
relies on developing a stable framework for collecting a collection of
``cookie-cutter'' pieces of knowledge, and interacting with them. By breaking
down knowledge into small units of knowledge, the end-result development cycle
should appear similar to using a projectional editor with appropriate \acs{ide}
tooling.

\intodo{Add an example of an SRS document, and explain how there is sufficient
      information in it such that we can use it to generate representational
      software that solves the relevant problems, with little or no manual/extra
      information (excluding design choices of the desired software artifacts).}

\begin{figure}[H]
      \centering
      \caption{Drasils Logo}
      \label{fig:drasilLogo}
      \includegraphics[width=0.6\linewidth]{\drasilLogo}
\end{figure}

\drasilPersonification

\section{Architecture}

Drasil relies on a domain expert encoding knowledge as a deeply embedded
\ACF{dsl} or record in Haskell. Instances of the knowledge also appear in the
Haskell source code. When knowledge is encoded in Drasil, we refer to it as a
\textit{Chunk} or \textit{knowledge fragment} (they will be used interchangeably
for the purposes of this thesis). The chunks relevant Haskell-level type is its
classifier, and each chunk must have a \ACF{uid} so that one might be able to
refer to a specific occurrence of knowledge. Chunks are funneled into a
\textit{Chunk Database} (in Haskell, a \ChunkDB{}).

\intodo{Code snippet: ChunkDB original definition.}

A \ChunkDB{} is currently limited to the above listed chunks\todo{ref. code
      snippet of ChunkDB}, but one should assume that more data types are also
\textit{chunks} because this is merely a temporary restriction at the
moment. Relating back to the ideology (as discussed in
\autoref{chap:ideology}), in Drasil, the \ChunkDB{} is where the knowledge
is collected, placed, and grown (generated). \textit{Transformers} are
used to operate on the \Chunk{}s in the \ChunkDB{}. The transformers take
in some knowledge, optional \textit{refinement} information, and convert
it into some other knowledge fragment. Oddly\todo{Is it odd or expected?},
these transformations are seemingly ``against the grain'' of the
``bottom-up'' information gathering. Areas of precise and highly specific
fragments of knowledge have their key components used in generating
something in another language (this typically involves some sort of
information loss/strip in order to restrict the knowledge for a specific
purpose). The produced fragments are directed by the developer. By
composing a series of miniature, ``bite-sized'', transformations, we are
able to create large and highly complex (but well-thought-out and
understood).

The largest, most prominent transformer used in Drasil is that of the
\textit{SmithEtAl} knowledge transformer\todo{I'm naming this, which I really
      shouldn't be doing, but I need a name to refer to the SRS+Code generator we have
      at the moment.}. It is currently represented using the entry point to Haskell
programs, the \inlineHs{main :: IO ()} function is representative of the
transformation capabilities of our understanding of our case studies into
sufficient \acs{srs} documents, and ready-to-use software.

\intodo{Code snippet: ``main'' function of GlassBR.}

\todo{Ref. ``main'' function code snippet above.} displays an example, from the
\acs{glassbr} case study, of what a transformer looks like in Drasil. This
transformer takes knowledge collected, configures a transformation task for the
desired outputs, as prescribed by an orchestrating developer, and performs an
\inlineHs{IO ()} effect that dumps an \acs{srs} and a software artifact to the
host computer, in the local working directory. While not seemingly coupled, they
indeed are. The code generator focuses on understanding fragments/ideas relevant
to generating the \acs{srs}, with more stringent rules than the \acs{srs}
generator to create a coherent software artifact. The data collected in the
\ChunkDB{}s are collected at Drasil Haskell-level compile-time, instead of the
Drasil run-time, because the chunks are captured within Haskell source code
instead of an external resource. In other words, the data is embedded in Haskell
itself.

\intodo{Code snippet: ``genSRS''}

\intodo{Code snippet: ``genCode''}

\intodo{Code snippet: ``PrintingInformation'', ``SystemInformation'', \& ``Choices''}

\intodo{Discuss how PrintingInformation, SystemInformation, and Choices are used
      to configure a SmithEtAl transformer run.}

The \acs{srs} and software artifacts are optional features. They are also not
always guaranteed to function merely because they were executed. It is up to the
knowledge transcribers to ensure that the body of knowledge recorded is
logically consistent and well-understood to Drasil. In particular, the SmithEtAl
transformer requires that the recorded \textit{theories}/models are consistent,
and that, together, they are able to produce a meta-level holistic single theory
that connects a list of inputs to a list of outputs of a desired calculation.
The calculations should also be reasonably convertible in some programming
language if we decide to use the calculations for code generation as well.

\intodo{coloured diagram showing flow of information and how general information
      flow works}

\caseStudiesCodeTable

\intodo{note somewhere that NoPCM does not build Swift code due to the lack of a
      connected ODE library/solver, which is outside of the scope of this work.}

\begin{itemize}

      \item Uses a series of \ACFP{dsl} to build up the knowledge-base and
            ``story'' of a scene/project, until sufficient knowledge is built
            such that a generator may take the ``whole story'' and generate
            representational software artifacts. This can be seen more clearly
            by observing an \acs{srs} example.

      \item Generates \acs{oo} programs; \acs{gool} is used to generate code in
            C++/C, Java, Python, Swift, and C\#.

      \item Generates Doxygen, Markdown, HTML, TeX, Makefile, CSS, and more
            non-programming software artifacts.

      \item The \acs{srs} is generated in both HTML and PDF flavours.

      \item Briefly discuss the SmithEtAl \acs{srs} template. The \acs{srs}
            template dissects scientific software into well-understood
            components, which should provide sufficient information for a
            developer to build a representational software product.

      \item Notable type of knowledge for code generation: theories/models.
            \intodo{I should add an example of the encoding of a theory.}

      \item Creates a ``calculation path'' for a series of $x = f(a,b,c,...)$
            formed equations (e.g., simple LHS = complex RHS), and ODEs
            supported by python libraries.

      \item The calculation path relies (implicitly) on:
            \begin{itemize}

                  \item The Exprs of the RelationConcept being of the form: $x =
                              f(a,b,c,...)$

                  \item The ODEs being described by the expression language, but
                        we do not rely on being able to generate representing
                        computational code due to needing extra external
                        information (e.g., we require a supplementary packet of
                        information [ODEInfo]).

            \end{itemize}

\end{itemize}
