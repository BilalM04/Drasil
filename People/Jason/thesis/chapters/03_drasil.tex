\chapter{Drasil}
\label{chap:drasil}

\begin{writingdirectives}

      \item What is Drasil?
      \begin{enumerate}
            \item What does it do?
            \item Where can we find information about it?
            \item What are its successes?
      \end{enumerate}

      \item How does Drasil work?
      \begin{enumerate}
            \item SRS? Generation?
            \item Specifically, what are its current problems?
      \end{enumerate}

\end{writingdirectives}

\drasilLogoImg{}

\section{What is it? What can it do?}
\label{chap:drasil:sec:what-is-it-what-can-it-do}

Principally investigated by \porthref{Dr. Jacques
      Carette}{https://www.cas.mcmaster.ca/~carette/} and \porthref{Dr. Spencer
      Smith}{https://www.cas.mcmaster.ca/~smiths/},
\porthref{Drasil}{https://jacquescarette.github.io/Drasil/} is a software suite
for generating software for well-understood problems through a knowledge-first
approach \cite{Drasil2021}. Drasil captures the background knowledge involved
with software development to make it \textit{reusable}, improve
\textit{maintainability} of software, and strengthen \textit{traceability}
between desired ``software artifacts''\footnote{``Software artifacts'' being any
      file with a well-defined structure, such as plaintext files, Python code,
      \LaTeX{} code, \acs{html}, or \acs{json}.} and the background knowledge
\cite{SzymczakEtAl2016}. Currently, Drasil focuses on generating software
artifacts for \ACF{scs}, where it has been shown to improve software qualities,
such as \textit{verifiability}, \textit{reliability}, and \textit{usability}
\cite{Smith2018}.

\roughNetworkOfDomains{}

Drasils knowledge-capture approach to software development allows users to
remove themselves from the discussion of ``code'' and focus on the important
bits: the problem the code solves and how ``code'' ultimately relates to
it\footnote{Drasil allows users to ``keep at a safe distance'' from software,
      but only so far as Drasil has encoded the terminology the users rely on for
      conveying their problem to Drasil.}. Drasil relies on a \textit{network of
      domains} \cite{Czarnecki2005} to capture the knowledge required to generate
artifacts for a series of case studies (\refCaseStudiesTable{}) that Drasil
builds and uses to navigate development. Roughly, the network is as per
\refRoughNetworkOfDomains{}, where nodes are the major categories of
domains\footnote{In other words, each node contains its own subdomain as well}
and arrows are mappings between them. The case studies use structured \ACF{srs}
\cite{SmithAndLai2005} abstraction to describe scientific problems and the
background knowledge necessary for developers to manually build software.
Through sufficient capture of the background scientific knowledge\footnote{Such
      as the key theories, input and output variables, and assumptions.}, Drasil
generates software artifacts that solve the precise problem descriptions
(\refCaseStudiesCodeTable{}). One notable success of the knowledge capture is
the reusability of it to regenerate artifacts in different, but similarly
applicable, languages. For example, the \acs{glassbr} case study had
\porthref{software
      artifacts}{https://github.com/smiths/caseStudies/tree/master/CaseStudies/glass}
manually built. Once the knowledge was codified in Drasil, the same knowledge
allows re-creation in \porthref{other
      languages}{https://github.com/JacquesCarette/Drasil/tree/master/code/stable/glassbr}.

\caseStudiesTable{}

Drasil is able to generate a host of \ACF{oo} programming language source codes
through compiling to \ACF{gool} \cite{Carette2019,MacLachlan2020}, which
compiles to several \acs{oo} languages (such as Java, Python, C/C$++$, C\#, and
Swift\footnote{Note that Swift was not discussed in \cite{MacLachlan2020}, but
      the renderer was built by Brooks as well.}). Drasil also contains renderers for
printing \acs{html} files, Makefiles, basic Markdown (enough for ``READMEs''),
GraphViz DOT \cite{Gansner1993} diagrams, and plaintext, \LaTeX{} documents.
\acs{srs} abstractions are renderable in either \LaTeX{} or \acs{html}.

\section{How does it work? How is it used?}
\label{chap:drasil:sec:how-does-it-work-how-is-it-used}

As mentioned in \Cref{chap:drasil:sec:what-is-it-what-can-it-do}, Drasil relies
on building a tree of knowledge that contains sufficient information such that
software artifacts can be ``grown'' from them. The individual pieces of
knowledge are known as \textit{chunks} and are encoded as either \ACFP{adt} or
\ACFP{gadt}. Drasil, and all knowledge captured in Drasil, is deeply embedded in
Haskell \cite{Haskell2010} \porthref{source
      code}{https://github.com/JacquesCarette/Drasil/}\footnote{The source code
      compiles against \acs{ghc} 8.8.4 \cite{GHC884} and uses \acs{ghc} language
      extensions.}. Each chunk has a \textit{type} which defines its structural
information. Chunks contain information encoded with various \ACFP{dsl}. The
network of domains (roughly, \refRoughNetworkOfDomains{}) is made up of a series
of chunks connecting and discussing one another, similar to how we might discuss
abstract concepts.

The ``coherent \acs{srs} abstraction'' of \refRoughNetworkOfDomains{} is
modelled after the \textit{Smith et al.} formal \acs{srs} template
\cite{SmithAndLai2005}, while the ``scientific knowledge'' higher up is a set of
interconnected chunks (and, hence, \acsp{dsl}). The ``scientific knowledge''
chunks are used to fill in the ``gaps'' of the \acs{srs} template. For example,
if we wanted to encode a variable, \(\hat{q}_{\text{tol}}\), representing a real
number, ``Tolerable load,'' we might write it as
\refOriginalQuantityDictExampleHaskell{}, where it is of type \QuantityDict{}
(\refOriginalQuantityDictHaskell{}), the type of variable encodings.

\originalQuantityDictExampleHaskell{}

\originalQuantityDictHaskell{}

Notably, in \refOriginalQuantityDictExampleHaskell{}, the symbol,
\(\hat{q}_{\text{tol}}\), is built using a \Symbol{} \acs{dsl}. The capture of
domain-specific knowledge is what sets \acsp{dsl} apart from general-purpose
programming languages. Domain-specific abstractions create opportunities for
domain-specific \textit{interpretation and transformation} (e.g., optimization,
analysis, error checking, tool support, etc.) \cite{Czarnecki2005}. For example,
with the symbol for ``tolerable load,'' we have information about the structure
of the symbol itself: that ``q'' has a ``hat'' and a subscript ``tol.'' From
this, we can output the same information in alternative flavours if we desired,
such as plain text, or with Java-compatible naming convention (e.g.,
``qHatTol'').

Drasils \acs{srs} template contains more ``holes''\footnote{Or ``blanks'' if you
      think of the template as a ``fill-in-the-blanks'' puzzle.} for other
information necessary to creating a whole ``story'' about how
\textit{output variables} can be calculated according to a set of
\textit{input variables} and algorithm derived through a series of
\textit{theories}. With sufficient knowledge \textit{depth}\footnote{Note
      that the \acs{srs} template provides the \textit{breadth} needed by
      design!} for each relevant fragment, Drasil is able to automatically
``check'' it for consistency and coherence, and generate representational
code\footnote{``Representational code'' meaning software that solves the
      problem the related \acs{srs} abstraction describes, using the algorithm
      outlined.}.

Unfortunately, not all of Drasils case studies are capable of generating
representational code (\refCaseStudiesCodeTable{}). Some case studies
(\acs{gamephysics}, \acs{hghc}, and \acs{ssp}) are still actively being
developed, but are left incomplete at the time of writing. \acs{nopcm} is usable
in all languages supported by \acs{gool} except for Swift due to the lack of a
Drasil-supported \acs{ode} solving library for the Swift \acs{gool} renderer.
\acs{pdcontroller} was built \cite{DrasilPR2289Naveen} outside  the normal means
of Drasils case studies development. Code generation for \acs{pdcontroller} is
not impossible, it just requires more investigation by a domain expert for the
needs of the case study. However, both the issues related to \acs{nopcm} and
\acs{pdcontroller} are outside the scope of this work. In this work, we will
focus on a critical common denominator between all examples: capturing
mathematical knowledge for reliable \acs{srs} artifact generation. In
particular, we will focus on 2 primary aspects of mathematical knowledge: the
\textit{theories} and the \textit{expressions}.

\caseStudiesCodeTable{}

\section{An Example}
\label{chap:drasil:sec:example}

As already mentioned, the \acs{srs} template \cite{SmithAndLai2005} breaks up
software requirements and problems into a series of well-understood components,
providing developers with concrete solution requirements they must satisfy, and
domain experts with justification for problem solutions. Notably, the \acs{srs}
relates a programs \textit{inputs} to a set of \textit{outputs} using a set of
\textit{theories}. The inputs and outputs are sets of variables, with data that
need to be somehow fed into the program, or calculated and output by the
program. The theories connect the input variables to the output by forming a
\textit{solution/calculation path}. There are at least 3 kinds of
theories\footnote{There's also a 4th kind: Data Definitions, intended for
explaining how input variables should be interpreted by the solution program,
thus also explaining how they should be formatted; they are typically intended
to be implementation-focused, rather than theoretical.}: Theory Models, General
Definitions, and Instance Models. Theory Models and General Definitions provide
justification for the mathematics of the solution: the Instance Models. The
Instance Models, specifically, together form the calculation path.

For example, Drasils \porthref{\acs{projectile} case
study}{https://jacquescarette.github.io/Drasil/examples/projectile/SRS/srs/Projectile_SRS.html}
describes how to estimate if a launcher, aligned at a particular angle, will hit
a target from a specific distance. The \acs{srs} requires users to fill in the:
\begin{enumerate}
    \item input variables:
          \begin{enumerate}
              \item \(p_\mathit{target}\), the targets distance from the
                    launcher,
              \item \(v_\mathit{launch}\), the projectile launch speed,
              \item and \(\theta\), the launch angle.
          \end{enumerate}
    \item output variables:
          \begin{enumerate}
              \item \(s\), a message, explaining if the projectile hit the
                    target, fell short, or went long,
              \item and \(d_\mathit{offset}\), the expected distance between the
                    target position and the landing position.
          \end{enumerate}
    \item and theories, connecting the inputs to the outputs:
          \begin{enumerate}
              \item \({t_{\text{flight}}}=\frac{2 {v_{\text{launch}}}
                        \sin\left(\theta{}\right)}{\mathbf{g}}\), estimating
                    flight time with \(v_{\mathit{launch}}\) and \(\theta\),
              \item \({p_{\text{land}}}=\frac{2 {v_{\text{launch}}}^{2}
                        \sin\left(\theta{}\right)
                        \cos\left(\theta{}\right)}{\mathbf{g}}\), a calculation
                    of the landing position,
              \item \({d_{\text{offset}}}={p_{\text{land}}}-{p_{\text{target}}}\),
                    calculation of distance between the targets position and the
                    expected landing position of the projectile,
              \item and \(s=\begin{cases} \text{``The target was hit.''}, &
              |\frac{{d_{\text{offset}}}}{{p_{\text{target}}}}| < \varepsilon{}
              \\
              \text{``The projectile fell short.''}, & {d_{\text{offset}}} < 0 \\
              \text{``The projectile went long.''},  & {d_{\text{offset}}} >
              0\end{cases}\), \newline{}calculating the output message.
          \end{enumerate}
\end{enumerate}

From these 3 key bodies of information along with some supporting background
knowledge (such as assumptions, constants, etc.), Drasil forms a calculation
path, deriving the output variables from the input variables using the instance
models\footnote{And, less importantly, data definitions.}. Here, Drasil
approximately recognizes that to calculate the outputs, it approximately needs
to follow a path along the lines of the order of presented theories. With it,
Drasil is able to generate representational code. For example, \acsp{projectile}
generates \refOriginalJavaProjectileMain{} for one of the Java-flavoured
artifacts. In \refOriginalJavaProjectileMain{}, it uses a
\inlineCode{java}{write_output} method to output the calculated output variables
after calculating them using the relevant theories\footnote{Note:
\(t_\text{flight}\) is seemingly unused in the generated code, but it is used in
the derivation of \(p_\text{land}\). However, it being ``unused'' is irrelevant
to this work.}.

\originalJavaProjectileMain{}
