\chapter{Introduction}
\label{chap:introduction}

\begin{writingdirectives}

      \item \textit{Based on the content of a video by Dr. Cecile Badenhorst
            (\url{https://www.youtube.com/watch?v=c2oGY1c51jc}) and a post about
            writing introductions by UNSW:
            \url{https://www.student.unsw.edu.au/introductions}}

      \item Move 1: Establishing a research territory by:
      \begin{itemize}

            \item showing research area is important, interesting, and
                  incomplete

            \item reviewing previous research

      \end{itemize}

      \item Move 2: Establishing a niche by noting gaps in previous research.

      \item Move 3: Occupying the niche by:
      \begin{itemize}

            \item outlining purpose

            \item listing research questions

            \item announcing principal findings

            \item stating the value of the previous research

      \end{itemize}

      \item General Structure:
      \begin{itemize}

            \item Introduction:
                  \begin{itemize}

                        \item Jazzy information to get reader hooked

                        \item States purpose of chapter

                        \item Roadmap of what will be discussed in chapter

                  \end{itemize}

            \item Background: context of research problem, sets up the need for
                  research and relevance

            \item PPSQ: should be within first 3 pages of thesis, after intro +
                  background information.

            \item Research design and context: description of where the research
                  takes place (Drasil), introducing methodology briefly

            \item Assumptions, limitations, scope of research, and expected
                  outcomes: what do we need from this work

            \item Overview of chapters

      \end{itemize}

      \item Last Paragraph: summarize key points of chapter, link to next
      chapter

      \item What is the context of this research? What is it about?

      \item What problem does this research tackle?

      \item Why is the research problem important/significant?

      \item What previous research exists?

      \item What is the purpose of this research? What are the goals?

      \item What did the author contribute?
      \wqanswer{\Cref{sec:intro:contributions}}

      \item What does this thesis contain? \wqanswer{\Cref{sec:intro:outline}}

\end{writingdirectives}

Software developers pull on their understanding of a problem to form a software
solution. Working together, developers similarly pull their understanding from a
shared pool of information. The information always belongs to a whole domain of
other similar problems and information. Often, developers share their knowledge
through documentation, keeping every product owner ``in the loop.'' However, as
knowledge and requirements change, the software trails behind it until
developers manually update the code. This might mean, however, that they need to
update several areas as a result of one change. Additionally, communication of
information may be ambiguous at times, which leads to logical issues that others
may not have expected.

Focusing on \ACF{scs}, Drasil allows users to describe their scientific problems
using a formal \ACF{srs} structure that contains just enough information such
that Drasil can generate software artifacts that solve said problems. However,
Drasil is only capable of generating software for the problems that it has
structural information about and how the relevant information can be transformed
into other useful forms.

In this thesis, we will explore how Drasil captures information about scientific
theories and mathematical expressions, and how the way they are captured affects
how quickly and reliably we can generate relevant solving software.
Additionally, we will also explore how Drasil stores information in its internal
information database.

\section{Background}
\label{sec:intro:background}

\subsection{My Understanding of the Underpinning Ideology}

All software tells a story. Programs made to sanitize data contain a story of
what data needs adjusting and how it can be done. Programs made to store and
retrieve data from textual commands contain a story of how data can be stored
and retrieved. In these stories, we find we commonly use similar terminology and
ideas, which is why shared libraries exist. However, shared libraries typically
only share reusable code fragments, not necessarily the meta-level information
about what each component is and how it can be appropriately used. As such, some
might question the validity of the knowledge it pulls from. Additionally, the
library might not be readily accessible to your preferred programming language,
requiring you to create a \ACF{ffi}, which is often quite brittle and expensive
due to demanding complex compatibility analysis for each change. Hence, we often
look towards mature libraries and frameworks to underpin our projects, but
typically without strong guarantee that using the libraries together is safe. 

For example, the sinking of the Vasa ship \cite{wiki:Vasa_ship} was partially
caused by different teams working together but using different ``feet'' units
(the Swedish foot is 12'' while the Amsterdam foot is 11'') resulting in
unexpected weight distribution, contributing to its demise. Similarly, when the
Mars Climate Orbiter travelled to Mars, it met its demise very early due to a
navigation issue \cite{Siddiqi2018}. The commands sent from Earth used English
units (specifically, pound-seconds) while the orbiter assumed that it would
receive commands using the metric system (Newton-seconds). As such, the orbiter
missed it's intended orbit altitude, falling into the Martian atmosphere, and
ultimately disintegrating due to atmospheric stress. Lockheed Martin built the
orbiter control tool without properly conforming to \acsp{nasa} \ACF{sis}.

In both examples, the issue lies in the \textit{communication} between the story
and the developers, highlighted by demise of both implementations. Of course,
most software is not critical, and issues in most software will not result in an
orbiter disintegrating in Martian atmosphere, but, there is something that we
can learn: communication and synchronization is vital for problems and execution
of their solutions. In both examples, experts already had a stable understanding
of the ``story'' and how things should have panned out every step of the way.
Experts knew how each individual component should have interacted and had sound
rationale for why and how it worked, and how all the components together fit the
requirements of the cohesive story.

\subsubsection{Thoughts of Generation}

For stories where the end product is software, unlike the Vasa, we can remedy
the communication issue partially by unifying it under one cohesive story.
\Aclp{srs} play a large role in unifying communication of software needs.
However, the communication of the software requirements into the final software
product is still brittle, as it typically heavily relies on manual labour to
translate it into software. It is not yet simple enough to reliably produce
error-free programs which satisfy a precisely defined set of requirements.

So, now we wonder: why is it still not simple enough? Our end-goal should be
assembly-line style engineering of the software \cite{well-understood}. Asides
from human-error, one large issue is the communication itself is very sparse in
meta-level information and doesn't contain any strong guarantees of cohesion. To
remedy this, we look to codifying subsets of natural language (English) used to
communicate ideas, and the rules that ensure that phrases make sense. In other
words, we look towards additionally communicating the meaning of the words we
would write down in our software specifications documents. Through sufficiently
communicating all relevant pieces of information about a story and how that
story relates to software, we should then be able to \textit{generate}
conforming software artifacts. The generated software is then traceable to its
foundations and can be easily kept in synchronization (i.e., maintained) with
its story through merely re-generating it.

To my understanding, \textit{Drasil} explores this ideology, focusing on
generating scientific software from user-described scientific problems using
Drasil-understood terminology (i.e., ones that a scientific domain expert
previously encoded).

\subsection{Drasil}


Intended to ``generate all the things''\footnote{``Generate All the Things'' is
      Drasils slogan.},
\porthref{Drasil}{https://jacquescarette.github.io/Drasil/} is a
Haskell-based \cite{Haskell2010} software suite studying how knowledge
capture may improve modern software development. ``Knowledge'' is
considered ``captured'' in Drasil by codifying it and its relations to
other things using \ACFP{dsl} encoded as Haskells data types. For example,
``quantities'' (\QuantityDict{}s), as we've currently needed from a
physics-based point-of-view, are encoded as:

\originalQuantityDictHaskell{}

And an instance of a ``quantity'' might appear as:\\

\originalQuantityDictExampleHaskell{}

The ways that we can translate ``quantities'' into other ``things'' are encoded
as Haskell-level functions and instances of typeclasses, such as:

\tedioustodo{Code snippet: example of how QuantityDicts are converted into at
      least 1 or 2 other things (e.g., SRS rows, symbols, etc.).}

These codified pieces of ``knowledge'' are known as \textit{chunks} in Drasil,
and are collected in a single database (\refOriginalChunkDBHaskell) of typed
maps of chunks, referenced by their \ACFP{uid}. Drasil is developed through a
``bottom-up'' methodology against several \acs{scs} case studies
(\refCaseStudiesTable{}), capturing and de-duplicating knowledge as needed to
re-generate the original artifacts and more, in a wide variety of similarly
applicable languages. For example, Drasil makes use of the similarities of
\ACF{oo} languages by forming expressions in \ACF{gool} before compiling to the
specific instances of \acs{oo} languages (such as Java, C/C\+\+, C\#, Python,
etc.). Similarly, textual markup can be exported in similar languages, such as
\acs{html} and \LaTeX{}.

For example, the \ACF{glassbr} case study (examining predicting whether a glass
slab can withstand an explosive blast) had \porthref{software
      artifacts}{https://github.com/smiths/caseStudies/tree/master/CaseStudies/glass}
manually written. A coherent net of knowledge/discussion (a ``story'') is then
formed by dissecting the artifacts, understanding why each piece existed, what
it relates to and how, and how it can be translated into other things. The
original artifacts are then
\porthref{re-generated}{https://github.com/JacquesCarette/Drasil/tree/master/code/stable/glassbr}
in a wider variety of other languages by codifying how the net of knowledge can
be translated into other languages.

However, not all the case studies are capable of generating software artifacts
yet (\refCaseStudiesCodeTable{}). Each for their own reason, but we will focus
on a critical common denominator between them all: capturing mathematical
knowledge for reliable \acs{scs} artifact generation (and more).

\section{Problem Statement}
\label{sec:intro:problemStatement}

Domain-specific abstractions are what enable domain-specific
\textit{interpretation and transformation} (e.g., optimization, analysis, error
checking, tool support, etc.) \cite{Czarnecki2005}. The capture of
domain-specific knowledge (through abstractions) is which is what sets
\acsp{dsl} apart from general-purpose programming languages. Drasil relies on a
\textit{network of domains} (a network of domain knowledge connected by
\aclp{dsl}) to enable the complex information transformation needed to convert
an \acs{srs} document into code. In Drasil, this roughly appears as
\refRoughNetworkOfDomains{}, where the nodes are domains, and the arrows
represent mappings between them. However, this sketch is only rough;
realistically, the individual nodes are the ``domains of the \aclp{dsl}'' (i.e.,
the top-level domains they belong to, and not an accurate depiction of all the
\aclp{dsl} that actually exist in Drasil).

\roughNetworkOfDomains{}

As Drasil focuses on the generative software development of \acs{scs}, capturing
the domain of scientific knowledge is at the forefront of its priority list. The
depth and breadth of the network of domains is directly related to how many
opportunities for domain-specific transformations we can perform on a specific
pool of knowledge\qtodo{I feel like I should be able to cite Czarnecki2005 again
      here, but this isn't really how he worded it, is it fair to cite him here,
      or should I provide my own justification?}.

Drasil currently relies on a single universal untyped mathematical language to
describe general scientific and mathematical knowledge (including, but not
limited to, equations, relations, theories, derivations, constraints, and
definitions).

\easytodo{Code snippet: Encoding of a theory using a RelationConcept.}

Unfortunately, as general-purpose programming languages are to domain-specific
languages, a single universal mathematical language is to a series of formalized
and structured theory-specific languages. In other words, Drasils reliance on a
single mathematical language is limiting because of the complexity associated
with interpreting its terms, which lack information about the \textit{domain}
(science and mathematics).

As a result, transforming encoded theories into other forms (such as code) is a
complex task (similar to the complexity associated with transpiling a
general-purpose program into another \textemdash{} an exercise in futility!). Drasil is
unable to make intended and appropriate usage of the encoded mathematical
theories because of a lack of information about the structure of the
mathematical expressions. Since the language is also universal, there is
difficulty in separation of expression term-concern (you wouldn't worry about
derivatives if you were writing down expressions on your standard calculator,
because your calculator likely doesn't understand what derivatives are!). For
example, converting a universal mathematical language into Java will be
difficult, as there are many terms not immediately expressible. Additionally,
due to Drasils lack of type information about its mathematical expression
language, invalid expressions (and hence, domain knowledge) are possible to be
written, causing further issues in reliable formation and transformation into
usable high-quality \acs{scs}. Together, these issues fundamentally have to do
with the depth and breadth of the scientific knowledge: we aim to enable Drasils
network of domain knowledge to grow, and grow it (to some degree).

Finally, as Drasils network of domains continues to grow in different aspects
(such as creating new kinds of chunks, and creating type parameters for existing
chunks), Drasil faces difficulties in scaling its database of knowledge because
of its typed nature.

\section{Research Questions}
\label{sec:intro:researchquestions}

\begin{enumerate}

      \item[\namedlabel{rq:lang_division}{RQ1}] Drasil has a language of simple
            mathematical expressions that are used in multiple contexts. But not
            all expressions are valid in all contexts. How do we fix that?

      \item[\namedlabel{rq:modelkinds}{RQ2}] Drasil's current encoding of
            ``theories'' are essentially black boxes. We would like to be able
            to use some structural information present in the short list of the
            ``kinds'' of theories that show up in scientific computing. How do
            we codify that?

      \item[\namedlabel{rq:typing}{RQ3}] How can we ensure that our language(s)
            of simple mathematical expressions admits only valid expressions?

      \item[\namedlabel{rq:chunkdb}{RQ4}] Our current ``typed'' approach to
            collecting different kinds of data is hard to extend. How can we
            make it easier to extend?

\end{enumerate}

\section{Contributions of the Author}
\label{sec:intro:contributions}

In listed code snippets, I will refer to at least two major points of time in
relation to Drasils development (time measured by their git blob hash):
``current''\footnote{Blob hash: dc3674274edb00b1ae0d63e04ba03729e1dbc6f9} and
``original''\footnote{Blob hash: 9c26b43d3e30c3f618e534a3f176a5152729af74}
\latertodo{Switch these blob hashes to blob tags.}. The ``original'' code refers
to a code snippet as it was written before I was onboarded to Drasil. The
``current'' code includes my work, at least, but might also include the work of
others who were also contributing to the project while I was actively
contributing. The work of others might include, but not limited to, code
formatting, code commenting, and extensions.

Drasil has existed since 2014, and has already seen success in its case studies,
which are used to guide the development of Drasil. Drasils focus on \acs{scs}
relies on knowledge of mathematical theories and language, for which Drasil has
a working understanding of before this work. However, some case studies were
unable to participate in code generation due to a lack of flexible theory
information (\ref{rq:modelkinds}), or just being inapplicable. This work
contributes to structuring theory information and allowing for future developers
to encode more kinds of theories and their relationships with other things
(discussed in \Cref{chap:modelkinds}). The solution builds on a prototype by Dr.
Jacques Carette\footnote{Unfortunately, the code associated with the prototype
had been deleted.} that facilitates structured theories to define relationships
between ``code'' and ``theories.''

Theories rely on mathematical expressions as well. We commonly differ the usable
set of language in different contexts (you are free to write a lot more on your
pencil and paper derivations than on your typical calculator). To obtain
information about the expressibility in different contexts, we divide the
expression language using a \acs{ttf} \cite{Carette2009} encoding, with a
\acsp{gadt} backend for structural edits (\Cref{chap:modelkinds}). However,
``expressibility'' also relies on the expressions adhering to a precise
syntactic set of rules. As such, we build a system of typing rules for the
expression language (\Cref{chap:typedExpr}).

Finally, to enable capturing data with type parameters and generally scale
Drasils knowledge database (\ref{rq:chunkdb}), this work merges the typed
database collections into a single untyped, yet type-preserving, database
(discussed in \Cref{chap:storingChunks}).

\section{Thesis Outline}
\label{sec:intro:outline}

In \Cref{chap:ideology}, we discuss the focal ideology underpinning this work
and Drasil. \Cref{chap:drasil} describes Drasil, the host project carrying the
fruits of this work. \Cref{chap:modelkinds} discusses how theories are encoded
in Drasil (\ref{rq:modelkinds}), the issues associated with using a single
universal mathematical language to describe theories (\ref{rq:lang_division}),
and how we can resolve these problems. \Cref{chap:typedExpr} describes issues
associated with the formation of mathematical expressions (\ref{rq:typing}).
\Cref{chap:storingChunks} focuses on how Drasil stores information, and how it
can be scaled.
