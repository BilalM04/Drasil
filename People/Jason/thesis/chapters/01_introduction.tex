\chapter{Introduction}
\label{chap:introduction}

\begin{writingdirectives}

      \item \textit{Based on the content of a video by Dr. Cecile Badenhorst
            (\url{https://www.youtube.com/watch?v=c2oGY1c51jc}) and a post about
            writing introductions by UNSW:
            \url{https://www.student.unsw.edu.au/introductions}}

      \item Move 1: Establishing a research territory by:
      \begin{itemize}

            \item showing research area is important, interesting, and
                  incomplete

            \item reviewing previous research

      \end{itemize}

      \item Move 2: Establishing a niche by noting gaps in previous research.

      \item Move 3: Occupying the niche by:
      \begin{itemize}

            \item outlining purpose

            \item listing research questions

            \item announcing principal findings

            \item stating the value of the previous research

      \end{itemize}

      \item General Structure:
      \begin{itemize}

            \item Introduction:
                  \begin{itemize}

                        \item Jazzy information to get reader hooked

                        \item States purpose of chapter

                        \item Roadmap of what will be discussed in chapter

                  \end{itemize}

            \item Background: context of research problem, sets up the need for
                  research and relevance

            \item PPSQ: should be within first 3 pages of thesis, after intro +
                  background information.

            \item Research design and context: description of where the research
                  takes place (Drasil), introducing methodology briefly

            \item Assumptions, limitations, scope of research, and expected
                  outcomes: what do we need from this work

            \item Overview of chapters

      \end{itemize}

      \item Last Paragraph: summarize key points of chapter, link to next
      chapter

      \item What is the context of this research? What is it about?

      \item What problem does this research tackle?

      \item Why is the research problem important/significant?

      \item What previous research exists?

      \item What is the purpose of this research? What are the goals?

      \item What did the author contribute?
      \wqanswer{\Cref{sec:intro:contributions}}

      \item What does this thesis contain? \wqanswer{\Cref{sec:intro:outline}}

\end{writingdirectives}

Software developers pull on their understanding of problems to build software
solutions. Working together, developers similarly pull their understanding from
a shared pool of knowledge. The knowledge always belongs to a domain of other
similar problems. Often, developers share their knowledge through documentation,
keeping every product owner ``in the loop.'' However, as knowledge and
requirements change, the software trails behind it until developers manually
update the code. This might mean, however, that they need to update several
areas as a result of one change. Additionally, communication of information may
be ambiguous at times, which leads to logical issues that others may not have
expected.

Focusing on \ACF{scs}, Drasil allows users to describe their scientific problems
using an \ACF{srs} structure which conveys sufficient information such that
Drasil can generate a software solution to the problem they describe. However,
Drasil is only capable of generating software for the problems that it has
sufficiently ``understood'' (i.e., ones that have been encoded in Drasil).

In this thesis, we will explore how Drasil captures information about scientific
theories and mathematical expressions, and how the way they are captured affects
how quickly and reliably we can generate relevant solving software.
Additionally, we will explore how Drasil captures general knowledge.

\section{Background: Drasil}
\label{chap:introduction:sec:background}

\porthref{Drasil}{https://jacquescarette.github.io/Drasil/} is a software suite
for generating software from well-formed, principled ``stories.'' Focused on
\ACF{scs}, Drasil allows users to ``fill in the blanks'' to describe their
scientific problems using a precise \ACF{srs} format \cite{SmithAndLai2005}. By
providing sufficient information in the ``blanks,'' Drasil is able to generate
to use the relevant information to generate various software artifacts,
including whole programs (in various target languages), build tools, and
documentation. The ``blanks'' are holes for domain-specific knowledge and are
filled in using one of many`' \ACFP{dsl}. Each individual fragment of knowledge
in Drasil is known as a ``chunk,'' and we encode each useful idea necessary to
build our desired software artifacts as chunks using \acsp{dsl}.

\imptodo{Add back the quantity example here.... ``For example, let's say we
      wanted to encode the quantity ... as an input to Drasil. We might
      write.... And then, we would need to register this input to Drasils
      database.''}

The many used \acsp{dsl} make up a \textit{network of domains}
\cite{Czarnecki2005}, which allow Drasil to make domain-specific
transformations, such as the one most desired in Drasil: generating computation
software conforming to a precise \acs{srs}.

\roughNetworkOfDomainsIntro{}

Roughly, the above diagram shows how Drasils \textit{Smith et al.} knowledge
transformer works, with each node representing a domain of knowledge, and each
arrow representing a mapping between them. Drasil users mostly enter in their
scientific knowledge near the ``top'' of the diagram to form a coherent
\acs{srs} abstraction using relevant \acsp{dsl}. Afterwards, Drasil takes their
\acs{srs} abstraction, audits it, and allows the user to pick from a series of
options to generate software that conforming to the scientific problem encoded.

The ``scientific knowledge'' at the top of the diagram is not necessarily a
complete capture of all scientific knowledge, of course. Rather, it is a
collection of the scientific knowledge that was captured by dissecting a series
of case studies. Drasil relies on a series of manually built case studies to
provide ``seedling'' data to navigate development of Drasil. As more information
is ``taught'' to Drasil (through providing it with a means of discussing
relevant terms) and, specifically, the ties between various pieces of knowledge,
Drasils range of generation increases. However, not all case study projects are
currently capable of code generation.

Some case studies are currently in-progress (i.e., incomplete) and won't be a
focus of this work, but left for future work by others. Instead, we will focus
on those which \textit{we} understand how to produce code for, but that Drasil
isn't yet capable of generating code for. Specifically, we will largely focus on
a common denominator, strengthening mathematical knowledge capture, but we will
also spend time learning how to scale Drasils knowledge (chunk) database against
more knowledge capture.

\subsection{Theories and Expressions}

One of the most important aspect of describing scientific problems is:
describing the relevant \textit{theories}. Drasil relies on users describing
theory knowledge using \textit{relations} through a \textit{single universal
      untyped mathematical expression language}. Equations, relations, derivations,
constraints, and definitions are all described using this single language.
However, the language does not contain sufficient ``depth'' to adequately make
use of its encoded information. In other words, this expression language is a
lower-level view of the information we really need to make domain-specific
transformations,

Drasil attempts to use the \textit{theories} gathered from a user-filled
\acs{srs} to understand what problem they intended to describe (i.e.,
calculating the inputs and outputs, and a sequence of calculation steps that go
from the former to the latter). With this, Drasil tries to translate the theory
knowledge into other forms, including typesetting languages and programming
languages, where equally applicable. For typesetting languages, this is fairly
okay, because a typesetting language views the theories in the same shallow
light. However, converting it into a snippet of programming language is
considerably more complex because it has to follow the semantics of the
programming language, retaining the same meaning, albeit in a different base
language.

\imptodo{For example, let's convert a pseudocode example! $y = mx + b$ to code
      should be fairly straight forward.}

However, this example is reasonably simple. If we were handed an equation of
this \(\nu{} = f(x,y,z)\) form, it's reasonable\footnote{Though it might be an
      incorrect assumption!} to assume that one way to define \(\nu{}\) is
\(f(x,y,z)\). However, if we were handed an equivalent, scrambled version of it,
then we can assume less information\footnote{Undocumented and unchecked
      assumptions are bad anyway!} about it. For example, if we re-wrote it as
\(\frac{x}{y} - \nu{} = - z + 10\) where \(f(x,y,z) = \frac{x}{y} + z - 10\),
then we've lost the critical \textit{definition} assumption. Additionally, if
our original theory was more complex by being an \acs{ode}, describing multiple
ways to define \(\nu{}\), or being purely theoretical/abstract, then we might
not have even been able to use it in the first place, let alone use it with the
extra complexity involved with translating expressions with higher-order terms
to common programming languages. In other words, we also lack information about
the context under which a theory is relevant and usable. For example, if a
theory contained an expression that deals with derivatives, then we might not be
able to natively translate it into Java code without extra information about how
to or use non-primitive Java. As a result, knowing \textit{how to} and
\textit{when you can} transform captured theories into other forms (such as
executable code) is a complex task (similar to the complexity associated with
transpiling a general-purpose program into another \textemdash{} an exercise in
futility!).

With the theory encoding above, we also never discussed what \(y\), \(m\),
\(x\), nor \(b\) where. On paper and pencil, it's fairly reasonable to assume
that they are of the same numeric type, but if they weren't, then they might not
make much sense anymore. Hence, generating software artifacts wouldn't make
sense to do because we wouldn't be able to guarantee that they wouldn't reach an
invalid state. Additionally, each language that deals with computation has its
own type system, and so we would need to have Drasil understand the types we're
working with in order to have it handle each target languages type system
respectively. For example, in Swift, you can't add two numbers if they're not of
the same type (e.g., you can't add a double and an integer), while in Java, you
can because of implicit type coercion.

\subsection{Capturing (\& Remembering) Everything}

The most important component of Drasil is knowledge capture. As already
mentioned, it's done through encoding the terminology we use to discuss ideas.
In Drasil, instances of these are referred to as \textit{chunks}, each one has a
\textit{type} that it belongs to, and a \ACF{uid}. The type is an identifier
that indicates the structure of the values, and the \acs{uid} is used to
uniquely name the chunk data. The chunk is unique with respect to a global
``chunk database'' that Drasil has users register all chunk into. The chunk
database is intended to carry all newly generated chunks as well. At the moment,
Drasils chunk database uses a series of typed maps with \acs{uid} keys and chunk
values, which means that as we create new types of chunks in Drasil, the list
will grow. Additionally, the list of types have to be known before using Drasil,
which means that users can't grow the chunk hierarchy if they need something
custom, unless they're willing to completely fork Drasil. In other words, the
current chunk database is not \textit{extensible} because of it's typed nature.

\section{Problem Statement}
\label{sec:intro:problemStatement}

\imptodo{Re-do the problem statement.}

\begin{itemize}
      \item theory structural knowledge
      \item scope of the expression language
      \item expression language is untyped
      \item scaling against new types
\end{itemize}

Additionally, due to Drasils lack of type information about its mathematical
expression language, invalid expressions (and hence, domain knowledge) are
possible to be written, causing further issues in reliable formation and
transformation into usable high-quality \acs{scs}.

Together, these issues fundamentally have to do with the depth and breadth of
the scientific knowledge: we aim to enable Drasils network of domain knowledge
to grow, and grow it (to some degree).

Finally, as Drasils network of domains continues to grow in different aspects
(such as creating new kinds of chunks, and creating type parameters for existing
chunks), Drasil faces difficulties in scaling its database of knowledge because
of its typed nature.

\subsection{Research Questions}
\label{sec:intro:researchquestions}

\imptodo{Make the difference between RQ1 and RQ3 more clear, or, optionally,
      just get rid of RQ1.}

\imptodo{The Background section should contain concrete examples of the issues
      that the RQs refer to.}

\begin{enumerate}

      \item[\namedlabel{rq:lang_division}{RQ1}] Drasil has a language of simple
            mathematical expressions that are used in multiple contexts. But not
            all expressions are valid in all contexts. How do we fix that?

      \item[\namedlabel{rq:modelkinds}{RQ2}] Drasil's current encoding of
            ``theories'' are essentially black boxes. We would like to be able
            to use some structural information present in the short list of the
            ``kinds'' of theories that show up in scientific computing. How do
            we codify that?

      \item[\namedlabel{rq:typing}{RQ3}] How can we ensure that our language(s)
            of simple mathematical expressions admits only valid expressions?

      \item[\namedlabel{rq:chunkdb}{RQ4}] Our current ``typed'' approach to
            collecting different kinds of data is hard to extend. How can we
            make it easier to extend?

\end{enumerate}

\section{Contributions of the Author}
\label{sec:intro:contributions}

In listed code snippets, I will refer to at least two major points of time in
relation to Drasils development (time measured by their git blob hash):
``current''\footnote{Blob hash: dc3674274edb00b1ae0d63e04ba03729e1dbc6f9} and
``original''\footnote{Blob hash: 9c26b43d3e30c3f618e534a3f176a5152729af74}
\latertodo{Switch these blob hashes to blob tags}. The ``original'' code refers
to a code snippet as it was written before I was onboarded to Drasil. The
``current'' code includes my work, at least, but might also include the work of
others who were also contributing to the project while I was actively
contributing. The work of others might include, but not limited to, code
formatting, code commenting, and extensions.

Drasil has existed since 2014, and has already seen success in its case studies,
which are used to guide the development of Drasil.

Drasils focus on \acs{scs} relies on knowledge of mathematical theories and
language, for which Drasil has a working understanding of before this work.

However, some case studies were unable to participate in code generation due to
a lack of flexible theory information (\ref{rq:modelkinds}), or just being
inapplicable.

This work contributes to structuring theory information and allowing for future
developers to encode more kinds of theories and their relationships with other
things (discussed in \Cref{chap:modelkinds}).

The solution builds on a prototype by Dr. Jacques
Carette\footnote{Unfortunately, the code associated with the prototype had been
deleted.} that facilitates structured theories to define relationships between
``code'' and ``theories.''

Theories rely on mathematical expressions as well. 

We commonly differ the usable set of language in different contexts (you are
free to write a lot more on your pencil and paper derivations than on your
typical calculator).

To obtain information about the expressibility in different contexts, we divide
the expression language using a \acs{ttf} \cite{Carette2009} encoding, with a
\acsp{gadt} backend for structural edits (\Cref{chap:modelkinds}).

However, ``expressibility'' also relies on the expressions adhering to a precise
syntactic set of rules.

As such, we build a system of typing rules for the expression language
(\Cref{chap:typedExpr}).

Finally, to enable capturing data with type parameters and generally scale
Drasils knowledge database (\ref{rq:chunkdb}), this work merges the typed
database collections into a single untyped, yet type-preserving, database
(discussed in \Cref{chap:storingChunks}).

\section{Thesis Outline}
\label{sec:intro:outline}

\Cref{chap:modelkinds} discusses how Drasil contains captured theories and
allows users to transcribe instances of them (\ref{rq:modelkinds}), and the
issues associated with using a single universal mathematical language to
describe theories (\ref{rq:lang_division}). \Cref{chap:typedExpr} discusses
issues associated with the formation of mathematical expressions and what it
means for expressions to be ``well-formed'' (\ref{rq:typing}).
\Cref{chap:storingChunks} focuses on how Drasil stores information, and how it
can scale against future development of Drasil and libraries (\ref{rq:chunkdb}).
