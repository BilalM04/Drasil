\chapter{Introduction}
\label{chap:introduction}

\begin{writingdirectives}

      \item \textit{Based on the content of a video by Dr. Cecile Badenhorst
            (\url{https://www.youtube.com/watch?v=c2oGY1c51jc}) and a post about
            writing introductions by UNSW:
            \url{https://www.student.unsw.edu.au/introductions}}

      \item Move 1: Establishing a research territory by:
      \begin{itemize}

            \item showing research area is important, interesting, and
                  incomplete

            \item reviewing previous research

      \end{itemize}

      \item Move 2: Establishing a niche by noting gaps in previous research.

      \item Move 3: Occupying the niche by:
      \begin{itemize}

            \item outlining purpose

            \item listing research questions

            \item announcing principal findings

            \item stating the value of the previous research

      \end{itemize}

      \item General Structure:
      \begin{itemize}

            \item Introduction:
                  \begin{itemize}

                        \item Jazzy information to get reader hooked

                        \item States purpose of chapter

                        \item Roadmap of what will be discussed in chapter

                  \end{itemize}

            \item Background: context of research problem, sets up the need for
                  research and relevance

            \item PPSQ: should be within first 3 pages of thesis, after intro +
                  background information.

            \item Research design and context: description of where the research
                  takes place (Drasil), introducing methodology briefly

            \item Assumptions, limitations, scope of research, and expected
                  outcomes: what do we need from this work

            \item Overview of chapters

      \end{itemize}

      \item Last Paragraph: summarize key points of chapter, link to next
      chapter

      \item What is the context of this research? What is it about?

      \item What problem does this research tackle?

      \item Why is the research problem important/significant?

      \item What previous research exists?

      \item What is the purpose of this research? What are the goals?

      \item What did the author contribute?
      \wqanswer{\Cref{sec:intro:contributions}}

      \item What does this thesis contain? \wqanswer{\Cref{sec:intro:outline}}

\end{writingdirectives}

Software developers pull on their understanding of a problem to form a software
solution. Working together, developers similarly pull their understanding from a
shared pool of information. The information always belongs to a whole domain of
other similar problems and information. Often, developers share their knowledge
through documentation, keeping every product owner ``in the loop.'' However, as
knowledge and requirements change, the software trails behind it until
developers manually update the code. This might mean, however, that they need to
update several areas as a result of one change. Additionally, communication of
information may be ambiguous at times, which leads to logical issues that others
may not have expected.

Focusing on \ACF{scs}, Drasil allows users to describe their scientific problems
using a formal \ACF{srs} structure that contains just enough information such
that Drasil can generate software artifacts that solve said problems. However,
Drasil is only capable of generating software for the problems that it has
structural information about and how the relevant information can be transformed
into other useful forms.

In this thesis, we will explore how Drasil captures information about scientific
theories and mathematical expressions, and how the way they are captured affects
how quickly and reliably we can generate relevant solving software.
Additionally, we will also explore how Drasil stores information in its internal
information database.

\section{Background}
\label{sec:intro:background}

\subsection[Ideology]{Ideology\footnotemark}

\footnotetext{Or, at least, my understanding of the ``ideology'' underpinning
      Drasil.}

All software tells a story. Programs made to sanitize data contain a story of
what data needs adjusting and how it can be done. Programs made to store and
retrieve data from textual commands contain a story of how data can be stored
and retrieved. In these stories, we find we commonly use similar terminology and
ideas, which is why shared libraries exist. However, shared libraries typically
only share reusable code fragments, not necessarily the meta-level information
about what each component is and how it can be appropriately used. As such, some
might question the validity of the knowledge it pulls from. Additionally, the
library might not be readily accessible to your preferred programming language,
requiring you to create a \ACF{ffi}, which is often quite brittle and expensive
due to demanding complex compatibility analysis for each change. Hence, we often
look towards mature libraries and frameworks to underpin our projects, but
typically without strong guarantee that using the libraries together is safe.

For example, the sinking of the Vasa ship \cite{wiki:Vasa_ship} was partially
caused by different teams working together but using different ``feet'' units
(the Swedish foot is 12'' while the Amsterdam foot is 11'') resulting in
unexpected weight distribution, contributing to its demise. Similarly, when the
Mars Climate Orbiter travelled to Mars, it met its demise very early due to a
navigation issue \cite{Siddiqi2018}. The commands sent from Earth used English
units (specifically, pound-seconds) while the orbiter assumed that it would
receive commands using the metric system (Newton-seconds). As such, the orbiter
missed it's intended orbit altitude, falling into the Martian atmosphere, and
ultimately disintegrating due to atmospheric stress. Lockheed Martin built the
orbiter control tool without properly conforming to \acsp{nasa} \ACF{sis}.

In both examples, the issue lies in the \textit{communication} between the story
and the developers, highlighted by demise of both implementations. Of course,
most software is not critical, and issues in most software will not result in an
orbiter disintegrating in Martian atmosphere, but, there is something that we
can learn: communication and synchronization is vital for problems and execution
of their solutions. In both examples, experts already had a stable understanding
of the ``story'' and how things should have panned out every step of the way.
Experts knew how each individual component should have interacted and had sound
rationale for why and how it worked, and how all the components together fit the
requirements of the coherent and cohesive story.

\subsubsection{Thoughts of Generation}

For stories where the end product is software, unlike the Vasa, we can remedy
the communication issue partially by unifying it under one cohesive story.
\Aclp{srs} play a large role in unifying communication of software needs.
However, the communication of the software requirements into the final software
product is still brittle, as it typically heavily relies on manual labour to
translate it into software. It is not yet simple enough to reliably produce
error-free programs which satisfy a precisely defined set of requirements.

So, now we wonder: why is it still not simple enough? Our end-goal should be
assembly-line style engineering of the software \cite{well-understood}. Asides
from human-error, one large issue is the communication itself is very sparse in
meta-level information and doesn't contain any strong guarantees of coherence.
To remedy this, we look to codifying subsets of natural language (English) used
to communicate ideas, and the rules that ensure that phrases make sense. In
other words, we look towards additionally communicating the meaning of the words
we would write down in our software specifications documents. Through
sufficiently communicating all relevant pieces of information about a story and
how that story relates to software, we should then be able to \textit{generate}
conforming software artifacts. The generated software is then traceable to its
foundations and can be easily kept in synchronization (i.e., maintained) with
its story through merely re-generating it. Furthermore, similar to shared
libraries, reusability of codified knowledge is strong as well, because codified
terminology can also be similarly shared. However, unlike shared pieces of code,
shared pieces of knowledge is even more reusable, in that it can be translated
into other forms (including programming languages, where applicable).

To my understanding, Drasil \cite{Drasil2021} explores this ideology, focusing
on generating scientific software from user-described scientific problems using
Drasil-understood terminology (i.e., ones that a scientific domain expert
previously encoded).

\subsection{Drasil \textemdash{} ``Generate All The Things!''}

\drasilLogoImg{}

\porthref{Drasil}{https://jacquescarette.github.io/Drasil/} is a software suite
for generating software from well-formed stories, providing tools for exporting
artifacts in various languages, including programming languages (through
compiling to \ACF{gool} \cite{Carette2019} first), Makefiles, typesetting
languages, and more. \porthref{Dr. Jacques
      Carette}{https://www.cas.mcmaster.ca/~carette/} and \porthref{Dr. Spencer
      Smith}{https://www.cas.mcmaster.ca/~smiths/} are the principal investigators of
Drasil. Drasil is deeply embedded in Haskell \cite{Haskell2010}, relying on
Stack \cite{HaskellStack}, and compiling against \acs{ghc} 8.8.4 \cite{GHC884}.
Focused on generating \ACF{scs}, Drasil uses an encoded variant of the Smith et
al. \cite{SmithAndLai2005} \ACF{srs} template to allow users to ``fill in the
blanks'' to describe a scientific problem, and, ultimately, generate code that
solves the described scientific problem. The template breaks up scientific
software requirements into a series of coherent logical components, which guide
us in knowing what things we need to sufficiently encode in Drasil to give users
sufficient expressibility of their problems. Filled in \acs{srs} document are,
within reason, automatically checked for consistency and coherence. The
``blanks'' are cookie-cutter shapes with a specific structure that input data
must conform to. Drasil is built in Haskell \cite{Haskell2010}, and case studies
are embedded directly in the Haskell code as well, allowing us to use Haskells
rich tooling for creating \ACFP{dsl}. A series of \acsp{dsl} are used to
represent encoded knowledge and their relationships to other pieces of
knowledge, and input data into Drasil.

The capture of domain-specific knowledge is what sets \acsp{dsl} apart from
general-purpose programming languages. Domain-specific abstractions create
opportunities for domain-specific \textit{interpretation and transformation}
(e.g., optimization, analysis, error checking, tool support, etc.)
\cite{Czarnecki2005}. Drasil relies on a \textit{network of domains} (a network
of domain knowledge connected by \aclp{dsl}) to enable the complex information
transformation needed to convert an \acs{srs} document into code.

In Drasil, \textit{chunks} are the fragments of knowledge\footnote{At times, we
      will also refer to chunks as ``knowledge fragments,'' or, similarly, ``fragments
      of knowledge.''} that carry semantically meaningful information`'. Haskell
records and \ACFP{adt} are used to encode chunks, and functions and instantiated
typeclasses are used to describe relationships chunks share with each other.
Each chunk has a \textit{type} denoting the category of knowledge it belongs to,
and containing structural and capability information about instances of it. By
connecting and intertwining chunks into large cohesive stories, we're able to
form a network of domain models \cite{Czarnecki2005}.

\roughNetworkOfDomains{}

Roughly, the above diagram shows how Drasils \textit{Smith et al.} knowledge
transformer works, with each node representing a domain of knowledge, and each
arrow representing a mapping between them. Realistically, each node in the
diagram represent an encompassing domain of \acsp{dsl}, they all contain their
own network of domain knowledge\footnote{In other words, each node is merely the
      ``domain'' of a series of \acsp{dsl}. Thus, the diagram is not an accurate
      depiction of all \acsp{dsl} that actually exist in Drasil.}. It uses a pool of
scientific knowledge to form a coherent \acs{srs} abstraction of a problem, from
which we can generate both representational \acs{srs} documents and \acs{scs}
that satisfies the requirements set forth. Users of Drasil are quite far-removed
from the inner workings and ``lower-level''\footnote{While we often think of
      abstractions as being ``higher'' and ``lower'' level than others, we should be
      careful to only discuss them with respect to a particular aspect, as not all
      things may be sensibly related with this dichotomy.} abstractions of resultant
software artifacts. Drasil allows scientists to ``keep at a safe distance'' from
software, but only so far as Drasil has encoded the terminology the scientist
relies on for conveying their problem to Drasil. With respect to generating
usable software and typeset \acs{srs} documents, the ``higher-level'' domains
(\acs{srs} abstraction and scientific knowledge) are the most ``informationally
dense''\footnote{``Informationally dense'' in a sense that it contains more,
      reusable, meta-level knowledge than produced final software artifacts.} and
relied upon for the relevant generators to do their tasks appropriately.

For example, should a scientist want to create a Real number variable for
representing ``tolerable load'' with the symbol as $l_{Tol}$, they might encode
it as:

\originalQuantityDictExampleHaskell{}

Where a \QuantityDict{} represents a basic understanding of a \textit{quantity}:

\originalQuantityDictHaskell{}

\imptodo{Any closing thoughts before the move to the next section?}

\subsubsection{Development}

Drasil is developed through a ``bottom-up'' methodology against several manually
built physics-focused \acs{scs} case studies (conforming a respective
\acs{srs}), capturing and de-duplicating knowledge\footnote{In particular, the
      background scientific knowledge is decoupled from the source artifacts as part
      of this process.} as needed to re-generate the original artifacts.

\caseStudiesTable{}

Drasil has already been shown to increase productivity of building and
maintaining reliable and traceable software artifacts \cite{SzymczakEtAl2016},
and, in particular, for \acs{scs} \cite{Smith2018}. In particular, as a result
of capturing the semantic meaning of scientific problems (through the \acs{srs}
``story'' guiding), we're also able to generate the same \acs{scs} using other
programming languages and tools. For example, the \ACF{glassbr} case study had
\porthref{software
      artifacts}{https://github.com/smiths/caseStudies/tree/master/CaseStudies/glass}
manually written, but, thanks to Drasil capturing semantic meaning, Drasil is
capable of
\porthref{re-generating}{https://github.com/JacquesCarette/Drasil/tree/master/code/stable/glassbr}
the same software solution with extra options, including modularity, logging,
programming language, and more.

Drasil is currently capable of generating usable software through compiling to
\ACF{gool}, which can produce Java, C++, Python, C\# \cite{MacLachlan2020}, and
Swift\footnote{not discussed in MacLachlan's Master's thesis, but created by him
      as well, and available similarly}. Drasil also contains renderers for HTML,
Makefile, basic Markdown (enough for README), GraphViz DOT (graph description
language) \cite{Gansner1993}, plaintext documents, \LaTeX{}, and
\TeX{}.\qtodo{Is the paragraph, ended here, absolutely needed for my thesis? I
      think the only part I want to ``shoehorn'' in is Swift, to note the typing
      issues later.}

In order to make this (re-)generation and options-variability possible, Drasil
needed an encoding of the semantic meaning of the manually-built artifacts.
Thankfully, generating original \acs{srs} documents in more typesetting flavours
(\LaTeX{}/\TeX{} and \acs{html}) is relatively uncomplicated. As such, each case
study is capable of generating an \acs{srs} document in at least 2 flavours.
However, generating software artifacts adds considerable complexity. As such,
unfortunately, not all case studies are currently able to generate software with
relative ease (compared to the existing code-generating case studies, see
\refCaseStudiesCodeTable{}). Generating software artifacts requires
understanding what things you \textit{can say} in desired artifacts, what things
you \textit{want and need to say}, and how you can transform the latter into the
former.

\caseStudiesCodeTable{}

Some case studies aren't capable of generating representational
code\footnote{``Representational code'' meaning software that solves the problem
      the related \acs{srs} abstraction describes.} because they aren't fully filled
out yet, but, we won't focus on those here. Here, we will focus on a critical
common denominator between them: capturing mathematical knowledge for reliable
\acs{srs} artifact generation.

\imptodo{Continue writing here!}

Some case studies (\acs{gamephysics}, \acs{hghc}, and \acs{ssp}) are still
actively being developed, but are left incomplete at the time of writing. The
\acs{srs} is currently generated in both \LaTeX{}\ and \acs{html} flavours, with
the \LaTeX{}\ variant having supplementary build information for building to a
single \acs{pdf} file, and the \acs{html} variant accessible from a web browser
compliant with \acs{html} version 5 standards. The \acs{glassbr},
\acs{projectile}, \acs{pdcontroller}, and \acs{nopcm} case studies each are
capable of generating representational software. \acs{nopcm} is usable in all
languages supported by \acs{gool} except for Swift due to the lack of a
Drasil-supported \acs{ode} solving library for the Swift \acs{gool} renderer.
\acs{pdcontroller} was built outside the normal means of Drasils case studies
development, being built by Naveen Ganesh Muralidharan \cite{DrasilPR2289Naveen}
for a class he took at McMaster University. Code generation for
\acs{pdcontroller} is not impossible, it just requires more investigation for
the needs of the case study. However, both the issues related to \acs{nopcm} and
\acs{pdcontroller} are outside the scope of this work.

\begin{enumerate}

      \item Drasil currently relies on a single universal untyped mathematical
            language to describe general scientific and mathematical knowledge
            (including, but not limited to, equations, relations, theories,
            derivations, constraints, and definitions).

      \item These codified pieces of ``knowledge'' are known as \textit{chunks}
            in Drasil, and are collected in a single database
            (\refOriginalChunkDBHaskell) of typed maps of chunks, referenced by
            their \ACFP{uid}.

\end{enumerate}

\section{Problem Statement}
\label{sec:intro:problemStatement}

\imptodo{As Dr. Carette said, the Problem Statement should be very short. I
      should try to ramble less here. I can potentially move some of the content
      ``up.''}

Unfortunately, as general-purpose programming languages are to domain-specific
languages, a single universal mathematical language is to a series of formalized
and structured theory-specific languages. In other words, Drasils reliance on a
single mathematical language is limiting because of the complexity associated
with interpreting its terms, which lack information about how they can be
transformed into other forms (such as code).

As a result, transforming encoded theories into other forms (such as code) is a
complex task (similar to the complexity associated with transpiling a
general-purpose program into another \textemdash{} an exercise in futility!). Drasil is
unable to make intended and appropriate usage of the encoded mathematical
theories because of a lack of information about the structure of the
mathematical expressions. Since the language is also universal, there is
difficulty in separation of expression term-concern (you wouldn't worry about
derivatives if you were writing down expressions on your standard calculator,
because your calculator likely doesn't understand what derivatives are!). For
example, converting a universal mathematical language into Java will be
difficult, as there are many terms not immediately expressible. Additionally,
due to Drasils lack of type information about its mathematical expression
language, invalid expressions (and hence, domain knowledge) are possible to be
written, causing further issues in reliable formation and transformation into
usable high-quality \acs{scs}. Together, these issues fundamentally have to do
with the depth and breadth of the scientific knowledge: we aim to enable Drasils
network of domain knowledge to grow, and grow it (to some degree).

Finally, as Drasils network of domains continues to grow in different aspects
(such as creating new kinds of chunks, and creating type parameters for existing
chunks), Drasil faces difficulties in scaling its database of knowledge because
of its typed nature.

\subsection{Research Questions}
\label{sec:intro:researchquestions}

\imptodo{Make the difference between RQ1 and RQ3 more clear, or, optionally,
      just get rid of RQ1.}

\imptodo{The Background section should contain concrete examples of the issues
      that the RQs refer to.}

\begin{enumerate}

      \item[\namedlabel{rq:lang_division}{RQ1}] Drasil has a language of simple
            mathematical expressions that are used in multiple contexts. But not
            all expressions are valid in all contexts. How do we fix that?

      \item[\namedlabel{rq:modelkinds}{RQ2}] Drasil's current encoding of
            ``theories'' are essentially black boxes. We would like to be able
            to use some structural information present in the short list of the
            ``kinds'' of theories that show up in scientific computing. How do
            we codify that?

      \item[\namedlabel{rq:typing}{RQ3}] How can we ensure that our language(s)
            of simple mathematical expressions admits only valid expressions?

      \item[\namedlabel{rq:chunkdb}{RQ4}] Our current ``typed'' approach to
            collecting different kinds of data is hard to extend. How can we
            make it easier to extend?

\end{enumerate}

\section{Contributions of the Author}
\label{sec:intro:contributions}

In listed code snippets, I will refer to at least two major points of time in
relation to Drasils development (time measured by their git blob hash):
``current''\footnote{Blob hash: dc3674274edb00b1ae0d63e04ba03729e1dbc6f9} and
``original''\footnote{Blob hash: 9c26b43d3e30c3f618e534a3f176a5152729af74}
\latertodo{Switch these blob hashes to blob tags.}. The ``original'' code refers
to a code snippet as it was written before I was onboarded to Drasil. The
``current'' code includes my work, at least, but might also include the work of
others who were also contributing to the project while I was actively
contributing. The work of others might include, but not limited to, code
formatting, code commenting, and extensions.

\imptodo{Switch the below notes to point-form notes.}

\imptodo{Below paragraph: move ``new'' information to Background section
      somehow.}

Drasil has existed since 2014, and has already seen success in its case studies,
which are used to guide the development of Drasil. Drasils focus on \acs{scs}
relies on knowledge of mathematical theories and language, for which Drasil has
a working understanding of before this work. However, some case studies were
unable to participate in code generation due to a lack of flexible theory
information (\ref{rq:modelkinds}), or just being inapplicable. This work
contributes to structuring theory information and allowing for future developers
to encode more kinds of theories and their relationships with other things
(discussed in \Cref{chap:modelkinds}). The solution builds on a prototype by Dr.
Jacques Carette\footnote{Unfortunately, the code associated with the prototype
      had been deleted.} that facilitates structured theories to define relationships
between ``code'' and ``theories.''

\imptodo{Below paragraph: move ``new'' information to Background section
      somehow.}

Theories rely on mathematical expressions as well. We commonly differ the usable
set of language in different contexts (you are free to write a lot more on your
pencil and paper derivations than on your typical calculator). To obtain
information about the expressibility in different contexts, we divide the
expression language using a \acs{ttf} \cite{Carette2009} encoding, with a
\acsp{gadt} backend for structural edits (\Cref{chap:modelkinds}). However,
``expressibility'' also relies on the expressions adhering to a precise
syntactic set of rules. As such, we build a system of typing rules for the
expression language (\Cref{chap:typedExpr}).

Finally, to enable capturing data with type parameters and generally scale
Drasils knowledge database (\ref{rq:chunkdb}), this work merges the typed
database collections into a single untyped, yet type-preserving, database
(discussed in \Cref{chap:storingChunks}).

\section{Thesis Outline}
\label{sec:intro:outline}

\Cref{chap:modelkinds} discusses how Drasil contains captured theories and
allows users to transcribe instances of them (\ref{rq:modelkinds}), and the
issues associated with using a single universal mathematical language to
describe theories (\ref{rq:lang_division}). \Cref{chap:typedExpr} discusses
issues associated with the formation of mathematical expressions and what it
means for expressions to be ``well-formed'' (\ref{rq:typing}).
\Cref{chap:storingChunks} focuses on how Drasil stores information, and how it
can scale against future development of Drasil and libraries.






\imptodo{Move the below sentence, code snippet, and paragraph somewhere else.}

Chunks are funneled into a \textit{chunk database} (a \ChunkDB{}).

\originalChunkDBHaskell{}

A \ChunkDB{} is currently limited to the above listed chunks
(\refOriginalChunkDBHaskell{}), but one should assume that more data types are
also \textit{chunks} because this is merely a temporary restriction at the
moment. The types of each record item is approximately a map from a \UID{} to an
instance of a chunk (\refOriginalChunkDBTypeMapsHaskell{}).
