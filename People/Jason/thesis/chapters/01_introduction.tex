\chapter{Introduction}
\label{chap:introduction}

\begin{writingdirectives}

      \item \textit{Based on the content of a video by Dr. Cecile Badenhorst
            (\url{https://www.youtube.com/watch?v=c2oGY1c51jc}) and a post about
            writing introductions by UNSW:
            \url{https://www.student.unsw.edu.au/introductions}}

      \item Move 1: Establishing a research territory by:
      \begin{itemize}

            \item showing research area is important, interesting, and
                  incomplete

            \item reviewing previous research

      \end{itemize}

      \item Move 2: Establishing a niche by noting gaps in previous research.

      \item Move 3: Occupying the niche by:
      \begin{itemize}

            \item outlining purpose

            \item listing research questions

            \item announcing principal findings

            \item stating the value of the previous research

      \end{itemize}

      \item General Structure:
      \begin{itemize}

            \item Introduction:
                  \begin{itemize}

                        \item Jazzy information to get reader hooked

                        \item States purpose of chapter

                        \item Roadmap of what will be discussed in chapter

                  \end{itemize}

            \item Background: context of research problem, sets up the need for
                  research and relevance

            \item PPSQ: should be within first 3 pages of thesis, after intro +
                  background information.

            \item Research design and context: description of where the research
                  takes place (Drasil), introducing methodology briefly

            \item Assumptions, limitations, scope of research, and expected
                  outcomes: what do we need from this work

            \item Overview of chapters

      \end{itemize}

      \item Last Paragraph: summarize key points of chapter, link to next
      chapter

      \item What is the context of this research? What is it about?

      \item What problem does this research tackle?

      \item Why is the research problem important/significant?

      \item What previous research exists?

      \item What is the purpose of this research? What are the goals?

      \item What did the author contribute?
      \wqanswer{\Cref{sec:intro:contributions}}

      \item What does this thesis contain? \wqanswer{\Cref{sec:intro:outline}}

\end{writingdirectives}

Software developers pull on their understanding of problems to build software
solutions. Working together, developers similarly pull their understanding from
a shared pool of knowledge. The knowledge always belongs to a domain of other
similar problems. Often, developers share their knowledge through documentation,
keeping every product owner ``in the loop.'' However, as knowledge and
requirements change, the software trails behind it until developers manually
update the code. This might mean, however, that they need to update several
areas as a result of one change. Additionally, communication of information may
be ambiguous at times, which leads to logical issues that others may not have
expected.

Focusing on \ACF{scs}, Drasil allows users to describe their scientific problems
using an \ACF{srs} structure which conveys sufficient information such that
Drasil can generate a software solution to the problem they describe. However,
Drasil is only capable of generating software for the problems that it has
sufficiently ``understood'' (i.e., ones that have been encoded in Drasil).

In this thesis, we will explore how Drasil captures information about scientific
theories and mathematical expressions, and how the way they are captured affects
how quickly and reliably we can generate relevant solving software.
Additionally, we will explore how Drasil captures general knowledge.

\section{Background: Drasil}
\label{chap:introduction:sec:background}

\porthref{Drasil}{https://jacquescarette.github.io/Drasil/} is a software suite
for generating software from well-formed, principled ``stories.'' Focused on
\ACF{scs}, Drasil allows users to ``fill in the blanks'' to describe their
scientific problems using a precise \ACF{srs} format \cite{SmithAndLai2005}. By
providing sufficient information in the ``blanks,'' Drasil is able to generate
to use the relevant information to generate various software artifacts,
including whole programs (in various target languages), build tools, and
documentation. The ``blanks'' are holes for domain-specific knowledge and are
filled in using one of many`' \ACFP{dsl}. Each individual fragment of knowledge
in Drasil is known as a ``chunk,'' and we encode each useful idea necessary to
build our desired software artifacts as chunks using \acsp{dsl}.

\imptodo{Add back the quantity example here.... ``For example, let's say we
      wanted to encode the quantity ... as an input to Drasil. We might
      write.... And then, we would need to register this input to Drasils
      database.''}

The many used \acsp{dsl} make up a \textit{network of domains}
\cite{Czarnecki2005}, which allow Drasil to make domain-specific
transformations, such as the one most desired in Drasil: generating computation
software conforming to a precise \acs{srs}.

\roughNetworkOfDomainsIntro{}

Roughly, the above diagram shows how Drasils \textit{Smith et al.} knowledge
transformer works, with each node representing a domain of knowledge, and each
arrow representing a mapping between them. Drasil users mostly enter in their
scientific knowledge near the ``top'' of the diagram to form a coherent
\acs{srs} abstraction using relevant \acsp{dsl}. Afterwards, Drasil takes their
\acs{srs} abstraction, audits it, and allows the user to pick from a series of
options to generate software that conforming to the scientific problem encoded.

The ``scientific knowledge'' at the top of the diagram is not necessarily a
complete capture of all scientific knowledge, of course. Rather, it is a
collection of the scientific knowledge that was captured by dissecting a series
of case studies. Drasil relies on a series of manually built case studies to
provide ``seedling'' data to navigate development of Drasil. As more information
is ``taught'' to Drasil (through providing it with a means of discussing
relevant terms) and, specifically, the ties between various pieces of knowledge,
Drasils range of generation increases. However, not all case study projects are
currently capable of code generation.

Some case studies are currently in-progress (i.e., incomplete) and won't be a
focus of this work, but left for future work by others. Instead, we will focus
on those which \textit{we} understand how to produce code for, but that Drasil
isn't yet capable of generating code for. Specifically, we will largely focus on
a common denominator, strengthening mathematical knowledge capture, but we will
also spend time learning how to scale Drasils knowledge (chunk) database against
more knowledge capture.

\subsection{Theories and Expressions}

One of the most important aspect of describing scientific problems is:
describing the relevant \textit{theories}. Drasil relies on users describing
theory knowledge using \textit{relations} through a \textit{single universal
      untyped mathematical expression language}. Equations, relations, derivations,
constraints, and definitions are all described using this single language.
However, the language does not contain sufficient ``depth'' to adequately make
use of its encoded information. In other words, this expression language is a
lower-level view of the information we really need to make domain-specific
transformations,

Drasil attempts to use the \textit{theories} gathered from a user-filled
\acs{srs} to understand what problem they intended to describe (i.e.,
calculating the inputs and outputs, and a sequence of calculation steps that go
from the former to the latter). With this, Drasil tries to translate the theory
knowledge into other forms, including typesetting languages and programming
languages, where equally applicable. For typesetting languages, this is fairly
okay, because a typesetting language views the theories in the same shallow
light. However, converting it into a snippet of programming language is
considerably more complex because it has to follow the semantics of the
programming language, retaining the same meaning, albeit in a different base
language.

\imptodo{For example, let's convert a pseudocode example! $y = mx + b$ to code
      should be fairly straight forward.}

However, this example is reasonably simple. If we were handed an equation of
this \(\nu{} = f(x,y,z)\) form, it's reasonable\footnote{Though it might be an
      incorrect assumption!} to assume that one way to define \(\nu{}\) is
\(f(x,y,z)\). However, if we were handed an equivalent, scrambled version of it,
then we can assume less information\footnote{Undocumented and unchecked
      assumptions are bad anyway!} about it. For example, if we re-wrote it as
\(\frac{x}{y} - \nu{} = - z + 10\) where \(f(x,y,z) = \frac{x}{y} + z - 10\),
then we've lost the critical \textit{definition} assumption. Additionally, if
our original theory was more complex by being an \acs{ode}, describing multiple
ways to define \(\nu{}\), or being purely theoretical/abstract, then we might
not have even been able to use it in the first place, let alone use it with the
extra complexity involved with translating expressions with higher-order terms
to common programming languages. In other words, we also lack information about
the context under which a theory is relevant and usable. For example, if a
theory contained an expression that deals with derivatives, then we might not be
able to natively translate it into Java code without extra information about how
to or use non-primitive Java. As a result, knowing \textit{how to} and
\textit{when you can} transform captured theories into other forms (such as
executable code) is a complex task (similar to the complexity associated with
transpiling a general-purpose program into another \textemdash{} an exercise in
futility!).

With the theory encoding above, we also never discussed what \(y\), \(m\),
\(x\), nor \(b\) where. On paper and pencil, it's fairly reasonable to assume
that they are of the same numeric type, but if they weren't, then they might not
make much sense anymore. Hence, generating software artifacts wouldn't make
sense to do because we wouldn't be able to guarantee that they wouldn't reach an
invalid state. Additionally, each language that deals with computation has its
own type system, and so we would need to have Drasil understand the types we're
working with in order to have it handle each target languages type system
respectively. For example, in Swift, you can't add two numbers if they're not of
the same type (e.g., you can't add a double and an integer), while in Java, you
can because of implicit type coercion.

\subsection{Capturing (\& Remembering) Everything}

The most important component of Drasil is knowledge capture. As already
mentioned, it's done through encoding the terminology we use to discuss ideas.
In Drasil, instances of these are referred to as \textit{chunks}, each one has a
\textit{type} that it belongs to, and a \ACF{uid}. The type is an identifier
that indicates the structure of the values, and the \acs{uid} is used to
uniquely name the chunk data. The chunk is unique with respect to a global
``chunk database'' that Drasil has users register all chunk into. The chunk
database is intended to carry all newly generated chunks as well. At the moment,
Drasils chunk database uses a series of typed maps with \acs{uid} keys and chunk
values, which means that as we create new types of chunks in Drasil, the list
will grow. Additionally, the list of types have to be known before using Drasil,
which means that users can't grow the chunk hierarchy if they need something
custom, unless they're willing to completely fork Drasil. In other words, the
current chunk database is not \textit{extensible} because of it's typed nature.

\section{Problem Statement}
\label{sec:intro:problemStatement}

\begin{writingdirectives}
      \item theory structural knowledge
      \item scope of the expression language
      \item expression language is untyped
      \item scaling against new types
\end{writingdirectives}

Drasil isn't able to make domain-specific interpretation of encoded scientific
knowledge because it lacks structural knowledge. Additionally, due to Drasils
lack of type information impedes from generating reliably usable software (in
particular, that they type check). Together, these issues affect our ability to
reliably and flexibly generate software. Finally, Drasils chunk database is not
extensible, limited admissible chunk types to only those that exist in core
Drasil.

\subsection{Research Questions}
\label{sec:intro:researchquestions}

\begin{enumerate}

      \item[\namedlabel{rq:lang_division}{RQ1}] Drasil uses a single
            mathematical language to describe mathematical expressions for
            multiple contexts, including code, abstract discussions, and simple
            common arithmetic. However, in these different contexts, certain
            terms should be avoided because of their applicability. How can we
            restrict term usage by context?\qtodo{Should we remove this as an
            RQ? It was something we did along the way for ModelKinds,
            technically, and it might be too basic. I'm tending towards ``yes,
            remove it.''}

      \item[\namedlabel{rq:modelkinds}{RQ2}] Drasil's current encoding of
            ``theories'' are essentially black boxes. We would like to be able
            to use some structural information present in the short list of the
            ``kinds'' of theories that show up in scientific computing. How do
            we codify that?

      \item[\namedlabel{rq:typing}{RQ3}] How can we ensure that our language(s)
            of simple mathematical expressions admits only valid expressions?

      \item[\namedlabel{rq:chunkdb}{RQ4}] Our current ``typed'' approach to
            collecting different kinds of data is hard to extend. How can we
            make it easier to extend?

\end{enumerate}

\section{Contributions of the Author}
\label{sec:intro:contributions}

In listed code snippets, I will refer to at least two major points of time in
relation to Drasils development (time measured by their git blob hash):
``current''\footnote{Blob hash: dc3674274edb00b1ae0d63e04ba03729e1dbc6f9} and
``original''\footnote{Blob hash: 9c26b43d3e30c3f618e534a3f176a5152729af74}
\latertodo{Switch these blob hashes to blob tags}. The ``original'' code refers
to a code snippet as it was written before I was onboarded to Drasil. The
``current'' code includes my work, at least, but might also include the work of
others who were also contributing to the project while I was actively
contributing. The work of others might include, but not limited to, code
formatting, code commenting, and extensions.

Notable contributions include:

\begin{itemize}
      
      \item Splitting the mathematical expression language into 3, each with
            their own specific purpose, but using a \acs{ttf} to keep same
            user-friendliness (resolving \Cref{rq:lang_division}).

      \item Implementing \ModelKinds{} to expose theory structure knowledge,
            creating opportunity for new domain-specific interpretation of
            theory knowledge (resolving \Cref{rq:modelkinds}). The solution
            builds on a prototype by Dr. Jacques Carette\footnote{Unfortunately,
            the code associated with the prototype had been deleted.}.

      \item Adding type checking and inference to mathematical expression
            languages (resolving \Cref{rq:typing}).

      \item Created an extensible chunk database prototype that can register
            chunks with types external to core Drasil and chunks with type
            parameters (resolving \Cref{rq:chunkdb}).

\end{itemize}

We commonly differ the usable set of language in different contexts (you are
free to write a lot more on your pencil and paper derivations than on your
typical calculator). To obtain information about the expressibility in different
contexts, we divide the expression language using a \acs{ttf} \cite{Carette2009}
encoding, with a \acsp{gadt} backend for structural edits
(\Cref{chap:modelkinds}).

\section{Thesis Outline}
\label{sec:intro:outline}

In \Cref{chap:ideology}, we discuss what we can learn from the source code of
general software, and, specifically, how we can abstract over them to form
similar software, varying over certain aspects of the software.
\Cref{chap:drasil} discusses Drasil, a software suite for generating software
from coherent descriptions of scientific problems. \Cref{chap:modelkinds}
discusses how Drasil contains captured theories and allows users to transcribe
instances of them (\ref{rq:modelkinds}), and the issues associated with using a
single universal mathematical language to describe theories
(\ref{rq:lang_division}). \Cref{chap:typedExpr} discusses issues associated with
the formation of mathematical expressions and what it means for expressions to
be ``well-formed'' (\ref{rq:typing}). \Cref{chap:storingChunks} focuses on how
Drasil stores information, and how it can scale against future development of
Drasil and libraries (\ref{rq:chunkdb}).
