\chapter{\textquotedblleft{}Store All The Things\textquotedblright{}}
\label{chap:storingChunks}

\begin{writingdirectives}

      \item \textit{Problem}: Drasil can have any number of \textit{types} of
            chunks involved in any particular generation operation. While the
            types are useful in many regards, the types encumber us when we try
            to reference a specific chunk (by its \UID{}) without surrounding
            type information, which may not be important.

      \item Drasils \ChunkDB{} (\refOriginalChunkDBHaskell) collects chunks
            using a series of maps, one for each chunk type.

      \item \textit{Practical Problems}:
            \begin{itemize}

                  \item Does not allow us to ignore type information when it's
                        not really needed. i.e., in areas where we use bounded
                        polymorphism.

                  \item Scaling against new types of chunks.
                  
                  \item Scaling against type parameters.
                  
                  \item Data consistency.
                  
                  \item Can't properly answer ``what chunk does X UID refer
                        to?'' No definitive answer to examining a specific chunk
                        by its \UID{}.

            \end{itemize}

      \item \textit{Solution}: Without discard, mask the type information,
            ignoring differences in the chunks other than that which is
            minimally required of them, and unmask it as needed.

      \item \textit{Practical Solution}: We can use \ExistentialQuantification{}
            with new data type that can carry anything that provides a minimum
            needed functionality (i.e., providing \UID{}s for their own data,
            and for references). In doing this, we effectively ``drop the type
            information'' when it's placed into the chunk database. However, we
            allow for that chunk to be unpacked (with type information retained)
            later through using Haskell's \inlineHs{Data.Typeable} (part of
            \inlineHs{base} package). As such, we can merge the series of maps
            into a single map that collects all chunks.

\end{writingdirectives}

In Drasil vernacular, as discussed in \Cref{chap:drasil}, we call encoded
fragments of knowledge, ``chunks.'' In practice, users encode chunks using
Haskells basic \inlineHs{data} types (example later), tagging it with a
\ACF{uid}, typically contained within the record. \acsp{uid} are represented by
the \UID{} data type (a string of text, \refOriginalUidHaskell{}). For example,
\todo{ref example chunk definition below} the below example chunk definition
represents a commonly used packet of data associated with names.

\tedioustodo{Example of an uncomplicated chunk definition.}

In the above example, the chunk belongs to a specific \textit{type}
classification\todo{ref its type definition, from the appendix}. Drasil
leverages Haskells type system to create a system of reasoning about chunks. As
such, when we create instances of chunks, they are ``typed'' with a single fully
monomorphic type signature. Commonly, we create chunks to discuss relations
between other chunks. As such, chunks commonly also refer to other instances of
chunks, but, instead of storing whole constituent chunks within them, we store
\UID{} references to those constituent chunks. In doing this, we ensure that all
references to that chunk refer to the same piece of immutable data\todo{Is
memory usage a real issue with this? I also imagine this allows post-facto chunk
creation too.}.

\tedioustodo{Discuss classy lenses built.}

Searching for chunks by their \UID{}s requires us to have somewhere to search
from. Drasil requires developers to collect all of their relevant chunks inside
of an encompassing ``chunk database.'' The ``chunk database'' (\ChunkDB{}) is
built (as seen in \refOriginalChunkDBHaskell{}) using a series of maps
(\refOriginalChunkDBTypeMapsHaskell) that map \UID{} keys to chunk data. Each
map is a map from a \UID{} to a specific data monomorphic data type. As such, in
order to access a chunk by its \UID{}, the associated type of the chunk must be
known, even if operations we intended to use on the grabbed chunk are generic,
applicable to any similar category of chunks (such as those satisfying a
particular typeclass constraint set), or all ``chunks''. Additionally, since
there is one map per monomorphic type, it means that all chunk types must be
known and coded in the \ChunkDB{} beforehand. Of course, this means that set of
types that Drasil can work with is fixed, and, that if we have \(N\) types (with
no type parameters), then there must be \(N\) maps in the \ChunkDB{} data type.
However, for each chunk type with type parameters, each argument combination
would need to also be registered. Together, this leads to an ever-growing series
of maps, and scales poorly against new knowledge being ``taught'' to Drasil.
Additionally, since we have a collection of maps, ensuring \UID{} collisions
never occur becomes tedious.

\section{Scaling Against New Types}

Fundamentally, the issue with the \ChunkDB{} is that it caters to each
individual type by creating a map for each type, leading to tedious busy work to
make up for inflexibility.

In order to scale against new types, we need to make the database maps
type-agnostic, merging them all together. It should contain no hard-coded
references to any specific type, but describe what kinds of types are admissible
(which should be any valid chunk). However, this isn't to say that we should
erase all types. Rather, we should mask the type information for the purpose of
storage and minimum viable usage, but ensure that the type information can be
unmasked for retrieval and normal usage.

The question: how can we achieve this?

To collapse the series of maps into a single one, we need to have a common data
type for the maps ``value'' type. 

\badUniversalChunkCarriage{}

Now, we have a common data type to wrap our data in: \Chunk{}. Since the type
parameters expose the type of the internal data, we will be able to unpack the
Chunk box into the internal data as well. However, this type parameter is also
an issue for storage, we run into the same issue of needing to create a series
of maps, one for each type:

\showingBadChunkWouldFailChunkDB{}

We need to be able to ignore the type parameter entirely without losing the
ability to unpack the data as needed. The nice thing about this ``as needed''
clause is that we will have an explicit expectation of what the type
\textit{should} be. In other words, it is sufficient that we can \textit{safely
attempt} to unpack data and cast it to a specific data.

Thankfully, \acs{ghc} provides us with the ``Existential Quantification''
language feature \cite{GHC2020ExistentialQuantification} that we can enable by
placing a small compiler option at the top of our Haskell files (e.g.,
\mintinline{haskell}{{-# LANGUAGE ExistentialQuantification #-}}), or, in our
\texttt{package.yaml} files. The ``Existential Quantification'' feature allows
us to qualify over variable types. In  particular, this is useful for
heterogeneous lists with elements, sub-typed against a set of constraints, in
Haskell (which isn't normally encouraged, nor directly possible). In other
words, it is useful because it allows us to ignore the type while retaining the
value and a common basic functionality to all sub-typed elements through
accessing the structural information through a set of constraints. With this, we
can re-create \Chunk{} using \ExistentialQuantification{} to hide the type
parameter:

\voidDataChunks{}

Great! Now we can create a single map for our chunk collection.

\voidDataChunkDB{}

Ok, now we've created a mechanism to collapse all of our chunk maps into one,
but, we've encountered an issue: we've neglected retrieval functionality. Let's
see:

\brokenChunkRetriever{}

\Chunk{}s are currently an informational void. So, this results in a type
error\todo{Show the type error here.}. Haskell is unable to create the infinite
type coercion from \inlineHs{expectedQd}'s unknown type to a \QuantityDict{}.

So, how can we try to fix this? \inlineHs{Data.Typeable} to the rescue! With
\inlineHs{Data.Typeable}, we're able to work with any piece of data given to us
without being provided any information about the data directly.
\inlineHs{Data.Typeable} allows us to create constrained types with extra
functionality for casting (amongst other common reflection operations). First,
we need to alter our \Chunk{} data type to make the contained data satisfy the
\Typeable{} constraint that the \Typeable{} module needs for most of its
functionality. As of \acs{ghc} 7.10 (for which our targeted version of 8+ is
newer than), \acs{ghc} automatically instantiates the \Typeable{} typeclass for
all types.

\examinableChunkBox{}

Ok, now we should be able to retrieve chunks, and cast the chunk value types as
needed.

\workingChunkRetriever{}

To sum up, at this point:

\begin{itemize}

      \item We were able to mask individual chunk types by hiding them in
            \Chunk{} boxes, allowing us to avoid discussing specific chunk types
            when forming our \ChunkDB{}.

      \item \ChunkDB{} is now merely a single map that allows us to easily
            ensure that there are no \UID{} collisions.

      \item \ChunkDB{} scales against new chunk type creation because it
            discusses no specific types as it only discusses types through
            constraints. Through this, it scales against the creation of type
            parameters for Haskell-level types.

\end{itemize}

Now, let's impose restrictions on the admissible chunks, to ensure that they are
indeed ``admissible,'' namely:

\begin{enumerate}
      
      \item They should contain \UID{}s.
      
      \item They should know what chunks they directly depend on.

\end{enumerate}

One implicit contract we had with the chunks in the past, was that they were all
expected to have \UID{}s. Now, we can try to make this contract more explicit
through imposing typeclass constraints, as below:

\uidOwnershipContract{}

And then we would alter our \Chunk{} definition:

\chunksWithUidConstraint{}

Great! Now all chunks must ``have a \acs{uid}'' (exposed via their \HasUID{}
instances), but we don't have a guarantee that they are unique and owned solely
by a single instance of any chunk. This is fine for now, and is left for future
work as part of future work (\Cref{chap:futureWork:sec:chunks}).

For the last restriction we want to impose, we want to ensure that chunks are
always ``understandable'' in a sense that all chunks they depend on have already
been entered in the chunk database as well. In other words, all information they
depend on should have already been entered before they are entered.

\chunkDependenciesContract{}

And then we would alter our \Chunk{} definition:

\chunksWithUidAndRefListConstraint{}

As you can see, adding restrictions on all chunks is now also considerably
simpler. If we're interested, we can add a ``dump to X'' mechanism, where $X$ is
any encoding of our choice (such as \acs{json}), similarly. This is omitted for
brevity, but we chose to add this. For now, this chunk structure will be our
final definition of a chunk: an arbitrary \textit{thing} that has a type which
indicates how it's usable, a acs{UID}, and a list of \textit{things} it
references (and hence depends on) to be sufficiently ``understood.''

Now, we may move our gaze back to the \ChunkDB{} structure. The most commonly
used feature of the previous generation of the \ChunkDB{} was that it allowed
the user to grab \textit{all} chunks of a particular type in one go. We can
re-create this for this new \ChunkDB{} as well by using
\inlineHs{Data.Typeable}s \TypeRep{} signature representation of Haskell types:

\begin{pseudohaskell}{Grabbing All Chunks from the New ChunkDB}{grabAllChunksFromNewChunkDB}
findAllByType :: TypeRep -> ChunkDB -> [a]
findAllByType tr cdb = catMaybes \$ map (\\(_, c) -> if chunkTy c == tr then Just (unChunk c) else Nothing) (M.toList cdb)

chunkTy :: Chunk -> TypeRep
chunkTy (Chunk c) = typeOf c

unChunk :: Typeable a => Chunk -> Maybe a
unChunk (Chunk c) = cast c
\end{pseudohaskell}

However, this is something of an expensive and commonly performed task, so it's
inefficient. So, in order to make the \ChunkDB{} more ``industrial-strength,''
we can add an extra mechanism for caching in various ways to trade a bit of
memory for a frequent and expensive search operation.

\eztodo{Haskell code: new chunk database structure.}

Now, we have extra functionality for caching by \TypeRep{}s without needing to
calculate it every time we need it. Since it's frequently used in Drasils case
studies and artifact generation, this will save \acs{cpu} time. Additionally, we
added a traceability matrix to easily find which chunks depend on which (direct
ones only, indirect ones can be calculated later if needed).

\ChunkDB{} is now a usable core across Drasil-like projects (ones thriving on
the same ``knowledge-based programming'' ideology). At the moment, the database
prototype lies in a separate Haskell project. Work on incorporating the database
in Drasil has been halted due to \acs{uid} conflicts arising in the case
studies. The port lies in both a separate repository (in prototype form) and a
separate branch on Drasils git repository, but can only be merged into the
stable branch once we resolve the \acs{uid} conflicts.

\eztodo{Link to my prototyped source code for the upgraded chunk database.}

\matryoshkaDollsImg{}

The \acs{uid} conflicts occur because of how they were structured. The chunks
follow a ``gradual building'' pattern, similar to Matryoshka nesting
dolls (\refMatryoshkaDollsImg{}).

\eztodo{Example chunk definition.}

\eztodo{Example chunk definition.}

\eztodo{Example common chunk definition.}

In these above examples\footnote{The examples do not exist in Drasil, but they
represent how chunks are ``gradually built.''}, chunks rely on a common data
type for functionality related to displaying text related to the name, short
name, and abbreviation of things. The current system assumes that the chunks
share a \acs{uid}. In the previous generation of \ChunkDB{}, this is allowed
because there was no \UID{} uniqueness checking across types. However, the new
\ChunkDB{}s require \UID{} uniqueness across chunk types, leading to
incompatibility issues. As such, the structure comes in to question. They're
currently built in such a way that relies on assuming that certain chunk types
exist and are related to other chunk types that share a \UID{} with them. In
other words, a ``whole chunk'' is the union of the chunks with the same \UID{}
spread across the other chunk maps. There are many ways that this can be
resolved, all depending on the needs of ``chunk building.'' For example, there
are at least three (3) possible resolutions: 
\begin{inparaenum}[(i)]
      
      \item forcibly/naively changing the \UID{}s, 

      \item forcibly/naively collapsing the chunk structure, and 
      
      \item restructuring the chunk structure against the chunks, possibly
            learning how to re-create the easy chunk building style through
            other features.

\end{inparaenum}
However, a solution has not yet been decided. For this issue is largely out of
scope at the moment, and requires considerable work. 
