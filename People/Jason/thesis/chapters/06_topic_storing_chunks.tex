\chapter{``Store All The Things''}
\label{chap:storingChunks}

\intodo{Rewrite the point form notes in Storing Chunks chapter.}

\begin{itemize}

      \item \UID{}s

      \item ChunkDB: Multiple maps from \UID{}s to single types

      \item Problems occur:
            \begin{itemize}

                  \item \UID{} collisions

                  \item Difficult to ascertain what a specific chunk type is
                        from a \UID{}

                  \item ``ChunkDB'' is not a stable core across Drasil-like
                        projects (ones that thrive on the same ``knowledge-based
                        programming'' ideology). \ChunkDB{}s are essentially the
                        ``scope'' of a system.

            \end{itemize}

      \item Solution:
            \begin{itemize}

                  \item Merge the maps!

                  \item The key would be the same; a \UID{}.

                  \item The value type?

                  \item An existentially quantified \inlineHs{Data.Typeable.Typeable}!

                  \item e.g., \inlineHs{data Chunk = forall a. Typeable => Chunk a}.

            \end{itemize}

      \item But wait! We're missing a few things from chunks:
            \begin{itemize}

                  \item What knowledge does the chunk rely on already having
                        been ``registered'' in the database and ready?

                  \item They should have \UID{}s; where's our guarantee?

                  \item Debugging will be difficult; need an interface to dump
                        all information of a chunk quickly.

            \end{itemize}

      \item Ok, revise: \inlineHs{data Chunk = forall a. (Typeable a, HasUID a, HasChunkRefs a, Dumpable a) => Chunk a}

      \item Ok, much better now.

      \item Or is it? Still many problems!
            \begin{itemize}

                  \item How do we explain ``Data.Typeable''?

                  \item And ``HasUID''?

                  \item And ``HasChunkRefs''?

                  \item And ``Dumpable''?

            \end{itemize}

      \item Well, at the very least, now we're able to merge the ``chunk'' maps
            and fix many of the pre-existing problems (we're almost there!).
            However, now we're relying too much on Haskell. How do we explain
            those parts?

      \item Also, what are \UID{}s really? Do their information carry any real
            information? \textit{Rigid designators}.

\end{itemize}

\section{Future Work}

\subsection{Encodings}

\begin{itemize}

      \item With the above new definition of ``chunks'', they still remain a
            very vague idea, and still \textit{deeply embedded} (a place to
            recognize an encoding might be appropriate!) in Haskell.

      \item What are the kinds of chunks that can exist? What can be in a chunk,
            and what are we missing from the existing list of chunks?

      \item The problem with that is that we lose a lot of information by
            writing Haskell, and leaving the knowledge in the form of Haskell.

      \item We need to de-embed all chunks so that we can obtain a tangible
            understanding of them.

      \item Through de-embedding the chunks, we will also be forced to de-embed
            everything with it. This is including the ways in which we transform
            and generate ``new''-ish knowledge (not necessarily new types/kinds
            of knowledge, but new instances of types).

\end{itemize}


\begin{enumerate}

      \item What is a ``chunk''?
            \begin{itemize}
                  \item A ``chunk instance'' is a single \textit{term} of a
                        language.
                  \item A ``chunk type'' is a language itself.
            \end{itemize}

      \item What is a ``transformer''?
            \begin{itemize}
                  \item A ``transformer'' is a conversion of a term written in a
                        language into another term, potentially in another language.
                  \item Transformers rely on a well-understood dissection of
                        knowledge (contained in a chunk type/language) in order
                        transform it (potentially with other terms/information
                        as well) into another term.
            \end{itemize}

\end{enumerate}