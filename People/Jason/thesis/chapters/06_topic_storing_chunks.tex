\chapter{``Store All The Things''}
\label{chap:storingChunks}

\begin{writingdirectives}

      \item \textit{Problem}: Drasil can have any number of \textit{types} (of
            chunks) involved in any particular generation. While the types are
            useful in many regards, the types encumber us when we try to
            reference a specific chunk (by its \UID{}) without surrounding type
            information, which may not be important.

      \item Drasils \ChunkDB{} (\refOriginalChunkDBHaskell) collects chunks
            using a series of maps, one for each chunk type.

      \item \textit{Practical Problems}:
            \begin{itemize}

                  \item Does not allow us to ignore type information when its
                        not really needed. i.e., in areas where we use bounded
                        polymorphism.
                  
                        \intodo{Explain when it's not really needed (i.e.,
                        functions that just take any chunk that satisfy a
                        constraint and use them in some area, or just grabbing
                        the UID or the references of the chunk.)}

                  \item Scaling against new types of chunks.
                  
                  \item Scaling against type parameters.
                  
                  \item Data consistency.
                  
                  \item Can't properly answer ``what chunk does X UID refer
                        to?'' No definitive answer to examining a specific chunk
                        by its \UID{}.

            \end{itemize}

      \item \textit{Solution}: Without discard, mask the type information,
            ignoring differences in the chunks other than that which is
            minimally required of them, and unmask it as needed.

      \item \textit{Practical Solution}: We can use \ExistentialQuantification{}
            with new data type that can carry anything that provides a minimum
            needed functionality (i.e., providing \UID{}s for their own data,
            and for references). In doing this, we effectively ``drop the type
            information'' when it's placed into the chunk database. However, we
            allow for that chunk to be unpacked (with type information retained)
            later through using Haskell's \inlineHs{Data.Typeable} (part of
            \inlineHs{base} package). As such, we can merge the series of maps
            into a single map that collects all chunks.

\end{writingdirectives}

In Drasil vernacular, as discussed in \Cref{chap:drasil}, we call encoded
fragments of knowledge ``chunks.'' In practice, users encode chunks using
Haskells basic \inlineHs{data} types (example later), tagging it with a
\ACF{uid}, typically contained within the record. \acsp{uid} are represented by
the \UID{} data type\todo{ref Original UID Haskell}. For example, \todo{ref
example chunk definition below} the below example chunk definition represents a
commonly used packet of data associated with names.

\intodo{Example of a basic chunk definition.}

In the above example, the chunk is of a specific \textit{type}. Drasil leverages
Haskells type system to create a system of reasoning about chunks. As such, when
we create instances of chunks, they are ``typed'' with a single fully
monomorphic type signature. When chunks connect and intertwine other chunks,
instead of storing whole instances of those constituent chunks, we store \UID{}
references to those constituent chunks. In doing this, we ensure that all
references to that chunk refer to the same piece of immutable data. 

\intodo{Discuss classy lenses built.}

Searching for chunks by their \UID{}s requires us to have somewhere to search
from. Drasil requires developers to collect all of their relevant chunks inside
of an encompassing ``chunk database.'' The ``chunk database'' (\ChunkDB{}) is
built (as seen in \refOriginalChunkDBHaskell{}) using a series of maps
(\refOriginalChunkDBTypeMapsHaskell) that map \UID{} keys to chunk data. Each
map is a map from a \UID{} to a specific data monomorphic data type. As such, in
order to access a chunk by its \UID{}, the associated type of the chunk must be
known, even if operations we intended to use on the grabbed chunk are generic,
applicable to any similar category of chunks, or all chunks. Additionally, since
there is one map per monomorphic type, it means that all chunk types must be
known and coded in the \ChunkDB{} beforehand. Of course, this means that set of
types that Drasil can work with is fixed, and, that if we have \(N\) types (with
no type parameters), then there must be \(N\) maps in the \ChunkDB{} data type.
However, for each chunk type with type parameters, each argument combination
would need to also be registered. Together, this leads to an ever-growing series
of maps. Additionally, since we have a collection of maps, ... regarding UID
collision detection.

\intodo{What's the problem with this method of storing chunks?}

\intodo{How can we resolve it?}

\intodo{How can we mask the types and unmask them later?}


\intodo{Rewrite the point form notes in Storing Chunks chapter.}

\begin{itemize}

      \item \UID{}s

      \item ChunkDB: Multiple maps from \UID{}s to single types

      \item Problems occur:
            \begin{itemize}

                  \item \UID{} collisions

                  \item Difficult to ascertain what a specific chunk type is
                        from a \UID{}

                  \item ``ChunkDB'' is not a stable core across Drasil-like
                        projects (ones that thrive on the same ``knowledge-based
                        programming'' ideology). \ChunkDB{}s are essentially the
                        ``scope'' of a system.

            \end{itemize}

      \item Solution:
            \begin{itemize}

                  \item Merge the maps!

                  \item The key would be the same; a \UID{}.

                  \item The value type?

                  \item An existentially quantified \inlineHs{Data.Typeable.Typeable}!

                  \item e.g., \inlineHs{data Chunk = forall a. Typeable => Chunk a}.

            \end{itemize}

      \item But wait! We're missing a few things from chunks:
            \begin{itemize}

                  \item What knowledge does the chunk rely on already having
                        been ``registered'' in the database and ready?

                  \item They should have \UID{}s; where's our guarantee?

                  \item Debugging will be difficult; need an interface to dump
                        all information of a chunk quickly.

            \end{itemize}

      \item Ok, revise: \inlineHs{data Chunk = forall a. (Typeable a, HasUID a, HasChunkRefs a, Dumpable a) => Chunk a}

      \item Ok, much better now.

      \item Or is it? Still many problems!
            \begin{itemize}

                  \item How do we explain ``Data.Typeable''?

                  \item And ``HasUID''?

                  \item And ``HasChunkRefs''?

                  \item And ``Dumpable''?

            \end{itemize}

      \item Well, at the very least, now we're able to merge the ``chunk'' maps
            and fix many of the pre-existing problems (we're almost there!).
            However, now we're relying too much on Haskell. How do we explain
            those parts?

      \item Also, what are \UID{}s really? Do their information carry any real
            information? \textit{Rigid designators}.

\end{itemize}

\section{Future Work}

\subsection{Encodings}

\begin{itemize}

      \item With the above new definition of ``chunks'', they still remain a
            very vague idea, and still \textit{deeply embedded} (a place to
            recognize an encoding might be appropriate!) in Haskell.

      \item What are the kinds of chunks that can exist? What can be in a chunk,
            and what are we missing from the existing list of chunks?

      \item The problem with that is that we lose a lot of information by
            writing Haskell, and leaving the knowledge in the form of Haskell.

      \item We need to de-embed all chunks so that we can obtain a tangible
            understanding of them.

      \item Through de-embedding the chunks, we will also be forced to de-embed
            everything with it. This is including the ways in which we transform
            and generate ``new''-ish knowledge (not necessarily new types/kinds
            of knowledge, but new instances of types).

\end{itemize}


\begin{enumerate}

      \item What is a ``chunk''?
            \begin{itemize}
                  \item A ``chunk instance'' is a single \textit{term} of a
                        language.
                  \item A ``chunk type'' is a language itself.
            \end{itemize}

      \item What is a ``transformer''?
            \begin{itemize}
                  \item A ``transformer'' is a conversion of a term written in a
                        language into another term, potentially in another language.
                  \item Transformers rely on a well-understood dissection of
                        knowledge (contained in a chunk type/language) in order
                        transform it (potentially with other terms/information
                        as well) into another term.
            \end{itemize}

\end{enumerate}
