\chapter{Typing the Expression Language}
\label{chap:typedExpr}

Mathematical expressions are one of the most prominent components of any
abstracted concept from scientific software artifacts. With a pencil and paper,
our mistakes might go unnoticed, because they are never ``hard'' validated by
any machine, but ``soft'' validated by us and other readers. In other words,
there is no clear \textit{validity assertion} when we traditionally write
expressions on paper. While \Cref{chap:modelkinds} focused on understanding how
mathematical expressions could be dissected and transformed into ``code,'' it
neglected to discuss which expressions it could even begin to dissect and
transform \textemdash{} that is to say, which expressions are ``valid?'' The
objective of this chapter is to create a system of type rules, and enforce
well-formedness/typedness\footnote{Please note that I will be using
      ``well-formed'' and ``well-typed'' interchangeably.} through them, for Drasils
mathematical expression languages.

\section{Recap of Drasils Math-related Expression Languages}

To recap, at this point, we have three (3) relevant and used ``mathematical
expression'' languages.

\subsection{One for \textquotedblleft{}Simple\textquotedblright{} Mathematics}

\Expr{} is a mathematical expression languages whose vocabulary is intended to
always have a definite value. In other words, with little to no extra work on
your end, you should be able to directly input these expressions in your
standard calculator (perhaps with a bit of work to handle vectors, functions,
etc.) to evaluate them.

\subsection{One For \textquotedblleft{}Code\textquotedblright{}}

\CodeExpr{} is a heavily mathematics-focused expression language with a few
extra features over \Expr{} for \acs{gool}/``code.'' The vocabulary should be
nearly directly usable in \acs{gool} for outputting to general-purpose
object-oriented programming languages. \CodeExpr{} is a superset of \Expr{}:

\[\Expr{} \subseteq{} \CodeExpr{}\]

\subsection{And One For General Mathematics}

\ModelExpr{} is the classical mathematics we know and love. It contains nearly
everything we know (up to what we've encoded thus far) and is intended to be a
descriptive language, with no particular restrictions on its terms (other than
that they should at least be describable on pencil and paper too). \ModelExpr{}
is also a superset of \Expr{}:

\[\Expr{} \subseteq{} \ModelExpr{}\]

However, \ModelExpr{}s terms are unlikely to appear in \CodeExpr{} due to their
indescribable nature in computable \acs{oo} ``code.''

As of right now, these languages have proven themselves to be effective
encodings, weakly proven through Drasils case studies being able to produce
working software artifacts. However, they are not without issue. Notably, at the
moment, Drasil does not have any readily-available type information about their
constructions. This lack of type information hampers the ``reliability'' aspect
of the code generator because the generator is unable to restrict its output
artifacts to those which are directly usable. In order for the generated
artifacts to be directly usable, they must be \textit{type safe} programs. In
other words, we need to make sure that the interpreters and compilers used on
the generated artifacts never get confused/stuck on the generated expressions.
To obtain this, we must add type information, and use it.

\section{Type Safety}

\intodo{Continue writing here!}

\intodo{Discuss what ``type safety'' is. Discuss: types, judgments, typing
      rules, well-typedness, preservation, and progress.}

\intodo{Discuss how we can add type information to Drasils expression languages,
      and the pros/cons of the solutions. For example, should type enforcement
      done at the construction-level or post-facto processed?}

\intodo{Discuss the properties of a good solution.}

\intodo{Re-write the typing rules without the Haskell code references (keep it
      mathematical/theoretical).}

\intodo{Re-write the typing rules with the Haskell code style.}

\intodo{Discuss our proposed and performed solution.}

\begin{enumerate}

      \item Ok, so we have these expression languages. They're great!

      \item However, they admit invalid expressions.

      \item Invalid expressions are bad because:

            \begin{enumerate}

                  \item they can't be properly dissected, for us to learn from
                        them.

                  \item they will cause problems later, in the artifacts we
                        generate.

                  \item they make no real discernible ``sense.'' They might make
                        sense to anyone in particular, but, broadly, they will
                        be gibberish, because they do not obey a globally agreed
                        upon rule set.

                  \item at the moment, to ensure that our generated artifacts
                        are directly usable in compilation and usage, we need to
                        manually ensure that they ``type-check.'' However,
                        Drasil has no clear understanding of what ``type-check''
                        means! For a few expressions, this manual methodology
                        might be ``okay,'' but it surely does not scale well
                        when add expression generation, nor human error through
                        scale in expression creation/usage.

            \end{enumerate}

      \item Ok, so what information are we missing? What do we need to ``teach''
            Drasil about in order for us to ensure that all of our expressions
            are well-formed (whatever that might mean)?

            \begin{enumerate}

                  \item First, we need to discuss: what does ``well-formedness''
                        mean?

                  \item What are ``typing rules?'', and how can we create a set
                        of typing rules?

                  \item What are our needed typing judgments?

            \end{enumerate}

      \item Now that we know what is needed of the expression language, how do
            we want to implement it in Drasil?

\end{enumerate}

\section{Background: Problem}

\begin{itemize}

      \item Writing invalid expressions is possible.
            \begin{itemize}

                  \item On paper, writing invalid expressions is as easy as
                        making a typo, but complete gibberish can also be
                        written. We rely on manually checking expressions to
                        ensure that they are ``correct''. As the number of
                        expressions grows, the cost of manually checking grows
                        rapidly, and changes result in costly setbacks. Imagine
                        systems with 10, 100, and 1000+ expressions, the cost
                        grows rapidly.

                  \item With computers, we can systematically check the validity
                        of expressions by imposing various kinds of
                        restrictions.

            \end{itemize}

      \item Mentally tracking expression creations to ensure they follow the
            implicit rules of the expression language is too difficult, and
            leads to mental strain.

      \item Compiling to ``lower languages'' requires special type checking
            before compiling to them. For example, the Swift code generator has
            to ensure that there are no ambiguously typed numerals as the types
            of numerics are not overloaded in Swift.

      \item Dynamically checking for invalid expression states is possible, but
            difficult and would result in increasingly difficult term tracking
            as terms in the expression language grow/are added.

      \item In general, being able to express invalid expressions causes large
            burden and mental overhead.

\end{itemize}


\section{Requirements \& properties of a good solution}

\begin{itemize}

      \item Invalid expressions should not be representable in the various
            expression languages (i.e., the expression types should strictly
            indicate valid expression constructions), without loss of
            generality.

      \item Invalid expression formation attempts should be statically found and
            reported by the compiler, at compile-time. This will move the
            previously runtime errors to compile-time.

      \item Invalid expression cases should not need to be considered when
            working (e.g., case-ing) with expressions.

      \item ``Safety = Preservation + Progress'' (\cite{Harper2016}, Ch.6)

\end{itemize}

\section{Solution}

\begin{itemize}

      \item Use TTF encodings of the smart constructors to lessen the cognitive
            load of handling at least 3 different expression languages.

      \item Statically type all 3 variants of Expr through GADTs.

\end{itemize}

\subsection{Syntax}

\subsubsection{Current}

\input{chapters/typing/syntax/current.tex}

\subsection{Typing Rules}

\subsubsection{Literal}

\input{chapters/typing/rules/literal}

\subsubsection{Miscellaneous}

\input{chapters/typing/rules/misc}

\subsubsection{Expr}

\input{chapters/typing/rules/expr}

\subsubsection{ModelExpr}

\input{chapters/typing/rules/modelexpr}

\subsubsection{CodeExpr}

\input{chapters/typing/rules/codeexpr}
