\intodo{Rewrite the point form notes in the Typing section.}

\section{Background: Problem}

\begin{itemize}

      \item Writing invalid expressions is possible.
            \begin{itemize}

                  \item On paper, writing invalid expressions is as easy as
                        making a typo, but complete gibberish can also be
                        written. We rely on manually checking expressions to
                        ensure that they are ``correct''. As the number of
                        expressions grows, the cost of manually checking grows
                        rapidly, and changes result in costly setbacks. Imagine
                        systems with 10, 100, and 1000+ expressions, the cost
                        grows rapidly.

                  \item With computers, we can systematically check the validity
                        of expressions by imposing various kinds of
                        restrictions.

            \end{itemize}

      \item Mentally tracking expression creations to ensure they follow the
            implicit rules of the expression language is too difficult, and
            leads to mental strain.

      \item Compiling to ``lower languages'' requires special type checking
            before compiling to them. For example, the Swift code generator has
            to ensure that there are no ambiguously typed numerals as the types
            of numerics are not overloaded in Swift.

      \item Dynamically checking for invalid expression states is possible, but
            difficult and would result in increasingly difficult term tracking
            as terms in the expression language grow/are added.

      \item In general, being able to express invalid expressions causes large
            burden and mental overhead.

\end{itemize}


\section{Requirements \& properties of a good solution}

\begin{itemize}

      \item Invalid expressions should not be representable in the various
            expression languages (i.e., the expression types should strictly
            indicate valid expression constructions), without loss of
            generality.

      \item Invalid expression formation attempts should be statically found and
            reported by the compiler, at compile-time. This will move the
            previously runtime errors to compile-time.

      \item Invalid expression cases should not need to be considered when
            working (e.g., case-ing) with expressions.

      \item ``Safety = Preservation + Progress'' (\cite{Harper2016}, Ch.6)

\end{itemize}

\section{Solution}

\begin{itemize}

      \item Use TTF encodings of the smart constructors to lessen the cognitive
            load of handling at least 3 different expression languages.

      \item Statically type all 3 variants of Expr through GADTs.

\end{itemize}

\subsection{Syntax}

\subsubsection{Current}

\input{chapters/typing/syntax/current.tex}

\subsection{Typing Rules}

\subsubsection{Literal}

\input{chapters/typing/rules/literal}

\subsubsection{Miscellaneous}

\input{chapters/typing/rules/misc}

\subsubsection{Expr}

\input{chapters/typing/rules/expr}

\subsubsection{ModelExpr}

\input{chapters/typing/rules/modelexpr}

\subsubsection{CodeExpr}

\input{chapters/typing/rules/codeexpr}

\intodo{Continued problems? Expressions don't expose enough information to be used in softifact generation}
