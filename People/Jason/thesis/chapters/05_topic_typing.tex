\chapter{Typing the Expression Language}
\label{chap:typedExpr}

Mathematical expressions are one of the most prominent components of any
abstracted concept from scientific software artifacts. With a pencil and paper,
our mistakes might go unnoticed, because they are never ``hard'' validated by
any machine, but ``soft'' validated by us and other readers. In other words,
there is no clear \textit{validity assertion} when we traditionally write
expressions on paper. While \Cref{chap:modelkinds} focused on understanding how
mathematical expressions could be dissected and transformed into ``code,'' it
neglected to discuss which expressions it could even begin to dissect and
transform \textemdash{} that is to say, which expressions are ``valid?'' The
objective of this chapter is to create a system of type rules, and enforce
well-formedness/typedness\footnote{Please note that I will be using
      ``well-formed'' and ``well-typed'' interchangeably.} through them, for Drasils
mathematical expression languages.

\section{Recap of Drasils Math-related Expression Languages}

To recap, at this point, we have three (3) relevant and used ``mathematical
expression'' languages.

\subsection{One for \textquotedblleft{}Simple\textquotedblright{} Mathematics}

\Expr{} is a mathematical expression languages whose vocabulary is intended to
always have a definite value. In other words, with little to no extra work on
your end, you should be able to directly input these expressions in your
standard calculator (perhaps with a bit of work to handle vectors, functions,
etc.) to evaluate them.

\subsection{One For \textquotedblleft{}Code\textquotedblright{}}

\CodeExpr{} is a heavily mathematics-focused expression language with a few
extra features over \Expr{} for \acs{gool}/``code.'' The vocabulary should be
nearly directly usable in \acs{gool} for outputting to general-purpose
object-oriented programming languages. \CodeExpr{} is a superset of \Expr{}:
\(\Expr{} \subseteq{} \CodeExpr{}\).

\subsection{And One For General Mathematics}

\ModelExpr{} is the classical mathematics we know and love. It contains nearly
everything we know (up to what we've encoded thus far) and is intended to be a
descriptive language, with no particular restrictions on its terms (other than
that they should at least be describable on pencil and paper too). \ModelExpr{}
is also a superset of \Expr{}: \(\Expr{} \subseteq{} \ModelExpr{}\).

However, \ModelExpr{}s terms are unlikely to appear in \CodeExpr{} due to their
indescribable nature in computable \acs{oo} ``code.''

As of right now, these languages have proven themselves to be effective
encodings, weakly proven through Drasils case studies being able to produce
working software artifacts. However, they are not without issue. Notably, at the
moment, Drasil does not have any readily-available type information about their
constructions. This lack of type information hampers the ``reliability'' aspect
of the code generator because the generator is unable to restrict its output
artifacts to those which are directly usable. In order for the generated
artifacts to be directly usable, they must be \textit{well-typed} programs. In
other words, we need to make sure that the generated expressions and programs
conform to the \textit{type rules} of the respective interpreters and/or
compilers.

\section{Type Safety}

Before compilation/execution, programming language compilers and interpreters
check input programs against a logical \textit{type system} to ensure that the
steps never perform invalid instructions, where program evaluation may become
impossible\footnote{Some instructions/operations may be ``nonsense!''}. For
example, to avoid nonsensical instructions, such as \(1 + \texttt{true}\), where
parameter \textit{type} mismatches occur. In this example, a computer (like us)
have no reasonable way to understand how to add \(1\) and the truth value
\texttt{true}. Type systems provide \textit{types} (such as
\(\mathbb{Z}\)/\texttt{integer} and \(\mathbb{B}\)/\texttt{boolean}) that are
assigned to each \textit{term} (such as \(1\), \(+\), and \texttt{true}), and a
set of \textit{typing rules} to restrict how terms interact and form. Types are
information about the structure of terms. \textit{Types} are typically
meta-level information. Terms are the value/``primitive'' data of a programming
language, such as numerics, functions/methods, operators, and modules. A series
of \textit{inference rules} makes up the type rules of a system. Here,
\textit{type safety} is approximately an assurance of \textit{preservation} and
\textit{progress} formed through the typing rules \cite{Harper2016}.

\intodo{Discuss ``preservation'' and ``progress,'' and how, together, they make
      up ``safety'' as discussed in \cite{Harper2016}. Also discuss what it
      means for things to be well-typed.}

\intodo{Invalid expressions are also ``bad'' because they make handling of
      expressions more cumbersome, we can't guarantee analysis makes sense. They
      break ``preservation'' and ``progress'' in the generated artifacts, they
      make no real discernible ``sense.'' They might make sense to anyone in
      particular, but, broadly, they will be gibberish, because they do not obey
      a globally agreed upon rule set. To avoid issues with ``preservation'' and
      ``progress,'' we manually ensure that generated artifacts by writing the
      source input in precise ways that we only happen to be generating the
      working artifacts. However, this does not scale well.}

\subsection{A Simple Language}

For example, if we had a small ``simple'' language, \(\bb{L}\), that contains
terms for integer and boolean values, and addition, ``less than'' comparison,
conjunction, and if-then-else (ternary operators)\footnote{Assume the
      definitions of the functions be total and understood/used under the conventional
      sense that mathematicians so often do.}, we might write the syntax inductively,
as follows:

\begin{longtable}{ r c c l}
      \(\bb{L}(l)\) & ::=       & \(n\)                                                        & Integers (where \(n\) is any integer) \\
                    & \(\vert\) & \texttt{true}                                                & True                                  \\
                    & \(\vert\) & \texttt{false}                                               & False                                 \\
                    & \(\vert\) & \(l_1\ \texttt{+}\ l_2\)                                     & Addition                              \\
                    & \(\vert\) & \(l_1\ \texttt{<}\ l_2\)                                     & ``Less than'' comparison              \\
                    & \(\vert\) & \(l_1\ \texttt{\land}\ l_2\)                                 & Conjunction                           \\
                    & \(\vert\) & \(\texttt{if}\ l_1\ \texttt{then}\ l_2\ \texttt{else}\ l_3\) & if-then-else (ternary ``if'')         \\
\end{longtable}

Great! Now, we can form expressions, such as:

\begin{equation}
      10
      \label{ex:sl:s:good1}
\end{equation}

\begin{equation}
      23 + (400\ \texttt{+}\ 4000)
      \label{ex:sl:s:good2}
\end{equation}

\begin{equation}
      \texttt{if}\ \texttt{true}\ \texttt{then}\ 95\ \texttt{else}\ 96
      \label{ex:sl:s:good3}
\end{equation}

\begin{equation}
      42\ \texttt{+}\ \texttt{false}
      \label{ex:sl:s:bad1}
\end{equation}

\begin{equation}
      22 + \texttt{if}\ (40\ \texttt{+}\ 400)\ <\ 96\ \texttt{then}\ \texttt{false}\ \texttt{else}\ 96\ \texttt{+}\ 400
      \label{ex:sl:s:bad2}
\end{equation}

\begin{equation}
      \texttt{if}\ 0\ \texttt{then}\ 1\ \texttt{else}\ \texttt{true}
      \label{ex:sl:s:bad3}
\end{equation}

% Forcibly rename the "equation" environment tags to "expression" for the sake
% of the below discussion.
\Crefname{equation}{Expression}{Expressions}

Now, let's evaluate these expressions.
\Cref{ex:sl:s:good1,ex:sl:s:good2,ex:sl:s:good3} can be calculated with a
conventional understanding of the operations, respectively, as \(10\), \(4423\),
and \(95\). However, \Cref{ex:sl:s:bad1,ex:sl:s:bad2,ex:sl:s:bad3} are
worrisome. Regarding, \Cref{ex:sl:s:bad1}, we just don't have any conventional
sense of addition on integers with booleans, so evaluation is unclear.
Continuing, to calculate the outermost addition expression of
\Cref{ex:sl:s:bad2}, we must first calculate the if-then-else condition would
evaluate to \texttt{true}, so we can short-circuit to the left expression
(\texttt{false}), but now we have no conventional sense of addition on integers
with booleans. So, we have an undefined expression, similar to
\Cref{ex:sl:s:bad1}. Finally, unless we were familiar with C-like languages, we
might not want to think of \(0\) as being equivalent to \texttt{false}, so we
immediately find issue in the condition of \Cref{ex:sl:s:bad3}. However,
ignoring the issue with the condition value, we might also find issue, similar
to \Cref{ex:sl:s:bad2}, with how different \textit{kinds} of values in the
branch operands.

\Crefname{equation}{Equation}{Equations}

Other than modifying the syntax into a convoluted mess to avoid issues like
these (which won't be easy, and might not be possible), we look to \textit{type
      systems} to rescue the \(\bb{L}\). The key is in understanding that there are
different ``kinds'' (\textit{types}) of values (\textit{terms}). Then, we can
either filter out the invalid expressions. First, we must analyze and capture
our universe of types, \(\tau\):

\begin{longtable}{ r c c l}
      \(\Tau(\tau)\) & ::=       & \(\bb{B}\) & Booleans \\
                     & \(\vert\) & \(\bb{Z}\) & Integers
\end{longtable}

Note that we are restricting the numeric-related operations to strictly
integers. The restriction is only there for simplification of numerics. \(\tau\)
is an enumeration of all permissible \textit{types} of \textit{terms} we can
have in \(\bb{L}\).

Next, we need to add the typing rules. They will restrict our syntax to only
those constructions which are semantically valid. We will do so using inference
judgments, as follows:

\begin{equation}
      \left.
      \infer{n : \bb{Z}}{}
      \right.
      \qquad
      \text{(where \(n\) is any integer.)}
      \label{eq:exTR:int}
\end{equation}

\begin{equation}
      \left.
      \infer{\texttt{true} : \bb{B}}{}
      \right.
      \qquad
      \text{True}
      \label{eq:exTR:true}
\end{equation}

\begin{equation}
      \left.
      \infer{\texttt{false} : \bb{B}}{}
      \right.
      \qquad
      \text{False}
      \label{eq:exTR:false}
\end{equation}

\begin{equation}
      \left.
      \infer{(a\ \texttt{+}\ b) : \bb{Z}}
      {a : \bb{Z}  &  b : \bb{Z}}
      \right.
      \qquad
      \text{Addition}
      \label{eq:exTR:addition}
\end{equation}

\begin{equation}
      \left.
      \infer{(a\ \texttt{<}\ b) : \bb{B}}
      {a : \bb{Z}  &  b : \bb{Z}}
      \right.
      \qquad
      \text{``Less than'' comparison}
      \label{eq:exTR:lessThan}
\end{equation}

\begin{equation}
      \left.
      \infer{(a\ \texttt{\wedge}\ b) : \bb{B}}
      {a : \bb{B}  &  b : \bb{B}}
      \right.
      \qquad
      \text{Conjunction}
      \label{eq:exTR:conjunction}
\end{equation}

\begin{equation}
      \left.
      \infer{(\texttt{if}\ b\ \texttt{then}\ x\ \texttt{else}\ y) : \tau}
      {b : \bb{B}  &  x : \tau  &  y : \tau}
      \right.
      \qquad
      \text{if-then-else (ternary ``if'')}
      \label{eq:exTR:ifThenElse}
\end{equation}

So as long as we follow these typing rules while we build our expressions, when
we try to evaluate any of these expressions, we should not arrive at invalid
expressions where evaluation cannot be completed.

Notably, on paper and pencil, or common typesetting, there is nothing tangibly
stopping us from continuing to write invalid expressions. However, with
computerized languages, we're able to tangibly (as far as ``tangible'' goes with
computers) stop users from writing invalid expressions. This is a huge gain over
conventional pencil and paper, because we're able to type check statements with
far less time and effort than if we were to do it manually.

\section{Back to Our Expression Languages}

Similar to the untyped \(\bb{L}\), in Drasil, our expression languages (\Expr{},
\CodeExpr{}, and \ModelExpr{}) are \textit{untyped}\footnote{i.e., they don't
      have type information, and are not type checked.}. We currently need to manually
ensure that our generated artifacts \textit{type check}. If we only had a few
expressions, then it would not be much of an issue to manually type check them.
However, with scale, it becomes problematic. In particular, just throwing
``generation'' into the mix makes it an area of concern, because there is no
assurance of type safety. In this chapter, we aim to bring type information to
the expression languages, and see how we can improve type safety and expression
usage.

\subsection{Decomposing the Expression Languages}

Before we begin to decompose the expression languages into their semantics,
syntax, and typing rules, we will start off with a common denominator language
to all the three (3): \Literal{}. The \Literal{} language is a simple
non-recursive sum type, where each possible value is a different kind of
``literal'' value\footnote{Note that this work is basing it's understanding on
      the existing syntax and usage, and does not intend to argue the existence of
      certain operations or kinds of values necessarily.}. The syntax is as follows:

\begin{longtable}{ r c c l}
      \(\mathit{Literal}(l)\) & ::=       & \(n\)     & Integers (where \(n \in \bb{Z}\))                \\
                              & \(\vert\) & \(s\)     & Strings (where \(s\) is any string of text)      \\
                              & \(\vert\) & \(r\)     & Real numbers (where \(r \in \bb{R}\)             \\
                              & \(\vert\) & \(r_w\)   & Whole-numbered reals (where \(r_w \in \bb{R}\))  \\
                              & \(\vert\) & \(n / d\) & Fractions/percentages (where \(n,d \in \bb{Z}\)) \\
\end{longtable}

The types are as follows:

\begin{longtable}{ r c c l}
      \(\Tau_{\mathit{Literal}}(\tau)\) & ::=       & \(\bb{R}\) & Reals    \\
                                        & \(\vert\) & \(\bb{Z}\) & Integers \\
                                        & \(\vert\) & \(\bb{S}\) & Strings
      \footnote{For sake of brevity, we will think of \(\bb{S}\) as the type of
            all possible strings of text.}
\end{longtable}

Thankfully, the typing rules are fairly straight forward:

\intodo{Typing rules for \Literal{}.}

\imptodo{Continue writing here!}

\intodo{Draw out the syntax diagram of each language, but start with Expr and
      discuss how CodeExpr and ModelExpr are extensions of Expr.}

\intodo{Re-write the typing rules without the Haskell code references (keep it
      mathematical/theoretical).}

\intodo{Discuss how and where we can add type information to Drasils expression
      languages, and the pros/cons of the solutions. For example, should type
      enforcement done at the construction-level or post-facto processed?}

In Haskell, there are at least two ways that we can perform these type rules: at
creation, and after creation. If we choose to restrict at the construction, we
have a stronger sense of type safety for any and all expressions, unlike with
post-creation manual checking of expressions, where you can't necessarily share
proofs that an expression ``well-typed''\footnote{At least not in Haskell, but
      perhaps in Agda!}.

\begin{itemize}

      \item Compiling to ``lower languages'' requires special type checking
            before compiling to them. For example, the Swift code generator has
            to ensure that there are no ambiguously typed numerals as the types
            of numerics are not overloaded in Swift.

      \item Dynamically checking for invalid expression states is possible, but
            difficult and would result in increasingly difficult term tracking
            as terms in the expression language grow/are added.

      \item In general, being able to express invalid expressions causes large
            burden and mental overhead.

\end{itemize}


\section{Requirements \& properties of a good solution}

\begin{itemize}

      \item Invalid expressions should not be representable in the various
            expression languages (i.e., the expression types should strictly
            indicate valid expression constructions), without loss of
            generality.

      \item Invalid expression formation attempts should be statically found and
            reported by the compiler, at compile-time. This will move the
            previously runtime errors to compile-time.

      \item Invalid expression cases should not need to be considered when
            working (e.g., case-ing) with expressions.

      \item ``Safety = Preservation + Progress'' (\cite{Harper2016}, Ch.6)

\end{itemize}

\section{Solution}

\begin{itemize}

      \item Use TTF encodings of the smart constructors to lessen the cognitive
            load of handling at least 3 different expression languages.

      \item Statically type all 3 variants of Expr through GADTs.

\end{itemize}

\subsection{Syntax}

\subsubsection{Current}

\input{chapters/typing/syntax/current.tex}

\subsection{Typing Rules}

\subsubsection{Literal}

\input{chapters/typing/rules/literal}

\subsubsection{Miscellaneous}

\input{chapters/typing/rules/misc}

\subsubsection{Expr}

\input{chapters/typing/rules/expr}
