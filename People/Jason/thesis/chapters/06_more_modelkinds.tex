\chapter{More Theory Kinds}
\label{chap:more-theory-kinds}

\imptodo{Continue writing here!}









\section{\textquotedblleft{}Classify All The Theories\textquotedblright{}}

In other words, we replace \Expr{} as a knowledge container, and restrict its
usage to strictly ``mathematical expressions'', as opposed to ``expressions''
and information about models/theories.

One notable change is that we will require the new theory knowledge containers
to be able to fully re-create the original shallow/raw \Expr{}s as a property of
the new theory encodings.

Ultimately, this is done through replacing \RelationConcept{} usage with
\ModelKind{}\footnote{\ModelKind{} is built upon Dr. Jacques Carettes prototype
    of an earlier version of \ModelKinds{}}, an aggregation of existing
Drasil-related knowledge of mathematical theories. \ModelKind{} is defined using
a \acs{gadt}, with one (1) type parameter. The type parameter is currently used
to determine whether the model is ``fully refined''/``grounded'' or not, and,
hence, usable in code generation.

\refCurrentModelKindsHaskell{} displays the creation of \ModelKind{} and
\ModelKinds{}.

Please note that this aggregation is based purely on the existing model examples
in the existing Drasil case studies, and the existing models are incomplete in
the larger scope.

Each \textit{kind of model} we find only has one requirement: that it should
carry enough information to, and provide a means of, recreating the original
expression from which they were abstracted out of.

This requirement is essentially that of ``viewing'' it in the expression
language, but it also tends to also add flexibility in how many ways that we can
``view'' the information in different forms.

In the Haskell code, this requirement is enforced through requiring them all to
instantiate the \Express{} typeclass (\refCurrentExpressHaskell{}).

\currentModelKindsHaskell{}

In the above \ModelKinds{} definition, there are two (2) TODO notes that you may
disregard.

The first one is merely a note for analyzing ``well-understood'' copies of our
existing \acsp{ode}, and the second one refers to models that haven't yet been
fully analyzed for how they will be used (other than for display).

\subsection{Quantity Definitions}

\currentQDefinitionHaskell{}

Assume \(y = x\) is transcribed as a \RelationConcept{}: while \(y = x\) might
conventionally be seen as ``y is equal to x'', we might want, in our model, for
it to be understood as ``x is defined by y'' but displayed differently.

Here, \(=\) is overloaded as ``definition'', instead of what \(=\) was defined
as in \Expr{}, as an ``equality'' operator.

To resolve this overloading and weak knowledge capture of definitions, we create
\EquationalModel{}s: theories that contain information about definitions of
symbols, built using a \QDefinition{} (\refCurrentQDefinitionHaskell{}).

If an \EquationalModel{} deals with theoretical symbols and is defined using
either a \ModelExpr{} or an \Expr{}, it may be used in Theory Models and General
Definitions.

If an \EquationalModel{} is defined using an \Expr{} and deals with only the
concrete (non-abstract) symbols, then the \EquationalModel{} is usable for code
generation.

At the moment, there is no information attached to symbols yet regarding whether
they are abstract or instanced, so that portion of the rule is not enforced.

\eztodo{Example of an EquationalModel/QDefinition in Haskell code, the SRS, and
    the generated code.}

\subsection{Constraints}

\currentConstraintSetHaskell{}

Theories that define expressions that constrain models in some way are defined
using \EquationalConstraints{}, which use \ConstraintSet{}s under the hood
(\refCurrentConstraintSetHaskell{})\todo{Describe what a ConstraintSet actually
	is.}.
	
At the moment, these are not used in code generation, and are pending design for
usage in code generation as the translation from them into software is unclear
and may be interpreted differently by readers.

This model can, and should, eventually also be usable in code generation once
there is interest in creating runtime assertions of symbols.

\eztodo{Example of an EquationalConstraints/ConstraintSet in Haskell code, and
	the SRS.}

\subsection{Definition Realms}

\currentDefiningExprHaskell{}

\currentMultiDefnHaskell{}

The Theory Models and General Definition Models are unrefined, and may contain
multiple ways for a particular theoretical symbol to be defined. This is
captured in Drasil by \EquationalRealm{}s: modelled after realms\qtodo{Cite Dr.
Carette and Yasmines paper?}.

This model kind is intended specifically for retaining information about
conscious choices made along the way to create Instance Models.

An \EquationalRealm{} is based on a \MultiDefn{}
(\refCurrentMultiDefnHaskell{}), and is intended for forming \QDefinition{}s
through choosing definitions (encoded as \DefiningExpr{}s,
\refCurrentDefiningExprHaskell{}), through refinements, from the \MultiDefn{}s.

\eztodo{Example of an EquationalRealm/MultiDefn in Haskell code, and the SRS.}

\subsection{Differential Equations}

\DEModel{} is the simple \RelationConcept{}-style capture of differential
equation-related theories, and only exists as a placeholder until all
differential equation models are converted into one of the other \ModelKinds{}.

For related solving of differential equations, \DEModel{} implicitly relies on a
developer writing a related \ODEInfo{}\todo{ref Current ODEInfo} packet which
the code generator can use to solve the system.

Actively being reconstructed in Drasil \cite{Chen2022MEng} \footnote{Shortly
after I implemented \ModelKind{}, Dong continued working on exploring
\DEModel{}s and created \NewDEModel{} as a result.}, \NewDEModel{} is the
replacement for \DEModel{}, aiming to expose more information about
well-understood differential equations and related areas.

\NewDEModel{} will eventually be renamed to \DEModel{} once all existing
\DEModel{} models have been upgraded.

\intodo{Example of a DEModel/NewDEModel and a RelationConcept in Haskell code,
	the SRS, and the related ODEInfo and code.}

\subsection{Leftovers}

\imptodo{Leftover model kinds.}

\section{Theories Undiscussed}

\ModelKinds{} is an enumeration of the currently handled model types.

Each ``model'' is meant to expose information to the Haskell compiler and for
other fragments of knowledge to make use of.

\ModelKinds{} is obviously an incomplete enumeration, and will grow as the need
for more kinds of models arises.













\section{Success}
\label{chap:more-theory-kinds:sec:success}

\ModelKind{} already has some success in enabling more theories to be encoded in
Drasil and used for code generation.

Dong Chens Master's involved exploring \acsp{ode} in Drasil and using them to
generate code that solves them \cite{Chen2022MEng}.

Through his work, we have already observed some success because more case
studies are already capable of generating code (see
\refCaseStudiesCodeTableAfterDongsWork{}).

Namely, \acs{dblpendulum} has working code generation for 4 languages (Python,
Java, C/C\(++\), and C\#), and \acs{pdcontroller} now also supports Java,
C/C\(++\), and C\# in addition to Python.

\caseStudiesCodeTableAfterDongsWork{}

