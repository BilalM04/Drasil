% ModelKinds -- Theory types / discrimination -- ``Expressions in context''

\chapter{Framing Theories}
\label{chap:modelkinds}

In working to understand some phenomenon, we often look to the boundaries of our
understandings of the phenomenon \textemdash{} the open-ended questions and gaps in our
knowledge. In any domain of knowledge (such as mathematics, philosophy, physics,
chemistry, biology, computer science, or any other studied subject), we often
think about various phenomenon in logical terms of theories and axioms, where
the theories and axioms are written using a formal \acs{dsl} tailored to the
field of knowledge. As this work pertains to Drasil, one language of interest to
this research is that of the mathematical language. A mathematical language is
heavily used in science, conveying important theories, axioms, corollaries,
amongst other things. As mathematicians transferring knowledge to one another,
we often use a written form of knowledge, though unlikely, potentially, with a
precise structure to our transcription of the knowledge, but still, the
structure is textual. We might break up the transcription of the knowledge into
its logical constituents. The components of a theory may be a name, a natural
language description, a derivation, some information regarding its origin (e.g.,
a reference), and a formalization of the theories important information in a
precise language. Of course, for a mathematical theory, a mathematical language
would be used. Describing a programming language artifact, we might prefer to
call our theories by a series of other names (e.g., functions/methods,
constants, modules, packages, libraries, \acsp{api}, \acsp{ast}).

In Drasil, both of these languages are of great importance. The mathematical
field of knowledge is directly used in at least two domains currently captured:
the scientific theories, and \acs{gool} \cite{Carette2019}. Meanwhile, the
programming language theory (artifacts) is only directly used in \acs{gool}, and
its various renderers. The Smith et al. \acs{srs} \cite{SmithAndLai2005}
template generator uses knowledge transcribed as scientific requirements to
automatically generate a series of representational software programs.
Thankfully, Smith and Lai \cite{SmithAndLai2005} break down theories relevant to
\acs{scs} into at least four (4) kinds for their \acs{srs} template:

\begin{enumerate}

	\item \textbf{Theory Models}: A ``theory presentation'' \qtodo{How should I
		      cite ``Theory Presentations?''}: an abstract theory, highly
	      general and unspecific, with room for refinement. Typically, these
	      are names coupled with information contained as axioms and data
	      that make up a coherent story, but that are too vague to be
	      immediately usable by the developers other than for refining into
	      Instance Models.

	\item \textbf{General Definitions}: A partially refined\footnote{Similar to
	      a theory model, but made less abstract in some way.} theory,
	      typically bearing a stronger relation to the context of the \acs{srs}
	      than the Theory Models. However, still, these are generally
	      theoretical and abstract, much like Theory Models.

	\item \textbf{Instance Models}: A fully refined theory, derived from the
	      Theory Models and General Definitions, and directly usable by
	      implementors of the \acs{srs}.

	\item \textbf{Data Definitions}: Symbols that are defined with basic
	      expressions of other symbols and inputs. Typically, these are
	      definitions that are ``given'', and used for making inputs easier to
	      work with for the instance models.

\end{enumerate}

\eztodo{Example of a theory/instance model here.}

The Instance Models and Data Definitions are to be directly used in the solving
algorithm for the whole system, while the General Definitions and Theory Models
provide justification for the existence of the Instance Models, and the Data
Definitions are provided and relatively unimportant/uncritical to the system.

Since the Smith et al. generator focuses itself on knowledge captured in the
form of the \acs{srs} template, Drasil requires a comprehensive understanding of
both fields in order to generate representational software for the \acs{srs}.
The focus of the scientific requirements documents are to transcribe the
relevant knowledge of a \acs{scs} system for end-user developers to satisfy when
developing \acs{scs}, and as developed by a domain/scientific expert. For
example, the \porthref{\acs{glassbr}
\acs{srs}}{https://jacquescarette.github.io/Drasil/examples/glassbr/SRS/srs/GlassBR_SRS.html}
is used to explain a scientific experiment, where a blast stresses glasses, such
that a software developer can construct a program based on it. Of course, if the
\acs{srs} document is to be truly sufficient for a software developer to
unambiguously create a representational software artifact, then the software
developer (who potentially knows nothing about the domain discussed in the
\acs{srs} document) will need to be able to credibly transcribe everything into
their program, matching the requirements as set by the \acs{srs} document.
Drasil is an apparatus for testing our understanding of these scenarios, rather
than having a read-only ``view'' of the scientists/domain experts knowledge
available to the software developer, the knowledge itself is available, in its
most raw encoded form.

Drasil relies on searching for a calculation path that relates the inputs and
outputs designated in an \acs{srs} document. The relations are based on the
grounded theories (\textit{Instance Models}) designated in the \acs{srs}. The
relations themselves are currently required to be of the form \(x = f(a, b, c,
\ldots{})\), with some exceptions made for \acsp{ode}. \acsp{ode} are being
actively developed to remove the manually written exceptions made for them
(outside the scope of this work).

Instance Models, General Definitions, and Data Definitions each rely on a
\textit{Relation Concept} (\RelationConcept{}): a notable and named mathematical
relation with a description and abbreviated name. A \RelationConcept{} is
modelled as a \Relation{} coupled with a \ConceptChunk{}
(\refOriginalConceptChunkHaskell{}, a named \textit{thing} with a name,
abbreviation, and natural language description):

\originalRelationConcept{}

The \Relation{}s (\refOriginalRelation{}) in the \RelationConcept{} are,
fundamentally, just an instance of a universal mathematical language which
conveys their information, but given a type synonym to indicate that the
instance should be a mathematical relation.

\section{A Universal Math Language}
\label{sec:modelkinds:language}

\originalExprHaskell

\Expr{} (defined above, in \refOriginalExprHaskell{} with an \ACF{adt})
represents the hypothetical mathematical language used to discuss the
mathematics relevant to common \acs{scs}, specifically, at least to
under/graduate-level physics problems. The language contains the commonly found
operations in a well-understood physics textbook (here, with a focus on
graduate-level scientific problems). The mathematical language is universal,
covering a wide range of knowledge, including facilities for creating commonly
used primitive data types, operations, and functions  in mathematics, physics,
and computer science and programming languages. For example, one might
transcribe \(3 e^{x + 2} = y\) in Drasil as:

\pseudoExampleExpression{}

This transcription relies on smart constructors, such as those in
\refOriginalFewExprSmartConstructorsHaskell{}. The smart constructors used are
all specialized to \Expr{} and perform simplifications along the way (such as
folding \(1 \cdot x\) into \(x\)).

\section{A Universal Theory Description Language}

The \acs{srs} document organizes theoretical information of different kinds in
various ways: instance models (\InstanceModel{}), general definitions
(\GenDefn{}), and theoretical models (\TheoryModel{}). However, each way relies
on flat \Relation{}s, either directly or through \RelationConcept{}s. The
theories are ``shallow'', or ``flat,'' representations of the theoretical
information because they do not directly provide information about the structure
of the information they carry. When transmitting information on pencil and paper
to your colleagues, this is fine, because they will likely read extra contextual
information from it, and know how to use it accordingly. However, our machines
aren't able to infer as well as we're able to. Our machines are clueless to the
contextual information about the theories because we have provided no means of
discussion to them. In other words, Drasil does not yet understand the language
of the associated context. This work aims to fix this issue.

\section{Theories to Specifications and Software}

Drasil relies on converting the various kinds of theories described in the
\acs{srs} template \cite{SmithAndLai2005}, essentially encoded in Drasil as
\RelationConcept{}s, into representational code.

\tedioustodo{Example of an IMs conversion into Java code.}

Unfortunately, issues occur when attempting to convert the knowledge contained
in \RelationConcept{}s. Namely, we have two (2) main issues with it: the
transformation is not \textit{total} (and we don't have structural information
about when it is defined versus when it's not), and transformation requires
complex analysis of expressions (as such, we're currently limited to relying on
implicit information).

\subsection{It's Not Total}

As the \acs{srs} is purely for \textit{display}, any \Expr{} expression can be
converted to something for display. However, the transformation of
\(\RelationConcept{} \rightarrow \acs{gool}\) (in particular, the \(\Expr{}
\rightarrow \acs{gool}\) component) is not \textit{total} (i.e., not all
possible expressions of the \Expr{} language can be converted into a
representational \acs{gool} expression), and we have no information about
\textit{when} they do. As \acs{gool} is \Expr{}s primary ``code'' target,
through which we compile to other \acs{oo} languages, we're only able to
directly translate terms from \Expr{} into \acs{gool} that have definite values.
The terms in \Expr{} that require extra information before they can be converted
into code also cannot be directly converted, they need to be refined first. At
times, this refinement information is also a conscious choice that the developer
should be making instead of having a choice imposed on them by the code
generator.

\subsection{It Requires Complex Analysis}

\imptodo{This subsection is still very awkward, I need to re-write it.}

Assume we have a theory that describes the equation of a line. There are many
ways we can describe the equation: polynomial (\(a \cdot{} x + b \cdot{} y + c =
0\)), slope-intercept form (\(y = m \cdot{} x + b\)), point-slope form (\(y_1 -
y_2 = m(x_1 - x_2)\)), and so on. Although we fundamentally understand the
equation of a line, even we might find difficulty in recognizing the equation of
a line from any provided equation. However, when calculating our dependent
variable, we'll always need to end with a specific form: \(y = \ldots{}\).
Similarly, when calculating this in ``code,'' we'll need this form. However, if
we struggle to even recognize the form, we will similarly find difficulty in
converting it to the specifically required form. Thus, it requires complex
analysis of the expressions to even create such a \(\Expr{} \rightarrow
\acs{gool}\) mapping. \RelationConcept{} exhibits the same issues as our
hypothetical example \textemdash{} it requires brittle, complex analysis.

More generally, it is very easy to write ``difficult/impossible to interpret''
expressions. For example, it is possible to create expressions for which aren't
directly calculable (i.e., things that require an extra paper and pencil/mental
mathematics before performing), either without extra surrounding information or
simply impossible.

When writing with pencil and paper, we usually write with extra context
(generally more information that needs to be read to fully understand some
expression), assuming the reader understands that context. We might also infer
information about the model. Unfortunately, mechanizing inference, without any
sort of context or other knowledge, is difficult, artificial learning is a whole
field of study of its own, and we're not interested in it here! We must reverse
the relationship of the inference by having knowledge container expose
everything on its own.

An \Expr{} alone is a weak conveyor of the inner knowledge of theories, similar
to normal ``pencil and paper'' mathematical expressions, without extra
information, the expression alone may be ineffectual or nearly unusable in code
generation.

In general, it is important that each knowledge encoding in Drasil exposes as
much information as reasonably possible (and useful). We want to expose the
``specifications'' of each piece of knowledge that we are encoding so that
transformers and generators may appropriately make use of contained knowledge.

Previous to this work, Drasil was limited to using theories encoded with a
precise form, \(x = f(a, b, c, \ldots{})\), in code generation. Any other forms
of theories were unusable. This was known as the ``\relToQD{} hack.''

\originalRelToQDHaskell{}

\refOriginalRelToQDHaskell{} was a temporary solution to this symptom of
insufficient knowledge capture. \relToQD{} relied on implicit (and unguaranteed)
requirements of inputs. It had no static checks for consistency that an input
``theory'' was indeed usable in code generation.

For the \acsp{ode} that Drasil captured, it required manual intervention at the
time of code generation, with manually written packet of information about how
the \acs{ode} could be translated.

Together, because of the both issues, mathematical knowledge flow is unstable in
Drasil, as shown in \refTheoriesWithoutModelKinds{}. The focal issue with the
existing way theories are encoded is that the \textit{theories
	(\RelationConcept{}s) do not contain the structural information we need}. The
mathematical knowledge is implicitly held within the Haskell-based functions. In
order to proceed, this mathematical knowledge must be reconciled and merged with
the \RelationConcept{}s in some capacity.

\theoriesWithoutModelKinds{}

\section{Reconciling Mathematical Knowledge}

Fundamentally, the issues arise because the information is too ``shallow'' for
Drasil to adequately make use of them \textemdash{} it can't infer from
expressions. The raw expressions are great for viewing and human-guided
inference by experts, but not an inexperienced person, or for a computer to
systematically use to generate things. At the moment, the available tools' type
signatures would appear as something too amazing, so much so in fact, that one
would (and should) question its accuracy. A hypothetical type signature,
\inlineHs{RelationConcept -> Code}, is quite far fetched. Not all expressions
that can possibly be contained in a \RelationConcept{} are usable in
code\footnote{When we discuss ``code'' generation, we target generating usable
	software, but we currently primarily target general-purpose \acs{oo} programs.}
generation.

\section{Language Division}

\acs{gool} currently bears the burden of creating a family of software artifacts
through describing a single \acs{gool} program. As we are specifically
interested in generating families of \acs{scs} through strong knowledge capture,
this work partially bears the burden ensuring that the conversion of the
knowledge contained in the Smith et al. \acs{srs} template
\cite{SmithAndLai2005} to software is possible. At the moment, it is possible to
describe mathematical expressions that are completely unusable in \acs{gool}
because \acsp{gool} primary targets are languages that rely on expressions with,
at least, definite values. Of course, \Expr{} already contains terms that are
without definite values. For example, \Expr{} (\refOriginalExprHaskell{})
discusses derivations, integrations, spaces as primitive/literal values (largely
symbolic, and unavailable in \acs{oo} languages), definition statements, and
infinite series. Realistically, this information already \textit{exists} in
Drasil, but it is not strongly enforced at Drasils Haskell-level compile-time.
In other words, the information is not \textit{exposed} to Haskells type system,
but to Drasils runtime.

In order to ensure that developers can only write ``usable'' grounded theories
(``InstanceModels'') for the code generator to use, we have chosen to expose
this information to the compiler. Specifically, we have chosen to expose it via
language division and type information.

\languageDivision{}

\Expr{} has its indefinite values split off into \ModelExpr{}
(\refCurrentModelExprHaskell{})\todo{List notable terms moved, Deriv, Continuous
vs Discrete ranges, Space, etc}, a deeply embedded universal mathematical
language. As we desire for it to be equally usable as \Expr{}, it is,
essentially, the original \Expr{} without the language terms related to
``code.'' In order to alleviate the stress involved with writing out the same
expression in two (2) different languages, we use a \ACF{ttf} encoding of the
two (2) languages: \refCurrentExprTTFHaskell{} and
\refCurrentModelExprTTFHaskell{}. The \acs{ttf} encoding allows us to seamlessly
write expressions in either, or both, languages at the same time. \ModelExpr{}s
\acs{ttf} encoding strictly contains the terms unique to \ModelExpr{}. As such,
the \acs{ttf} encoding won't allow terms from \ModelExpr{} to be interpreted
into \Expr{} unless they have a definite value because it will be impossible to
describe the terms unique to \ModelExpr{} in terms of the \Expr{} language.
However, it is possible (and is done normally) to convert \Expr{}s into
\ModelExpr{}s for usage in generating the \acs{srs} documents, which primarily
expect \ModelExpr{}s for transcribing mathematical expressions. Furthermore,
with \ModelExpr{}, we may use instances of \Express{}
(\refCurrentExpressHaskell{}) to define how various chunks can be described
visually, using this mathematical modelling language.

\currentExpressHaskell{}

Continuing, we've noticed that there are residual terms left in \Expr{} that
don't quite relate to mathematics, but to ``code'' specifically (here, ``code''
meaning the \acs{oo} ``code''). As such, we continue the division by moving
those less related into their own language, specifically tailored to ``code''
expressions: \CodeExpr{} (\todo{ref Current CodeExpr Haskell}).

Finally, we end up with 3 languages, as shown in \refLanguageDivision{}: \Expr{}
(\refCurrentExprHaskell{}), \ModelExpr{} (\refCurrentModelExprHaskell{}), and
\CodeExpr{} (\todo{ref Current CodeExpr Haskell}). Each language has its own
specific domain, and, although there is some overlap between each, we are able
to enforce weaker rules on each formation through their \acs{ttf} instances if
needed.

Relating back to \refTheoriesWithoutModelKinds{}, we may observe that there is a
transformation from \textit{Theory} (realistically, these expression languages
discussed) to \textit{Mathematical Knowledge}. This may seem peculiar because
one might expect the \textit{theory} to be precisely the \textit{mathematical
	knowledge}. Presently, the mathematical knowledge is implicitly built into
transformers that work with \RelationConcept{}s (theories). The explicit
information is \textit{lost} in both the Haskell-level transformation function
that makes generation possible and the external knowledge used to create the
actual expression itself. To resolve this, we need to reconcile
\textit{theories} with \textit{mathematical knowledge}, strengthening the
\textit{depth of knowledge} contained in a theory. Should this occur, we should
observe \refTheoriesWithoutModelKinds{} having the \textit{Theory} and
\textit{Mathematical Knowledge} nodes merged, and have the expressions
understood to only be one of many possible ``views'' of higher-level usable
knowledge. In other words, the expressions would not be used to transfer
knowledge any longer, but they might remain as one component of it. Through
resolving these issues, we will have deeper knowledge available at Drasils
compile-time, and we will be able to better understand which theories are usable
in code generation, and which aren't. Additionally, we will be able to better
handle more \textit{kinds} of theories without needing to create complex
traversal and analysis algorithms to recognize when certain kinds of theories
were transcribed in the expressions.

\section{\textquotedblleft{}Classify All The Theories\textquotedblright{}}

Issues occurring due to weak knowledge capture may be resolved through strong
knowledge capture. Beginning with the existing case studies of Drasil, we will
attempt to classify our existing knowledge better. We aim to make
\RelationConcept{} a ``view'' of other more information-dense encodings. In
other words, we replace \Expr{} as a knowledge container, and restrict its usage
to strictly ``mathematical expressions'', as opposed to ``expressions'' and
information about models/theories. One notable change is that we will require
the new theory knowledge containers to be able to fully re-create the original
shallow/raw \Expr{}s as a property of the new theory encodings. The once
meta-level knowledge of the theories, lost in the Haskell implementation,
becomes exposed and understood to Drasil. Ultimately, this is done through
replacing \RelationConcept{} usage with \ModelKind{}\footnote{\ModelKind{} is
built upon Dr. Jacques Carettes prototype of an earlier version of
\ModelKinds{}}, an aggregation of existing Drasil-related knowledge of
mathematical theories. \ModelKind{} is defined using a \acs{gadt}, with one (1)
type parameter. The type parameter is currently used to determine whether the
model is ``fully refined''/``grounded'' or not, and, hence, usable in code
generation. \refCurrentModelKindsHaskell{} displays the creation of \ModelKind{}
and \ModelKinds{}. Please note that this aggregation is based purely on the
existing model examples in the existing Drasil case studies, and the existing
models are incomplete in the larger scope. Each \textit{kind of model} we find
only has one requirement: that it should carry enough information to, and
provide a means of, recreating the original expression from which they were
abstracted out of. This requirement is essentially that of ``viewing'' it in the
expression language, but it also tends to also add flexibility in how many ways
that we can ``view'' the information in different forms. In the Haskell code,
this requirement is enforced through requiring them all to instantiate the
\Express{} typeclass (\refCurrentExpressHaskell{}).

\currentModelKindsHaskell{}

\subsection{Quantity Definitions}

\currentQDefinitionHaskell{}

Assume \(y = x\) is transcribed as a \RelationConcept{}: while \(y = x\) might
conventionally be seen as ``y is equal to x'', we might want, in our model, for
it to be understood as ``x is defined by y'' but displayed differently. Here,
\(=\) is overloaded as ``definition'', instead of what \(=\) was defined as in
\Expr{}, as an ``equality'' operator. To resolve this overloading and weak
knowledge capture of definitions, we create \EquationalModel{}s: theories that
contain information about definitions of symbols, built using a \QDefinition{}
(\refCurrentQDefinitionHaskell{}). If an \EquationalModel{} deals with
theoretical symbols and is defined using either a \ModelExpr{} or an \Expr{}, it
may be used in Theory Models and General Definitions. If an \EquationalModel{}
is defined using an \Expr{} and deals with only the concrete (non-abstract)
symbols, then the \EquationalModel{} is usable for code generation. At the
moment, there is no information attached to symbols yet regarding whether they
are abstract or instanced, so that portion of the rule is not enforced.

\eztodo{Example of an EquationalModel/QDefinition in Haskell code, the SRS, and
	the generated code.}

\subsection{Constraints}

\currentConstraintSetHaskell{}

Theories that define expressions that constrain models in some way are defined
using \EquationalConstraints{}, which use \ConstraintSet{}s under the hood
(\refCurrentConstraintSetHaskell{})\todo{Describe what a ConstraintSet actually
	is.}. At the moment, these are not used in code generation, and are pending
design for usage in code generation as the translation from them into software
is unclear and may be interpreted differently by readers. This model can, and
should, eventually also be usable in code generation once there is interest in
creating runtime assertions of symbols.

\eztodo{Example of an EquationalConstraints/ConstraintSet in Haskell code, and
	the SRS.}

\subsection{Definition Realms}

\currentDefiningExprHaskell{}

\currentMultiDefnHaskell{}

The Theory Models and General Definition Models are unrefined, and may contain
multiple ways for a particular theoretical symbol to be defined. This is
captured in Drasil by \EquationalRealm{}s: modelled after realms\qtodo{Cite Dr.
Carette and Yasmines paper?}. This model kind is intended specifically for
retaining information about conscious choices made along the way to create
Instance Models. An \EquationalRealm{} is based on a \MultiDefn{}
(\refCurrentMultiDefnHaskell{}), and is intended for forming \QDefinition{}s
through choosing definitions (encoded as \DefiningExpr{}s,
\refCurrentDefiningExprHaskell{}), through refinements, from the \MultiDefn{}s.

\eztodo{Example of an EquationalRealm/MultiDefn in Haskell code, and the SRS.}

\subsection{Differential Equations}

\DEModel{} is the simple \RelationConcept{}-style capture of differential
equation-related theories, and only exists as a placeholder until all
differential equation models are converted into one of the other \ModelKinds{}.
For related solving of differential equations, \DEModel{} implicitly relies on a
developer writing a related \ODEInfo{}\todo{ref Current ODEInfo} packet which
the code generator can use to solve the system. Actively being reconstructed in
Drasil \cite{Chen2022MEng} \footnote{Shortly after I implemented \ModelKind{},
Dong continued working on exploring \DEModel{}s and created \NewDEModel{} as a
result.}, \NewDEModel{} is the replacement for \DEModel{}, aiming to expose more
information about well-understood differential equations and related areas.
\NewDEModel{} will eventually be renamed to \DEModel{} once all existing
\DEModel{} models have been upgraded.

\intodo{Example of a DEModel/NewDEModel and a RelationConcept in Haskell code,
	the SRS, and the related ODEInfo and code.}

\subsection{Leftovers}

\imptodo{Instead of writing anything here, I'm going to re-evaluate the existing
	leftover models and see if they can be replaced with any of the existing or
	if they need a new one.}

\begin{itemize}

	\item \OthModel{} \ldots{}

\end{itemize}

\section{Theories Undiscussed}

\ModelKinds{} is an enumeration of the currently handled model types. Each
``model'' is meant to expose information to the Haskell compiler and for other
fragments of knowledge to make use of. \ModelKinds{} is obviously an incomplete
enumeration, and will grow as the need for more kinds of models arises.

Through incorporating \ModelKinds{} and reaping its benefits, we obtain,
approximately, the flow of mathematical knowledge as shown below, in
\refTheoriesWithModelKinds{}.

\theoriesWithModelKinds{}

Comparing \refTheoriesWithModelKinds{} with \refTheoriesWithoutModelKinds{}, we
observe a decrease in the scary orange colouring! The focal difference in the
two figures (and the difference between the work pre-existing and current) lies
in the understanding of a theory. Previously, the ``theory'' was captured by the
\RelationConcept{}s themselves, captured fully by a single \Expr{} (the original
universal version). The mathematical knowledge of the theory was never
explicitly captured, and usage of theories was unsustainable due to reliance on
brittle transformations (\relToQD{}, \refOriginalRelToQDHaskell{}) and implicit
expectations of the written transcriptions. Now, the theories and the
mathematical knowledge are unified with information exposed both by dissection
of components as record entries, and by creating type information for
classifying theories and relevant information. Notably, from the new encodings
of the theories, we are still able to recreate the original \Expr{}s (or, now
\ModelExpr{}s) that once represented them.

\tedioustodo{Side-by-side figure comparison of \refTheoriesWithModelKinds{} and
	\refTheoriesWithoutModelKinds{}}

\eztodo{What do we learn from doing this conversion, about the greater part
	about encoding knowledge? \ldots{}}

From this, we obtain a new general rule for future knowledge
dissection/capture/encoding: when extracting information about the formation of
certain language snippets and classifying that contextual information, we must
ensure that we have obtained a generic means (algorithm) for reproducing the
originating term from an instance of the new contextual information. In other
words, there should be a generic method to reproduce the original information
from the new information \textemdash{} this is finding areas where we can add to the
generation possibilities of Drasil.

While we've gained information about the reason what the expressions described,
the expression language, as a whole, allows for poorly typed expressions to be
formed. We lack enforcement regarding the validity of \Expr{} as
``expressions''.

\ModelKind{} already has some success in enabling more theories to be encoded in
Drasil and used for code generation. Dong Chens Master's involved exploring
\acsp{ode} in Drasil and using them to generate code that solves them
\cite{Chen2022MEng}. Through his work, we have already observed some success
because more case studies are already capable of generating code (see
\refCaseStudiesCodeTableAfterDongsWork{}). Namely, \acs{dblpendulum} has working
code generation for 4 languages (Python, Java, C/C\(++\), and C\#), and
\acs{pdcontroller} now also supports Java, C/C\(++\), and C\# in addition to
Python.

\caseStudiesCodeTableAfterDongsWork{}
