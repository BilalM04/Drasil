% ModelKinds -- Theory types / discrimination -- ``Expressions in context''

In working to understand some phenomenon, we often look to the boundaries of our
understandings of the phenomenon — the open-ended questions and gaps in our
knowledge. In any domain of knowledge (such as mathematics, philosophy, physics,
chemistry, biology, computer science, or any other studied subject), we often
think about various phenomenon in logical terms of theories and axioms, where
the theories and axioms are written using a global logical language with precise
meanings\todo{I almost make it sound like we're not using English/Any other
	language to communicate ideas, I should clarify this.}. The language is
typically tailored to the field of knowledge. As this work pertains to Drasil,
one language of interest to this research is that of the mathematical language.
A mathematical language is heavily used in science, conveying important
theories, axioms, corollaries, amongst other things. As mathematicians
transferring knowledge to one another, we often use a written form of knowledge,
though unlikely, potentially, with a precise structure to our transcription of
the knowledge, but still, the structure is textual. We might break up the
transcription of the knowledge into sections. The sections of a theory may have
a name, a natural language description, a derivation, some information regarding
its origin (e.g., a reference), and a formalization of the theories important
information in a precise language. Of course, for a mathematical theory, a
mathematical language would be used. Describing a programming language artifact,
we might prefer to call our theories by a series of other names (e.g.,
functions/methods, constants, modules, packages, libraries, \acsp{api},
\acsp{ast}.

In Drasil, both of these languages are of great importance. The mathematical
field of knowledge is directly used in at least two domains currently captured:
the scientific theories, and \acs{gool} \cite{Carette2019}. Meanwhile, the
programming language theory (artifacts) is only directly used in \acs{gool}, and
its various renderers. The SmithEtAl \acs{srs} \cite{SmithAndLai2005} template
generator uses knowledge transcribed as scientific requirements to automatically
generate a series of representational software programs. Thankfully, Smith and
Lai \cite{SmithAndLai2005} break down theories relevant to \acs{scs} into at
least four (4) kinds for their \acs{srs} template:

\todo{Define the 4 kinds of models here.}
\begin{enumerate}

	\item \textbf{Theory Models}:

	\item \textbf{General Definitions}:

	\item \textbf{Instance Models}:

	\item \textbf{Data Definitions}:

\end{enumerate}

\intodo{Example of a theory/instance model here.}

\intodo{Insider knowledge: the theories are actively being re-thought.}

Since the SmithEtAl generator focuses itself on knowledge captured in the form
of the \acs{srs} template, Drasil requires a comprehensive understanding of both
fields in order to generate representational software for the \acs{srs}. The
focus of the scientific requirements documents are to transcribe the relevant
knowledge of a \acs{scs} system as developed by a domain/scientific expert. For
example, \todo{SRS document example} is used to fully explain \todo{something}
such that a software developer can construct a program based on it. Of course,
if the \acs{srs} document is to be truly sufficient for a software developer to
unambiguously create a representational software artifact, then the software
developer (who potentially knows nothing about the domain discussed in the
\acs{srs} document) will need to be able to credibly transcribe everything into
their program, matching the requirements as set by the \acs{srs} document.
Drasil is an apparatus for testing our understanding of these scenarios, rather
than having a read-only ``view'' of the scientists/domain experts knowledge
available to the software developer, the knowledge itself is available, in its
most raw encoded form.

Drasil relies on searching for a calculation path that relates the inputs and
outputs designated in an \acs{srs} document. The relations are based on the
grounded theories (\textit{Instance Models}) designated in the \acs{srs}. The
relations themselves are currently required to be of the form \(x = f(a, b, c,
\ldots{})\), with some exceptions made for \acsp{ode}. \acsp{ode} are being
actively developed to remove the manually written exceptions made for them
(outside the scope of this work).

Instance Models, General Definitions, and Data Definitions each rely on a
\textit{Relation Concept} (\RelationConcept{}): a notable and named mathematical
relation with a description and abbreviated name. A \RelationConcept{} is
modelled as a \Relation{} coupled with a \ConceptChunk{} (\todo{Add ConceptChunk
	original definition to thesis appendix.}, a named \textit{thing} with a name,
abbreviation, and natural language description):

\originalRelationConcept{}

The \Relation{}s \todo{add a reference to an appendix entry for the ``type
	Relation = Expr'' definition} in the \RelationConcept{} are, fundamentally,
just an instance of a universal mathematical language which conveys their
information, but given a type synonym to indicate that the instance should
be a mathematical relation.

\section{A Universal Math Language}
\label{sec:modelkinds:language}

\originalExprHaskell

\Expr{} (defined above, in \refOriginalExprHaskell{} with an \acs{adt})
represents the hypothetical mathematical language used to discuss the
mathematics relevant to common \acs{scs}, specifically, at least to
under/graduate-level physics problems. The language contains the commonly found
operations in a well-understood physics textbook (here, with a focus on
graduate-level scientific problems). The mathematical language is universal,
covering a wide range of knowledge, including facilities for creating commonly
used primitive data types, operations, and functions  in mathematics, physics,
and computer science and programming languages. For example, \todo{An
	expression.} is transcribed in Drasil as follows:

\intodo{Transcription of the above expression.}

This transcription relies on smart constructors, such as \todo{Ref. a new
	appendix entry for new smart constructors.}. The smart constructors used are
all specialized to \Expr{} and perform simplifications along the way (such
as folding \(1 \cdot x\) into \(x\)).

\section{A Universal Theory Description Language}

As Drasils theories rely heavily on \Relation{}s (and \RelationConcept{}s)
(\todo{Ref. the definitions of DDs, IMs, GDs, and TMs}), we may observe that the
theories are an accurate reflection of writing out mathematics involved as one
might write them down on paper: exactly as they please. In modelling any
problem, one will, of course, model the work of their pencil and paper. This is
exactly what occurs here. Theories here are shallow representations of
knowledge, that mimic your pencil and paper.

\section{Usage: Converting to Software}

Drasil relies on converting the various kinds of theories described in the
\acs{srs} template \cite{SmithAndLai2005}, essentially encoded in Drasil as
\RelationConcept{}s, into representational code.

\intodo{Example of an IM being converted into Java code.}

Unfortunately, issues occur when attempting to convert the knowledge contained
in \RelationConcept{}s. Namely,

\begin{enumerate}

	\item The transformation of \(\RelationConcept{} \rightarrow \acs{gool}\) is
	      not \textit{total} (e.g., not all terms of the \Expr{} language can be
	      mapped into a representational \acs{gool} term).

	      \begin{itemize}

		      \item Not all terms of the \Expr{} language have a definite value.

		      \item Some terms in \Expr{} require extra information before they
		            can be converted into code. At times, this information is a
		            conscious choice that the developer should be making instead
		            of imposed on them.

	      \end{itemize}

	\item It is very easy to write ``difficult/impossible to interpret''
	      expressions. For example, it is possible to create expressions for
	      which aren't directly calculable (i.e., things that require an extra
	      paper and pencil/mental mathematics before performing), either without
	      extra surrounding information or simply impossible.

	      \begin{itemize}

		      \item When writing a pencil \& paper, we usually write with extra
		            context (generally more information that needs to be read to
		            fully understand some expression). We might also infer
		            information about the model. Unfortunately, mechanizing
		            inference, without any sort of context or other knowledge,
		            is difficult, artificial learning is a whole field of study
		            of its own, and we're not interested in it here! As such, we
		            reverse the relationship of the inference by having
		            knowledge container expose everything on its own. We
		            additionally expect knowledge as a requisite to working with
		            the model.

		      \item Transformation requires a comprehensive understanding of the
		            inputs to outputs translation, but much of the input
		            knowledge requires complex analysis that would only appear
		            in the transformer, discarding its usability elsewhere —
		            information loss.

		      \item An \Expr{} alone is a weak conveyor of the inner knowledge
		            of theories, similar to normal pencil-and-paper mathematical
		            expressions, without extra information, the expression alone
		            may be ineffectual or nearly unusable in code generation.

		      \item It is important that each knowledge encoding in Drasil
		            exposes as much information as reasonably possible (and
		            useful). We want to expose the ``specifications'' of each
		            piece of knowledge that we are encoding so that transformers
		            and generators may appropriately make use of contained
		            knowledge.

	      \end{itemize}

	\item Drasil is limited to using theories with expressions written in a very
	      precise form: \(x = f(a, b, c, \ldots{})\) \todo{Discuss
		      \QDefinition{}s.}

	      \begin{itemize}

		      \item The \(=\) sign is being overloaded here to mean definition,
		            when it is supposed to mean equality. While \(y = x\) might
		            conventionally be seen as ``y is equal to x'', we might
		            want, in our model, for it to be understood as ``x is
		            defined by y'' but displayed differently.

		      \item Any other form of theories are unusable. Equational
		            constraints at the very least should be immediately usable
		            in creating assertions in the generated code.

	      \end{itemize}

	\item Existing transformation of \RelationConcept{}s into \acs{gool} relies
	      on unstable transformation caused by need to write in a precise
	      digestible form, with no static checks done at compile-time.

\end{enumerate}

Therefore, mathematical knowledge flow is unstable in Drasil, as shown in
\refTheoriesWithoutModelKinds{}. The focal issue with the existing way theories
are encoded is that the \textit{theories (\RelationConcept{}s) do not contain
	the meaningful usable mathematical knowledge at all}. The mathematical knowledge
is implicitly held within the Haskell-based functions\todo{I need to phrase this
	better, but, the Haskell calculation functionality should be used as
	infrequently as possible.}. In order to proceed, this mathematical knowledge
must be reconciled and merged with the \RelationConcept{}s in some capacity.

\theoriesWithoutModelKinds{}

\section{Reconciling Mathematical Knowledge}

Fundamentally, the issue lies in that the information exposed for Drasil to make
use of is too ``shallow''. At the moment, the available tools' type signatures
(\todo{Show a type signature}) would appear as something too amazing, so much so
in fact, that one would (and should) question its accuracy. A hypothetical type
signature, \inlineHs{RelationConcept -> Code}, is quite far fetched. Not all
expressions that can possibly be contained in a \RelationConcept{} are usable in
code generation\todo{Note somewhere in the thesis above that when we discuss
	``code'', we really mean \acs{oo} programs and snippets}.

Relating back to \refTheoriesWithoutModelKinds{}, we may observe that there is a
transformation from \textit{Theory} to \textit{Mathematical Knowledge}. This may
seem peculiar because one would expect the \textit{theory} to really be the
\textit{mathematical knowledge}. Presently, the mathematical knowledge is
implicitly built into transformers that work with \RelationConcept{}s
(theories). The explicit information is \textit{lost} in the Haskell-level
transformation function that makes generation possible. To resolve this, we need
to reconcile \textit{theories} with \textit{mathematical knowledge},
strengthening the \textit{depth of knowledge} contained in a theory. Should this
occur, we should observe \refTheoriesWithoutModelKinds{} having the
\textit{Theory} and \textit{Mathematical Knowledge} nodes merged, and have the
expressions understood to only be one of many possible ``views'' of higher-level
usable knowledge. In other words, the expressions would not be used to transfer
knowledge any longer, but they might remain as one component of it. Through
resolving these issues, we will have deeper knowledge available at Drasils
compile-time, and we will be able to better understand which theories are usable
in code generation, and which aren't. Additionally, we will be able to better
handle more \textit{kinds} of theories.

\section{``Classifying All The Theories''}

Issues occurring due to weak knowledge capture may be resolved through strong
knowledge capture. Beginning with the existing case studies of Drasil, we will
attempt to classify our existing knowledge better. We aim to make
\RelationConcept{} a ``view'' of other ``higher-order''\todo{Seems weird to say
	higher-order, need something else most likely.} knowledge encodings.

\currentModelKindsHaskell{}

\refCurrentModelKindsHaskell{} displays the creation of \ModelKind{} and
\ModelKinds{}.

\intodo{I should create a new acronym, SEtFPM, to indicate ``Slightly Edited to
	Fit Page Margins'', and use it everywhere.}

\intodo{Continue writing here.}

Incorporating \ModelKinds{} and reaping its benefits, we obtain, approximately,
the flow of mathematical knowledge as shown in \refTheoriesWithModelKinds{}.

\theoriesWithModelKinds{}

\intodo{Rewrite the point form notes in the ModelKinds section.}

\section{Problem}

\begin{itemize}

	\item For example, assuming the following expressions are written using the
	      existing mathematical Expr language in Drasil\ldots{}
	      \begin{itemize}

		      \item While \(y = x\) might conventionally be seen as ``y is equal
		            to x'', we might want, in our model, for it to be understood
		            as ``x is defined by y'' but displayed differently. Here,
		            \(=\) is also shown to have been previously abused by being
		            equality instead of definition.

		      \item \(a = b = c = ... = d\) can be ambiguously read\ldots{}

		      \item Truth statements such as \(y < x\) might be usable in
		            asserting constraints at software runtime, but it's
		            difficult to find a place for it to belong without extra
		            context.

	      \end{itemize}

\end{itemize}

\section{Requirements \& properties of a good solution}

\begin{itemize}

	\item Expressions are great for viewing, but not for a computer to
	      systematically use to generate things.

	\item Theories should expose more information about themselves so that we
	      can directly interpret them without needing to traverse over an
	      expression.

	\item Specifically, more expressions should be usable in code generation,
	      amongst other things.

\end{itemize}

\section{Solution}

\begin{itemize}

	\item Mathematical expressions may have definitive meanings at different
	      levels of interpretation. Splitting our focal expression language into
	      3 variants is easy thanks to GADTs and TTF \cite{Carette2009};
	      CodeExpr, ModelExpr, and Expr. This will allow us to restrict terms to
	      the different levels of interpretation through a common type (either
	      using the GADT, or the TTF constraints).

	\item Splitting Expr into 3 variants; Expr, CodeExpr, and ModelExpr. This
	      allows us to both segregate terms to particular domains, and add weak
	      typing where necessary, as required (e.g., areas where we might
	      require a dependently typed host language).

	      \begin{itemize}

		      \item
		            \url{https://github.com/JacquesCarette/Drasil/issues/1220}

	      \end{itemize}


	\item Replacing ``RelationConcepts'':

	      \begin{itemize}

		      \item Using raw expressions to transcribe whole mathematical
		            theories and data structures leads to many problems and
		            difficulties in interpretation alone.

		      \item In other words, we replace Expr as a knowledge container,
		            and restrict its usage to strictly ``expressions'', as
		            opposed to ``expressions'' and information about models.

		      \item Replacing raw expressions with ``encodings one step higher''
		            that can push out the same raw expressions as a property of
		            the higher-level encodings will allow us to quickly
		            identify, discriminate, and efficiently use the information
		            originally contained in the expressions better. This is done
		            through replacing ``RelationConcepts'' with ``ModelKinds'':

		      \item \currentModelKindsHaskell{}

		      \item In other words, we replace Expr as the expressive language
		            of knowledge (with a new kinds of knowledge encodings
			            [chunks]), and restrict its usage to strictly some
		            ``mathematical expressions'', as opposed to ``expressions'',
		            and meta-level information about the expressions and model.

		      \item \intodo{Discuss EquationalModels, EquationalRealms,
			            EquationalConstraints, DEModel, NewDEModel, etc.}

		      \item We can still push out ModelExprs and Exprs from things where
		            necessary, if they can be explained using them.

		      \item The type parameters used should not be worried about. The
		            holes used are primarily used for \Expr{} and \ModelExpr{},
		            where \Expr{} indicates that the model is usable in code
		            generation, while \ModelExpr{} indicates that it is not
		            usable in code generation.

	      \end{itemize}

\end{itemize}

\intodo{Remaining problems}
