\chapter{Classifying Theories}
\label{chap:modelkinds}

\begin{writingdirectives}
    \item What are theories used for in Drasil?
    \item How are they captured in Drasil?
    \item Current problems? Solution?
\end{writingdirectives}

In this chapter, we will focus on improving inspection and interpretation
capabilities of theories in Drasil. Specifically, with focus on interpreting
them for generating software artifacts.

\section{Transforming Theories to Code}
\label{chap:modelkinds:sec:transforming-theories-to-code}

As seen in \refOriginalJavaProjectileMain{}, it relies on a few methods
calculating the related ``instance models'' on its behalf. Those methods are a
specific \textit{interpretation}\footnote{Or ``view.''} of the theory knowledge.
Specifically, it is a \textit{calculation-focused} interpretation. For example,
to calculate \(p_\text{land}\), \refOriginalJavaProjectileMain{} relies on the
method \inlineCode{java}{func_p_land} to calculate the landing position.
\refOriginalJavaProjectilePLandMethod{} is one possible exported method for
calculating \(p_\text{land}\) given \(v_\text{launch}\), \(\theta\), and
\(\mathbf{g}\).

\originalJavaProjectilePLandMethod{}

Of course, to generate this method in \refOriginalJavaProjectilePLandMethod{},
Drasil relies on a sufficient capture of its underlying knowledge, and a means
of transforming said knowledge to ``code'' (e.g., sufficient information that
answers: What do we want to define? How can it be converted to code?). This
capture of theories is done using Drasils representation of an ``Instance
Model.'' To build it, Drasil uses information gathered from what users fed in
about it, via \refOriginalLandPosTheoryDefinition{}.

\originalLandPosTheoryDefinition{}

Now, let's unpack \refOriginalLandPosTheoryDefinition{}. \inlineHs{landPosIM} is
an instance of an \InstanceModel{}\footnote{Drasils encoding of the ``Instance
    Models.''}, containing the equational definition component
(\inlineHs{landPosRC}), and meta-level information about the theory, including
constraint ranges, notes, and a derivation\footnote{Mostly omitted here for the
    sake of conserving space.}.

In order to transform \refOriginalLandPosTheoryDefinition{} into
\refOriginalJavaProjectilePLandMethod{}, \textit{interpretation}\footnote{More
    accurately, this interpretation is ``domain-specific interpretation''
    \cite{Czarnecki2005}.} occurs on \inlineHs{landPosRC}
(\refOriginalRelToQDHaskell{}).

\originalRelToQDHaskell{}

\refOriginalRelToQDHaskell{} shows the definition of \relToQD{}, a function that
attempts to convert arbitrary relations into coherent ``quantity
definitions''\footnote{Or, ``variable definitions.''} (\QDefinition{}), which
Drasils ``\acs{srs} to code'' generator relies on. \inlineHs{landPosRC} is an
instance of a \RelationConcept{} (\refOriginalRelationConcept{}), a coupled
mathematical relation (encoded using \Relation{}s\footnote{\Relation{} is
    Drasils \acs{dsl} encoding arbitrary mathematical relations. We will talk more
    about this later. For now, this is enough.}), natural language description of
the relation, and descriptive name.

\originalRelationConcept{}

\relToQD{} is used on \textit{all} of the captured \InstanceModel{}s of a case
study to find code it can generate. However, these \InstanceModel{}s carry
arbitrary \Relation{}s, which are arbitrary mathematical relations. As such, an
issue arises: since \relToQD{} only works with ``variable defining''
relations\footnote{In some sense, calling these relations ``variable defining''
    is also an issue of itself. We're overloading \(=\) to mean definition.}, we're
limited to only one \textit{kind} of theory. Even with this restriction, we're
further limited to only a specific formation of that theory (e.g., relations of
the form \(x = f(a, b, c, \ldots{})\))!

\subsection{Problems}
\label{chap:modelkinds:sec:transforming-theories-to-code:subsec:problems}

In the sense that we really want to be able to use \relToQD{} (or something like
it) to transform arbitrary well-understood \textit{theories} into code fragments
for Drasils code generator, it has at least 3 problems:
\begin{enumerate}
    \item[\namedlabel{mk:issue:1}{P1}] it only handles one theory kind:
        variable definitions,
    \item[\namedlabel{mk:issue:2}{P2}] and for those definitions, it requires a
        specific form, thereby limiting users to very specific usage, views, and
        transcription,
    \item[\namedlabel{mk:issue:3}{P3}] and it implicitly assumes that all inputs
        will be of this theory kind, or else it causes a panic.
\end{enumerate}

As a result of \ref{mk:issue:1}, we aren't able to encode adequately all the
theories we're interested in using, and want to generate representational code
of. In particular, as Drasil is heavily guided by physics-focused case studies,
\acsp{ode} are desired! When we want to use \acsp{ode} in the solution of a
problem, extra information is required. For example, we might need to give
Drasil (and/or developers) information about a desired approximation formula
with particular ``settings.'' Drasil does circumvent this issue for \acsp{ode},
but we would like to reconcile the half-measures and push all necessary
information back in to the theory encodings.

Assuming we wanted to describe the theory of a line, there are many ways we can
describe the equation: polynomial (\(a \cdot{} x + b \cdot{} y + c = 0\)),
slope-intercept form (\(y = m \cdot{} x + b\)), point-slope form (\(y_1 - y_2 =
m(x_1 - x_2)\)), and so on. However, as a result of \ref{mk:issue:2}, we are
forced to use the ``simple'' slope-intercept form, even though we are aware of
other forms and may prefer to describe it in other forms.

As a result of \ref{mk:issue:3}, when Drasils users are encoding theories in
Drasil, they might be misled to think that any of their encoded theories is
fully-understood to Drasil and actually usable as part of the generated solution.

Together, these issues arise because of a lack of sufficient \textit{depth} and
\textit{breadth} in the contained knowledge of the theory encodings. Because the
theory encodings rely on ``flat'' information (e.g., the relations),
transforming them programmatically is challenging. Of course, if two programmers
were to read this information in the \acs{srs}, they might be able to use it.
However, the programmers understand the context of the theory, and are able to
\textit{recognize} (from any form of a theory) if and how it can be transcribed
as a computation. Now, imagine if we wanted to  So, how can we mitigate all of
these issues?

Just as we may discuss the specifics of implementing any particular theory in
our manual implementation of a software artifact, we assume prior learned
knowledge about mathematical expressions, such as which ones we know we can
somehow translate into code. In order to mitigate these issues, we must further
capture this background knowledge because raw relations carry too little
information about how to transform into coded. So, now, more concretely, we ask:
how could we have avoided these individual problems?

\begin{longtable}[c]{>{\raggedright}p{0.3\linewidth}>{\raggedright\arraybackslash}p{0.54\linewidth}}
    \textit{To avoid~\ldots{}} & \textit{we needed~\ldots{}}                                    \\
    \ref{mk:issue:1}              & knowledge about more \textit{kinds} of theories,            \\
    \ref{mk:issue:2}              & to decompose the relations into its set of
    logical components and capture information about how instances can be
    transformed into various forms,                                                             \\
    \ref{mk:issue:3}              & a signifier for each theory \textit{kind} we're interested. \\
\end{longtable}







\imptodo{Continue writing here!}

\section{\textquotedblleft{}Classify All The Theories\textquotedblright{}}

Issues occurring due to weak knowledge capture may be resolved through strong
knowledge capture.

Beginning with the existing case studies of Drasil, we will attempt to classify
our existing knowledge better.

We aim to make \RelationConcept{} a ``view'' of other more information-dense
encodings.

In other words, we replace \Expr{} as a knowledge container, and restrict its
usage to strictly ``mathematical expressions'', as opposed to ``expressions''
and information about models/theories.

One notable change is that we will require the new theory knowledge containers
to be able to fully re-create the original shallow/raw \Expr{}s as a property of
the new theory encodings.

The once meta-level knowledge of the theories, lost in the Haskell
implementation, becomes exposed and understood to Drasil.

Ultimately, this is done through replacing \RelationConcept{} usage with
\ModelKind{}\footnote{\ModelKind{} is built upon Dr. Jacques Carettes prototype
    of an earlier version of \ModelKinds{}}, an aggregation of existing
Drasil-related knowledge of mathematical theories. \ModelKind{} is defined using
a \acs{gadt}, with one (1) type parameter. The type parameter is currently used
to determine whether the model is ``fully refined''/``grounded'' or not, and,
hence, usable in code generation.

\refCurrentModelKindsHaskell{} displays the creation of \ModelKind{} and
\ModelKinds{}.

Please note that this aggregation is based purely on the existing model examples
in the existing Drasil case studies, and the existing models are incomplete in
the larger scope.

Each \textit{kind of model} we find only has one requirement: that it should
carry enough information to, and provide a means of, recreating the original
expression from which they were abstracted out of.

This requirement is essentially that of ``viewing'' it in the expression
language, but it also tends to also add flexibility in how many ways that we can
``view'' the information in different forms.

In the Haskell code, this requirement is enforced through requiring them all to
instantiate the \Express{} typeclass (\refCurrentExpressHaskell{}).

\currentModelKindsHaskell{}

In the above \ModelKinds{} definition, there are two (2) TODO notes that you may
disregard.

The first one is merely a note for analyzing ``well-understood'' copies of our
existing \acsp{ode}, and the second one refers to models that haven't yet been
fully analyzed for how they will be used (other than for display).

\subsection{Quantity Definitions}

\currentQDefinitionHaskell{}

Assume \(y = x\) is transcribed as a \RelationConcept{}: while \(y = x\) might
conventionally be seen as ``y is equal to x'', we might want, in our model, for
it to be understood as ``x is defined by y'' but displayed differently.

Here, \(=\) is overloaded as ``definition'', instead of what \(=\) was defined
as in \Expr{}, as an ``equality'' operator.

To resolve this overloading and weak knowledge capture of definitions, we create
\EquationalModel{}s: theories that contain information about definitions of
symbols, built using a \QDefinition{} (\refCurrentQDefinitionHaskell{}).

If an \EquationalModel{} deals with theoretical symbols and is defined using
either a \ModelExpr{} or an \Expr{}, it may be used in Theory Models and General
Definitions.

If an \EquationalModel{} is defined using an \Expr{} and deals with only the
concrete (non-abstract) symbols, then the \EquationalModel{} is usable for code
generation.

At the moment, there is no information attached to symbols yet regarding whether
they are abstract or instanced, so that portion of the rule is not enforced.

\eztodo{Example of an EquationalModel/QDefinition in Haskell code, the SRS, and
    the generated code.}
