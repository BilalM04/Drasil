\chapter{Framing Theories}
\label{chap:modelkinds}

\section{\textquotedblleft{}Classify All The Theories\textquotedblright{}}

Issues occurring due to weak knowledge capture may be resolved through strong
knowledge capture.

Beginning with the existing case studies of Drasil, we will attempt to classify
our existing knowledge better.

We aim to make \RelationConcept{} a ``view'' of other more information-dense
encodings.

In other words, we replace \Expr{} as a knowledge container, and restrict its
usage to strictly ``mathematical expressions'', as opposed to ``expressions''
and information about models/theories.

One notable change is that we will require the new theory knowledge containers
to be able to fully re-create the original shallow/raw \Expr{}s as a property of
the new theory encodings.

The once meta-level knowledge of the theories, lost in the Haskell
implementation, becomes exposed and understood to Drasil.

Ultimately, this is done through replacing \RelationConcept{} usage with
\ModelKind{}\footnote{\ModelKind{} is built upon Dr. Jacques Carettes prototype
of an earlier version of \ModelKinds{}}, an aggregation of existing
Drasil-related knowledge of mathematical theories. \ModelKind{} is defined using
a \acs{gadt}, with one (1) type parameter. The type parameter is currently used
to determine whether the model is ``fully refined''/``grounded'' or not, and,
hence, usable in code generation.

\refCurrentModelKindsHaskell{} displays the creation of \ModelKind{} and
\ModelKinds{}.

Please note that this aggregation is based purely on the existing model examples
in the existing Drasil case studies, and the existing models are incomplete in
the larger scope.

Each \textit{kind of model} we find only has one requirement: that it should
carry enough information to, and provide a means of, recreating the original
expression from which they were abstracted out of.

This requirement is essentially that of ``viewing'' it in the expression
language, but it also tends to also add flexibility in how many ways that we can
``view'' the information in different forms.

In the Haskell code, this requirement is enforced through requiring them all to
instantiate the \Express{} typeclass (\refCurrentExpressHaskell{}).

\currentModelKindsHaskell{}

In the above \ModelKinds{} definition, there are two (2) TODO notes that you may
disregard.

The first one is merely a note for analyzing ``well-understood'' copies of our
existing \acsp{ode}, and the second one refers to models that haven't yet been
fully analyzed for how they will be used (other than for display).

\subsection{Quantity Definitions}

\currentQDefinitionHaskell{}

Assume \(y = x\) is transcribed as a \RelationConcept{}: while \(y = x\) might
conventionally be seen as ``y is equal to x'', we might want, in our model, for
it to be understood as ``x is defined by y'' but displayed differently.

Here, \(=\) is overloaded as ``definition'', instead of what \(=\) was defined
as in \Expr{}, as an ``equality'' operator.

To resolve this overloading and weak knowledge capture of definitions, we create
\EquationalModel{}s: theories that contain information about definitions of
symbols, built using a \QDefinition{} (\refCurrentQDefinitionHaskell{}).

If an \EquationalModel{} deals with theoretical symbols and is defined using
either a \ModelExpr{} or an \Expr{}, it may be used in Theory Models and General
Definitions.

If an \EquationalModel{} is defined using an \Expr{} and deals with only the
concrete (non-abstract) symbols, then the \EquationalModel{} is usable for code
generation.

At the moment, there is no information attached to symbols yet regarding whether
they are abstract or instanced, so that portion of the rule is not enforced.

\eztodo{Example of an EquationalModel/QDefinition in Haskell code, the SRS, and
	the generated code.}

\subsection{Constraints}

\currentConstraintSetHaskell{}

Theories that define expressions that constrain models in some way are defined
using \EquationalConstraints{}, which use \ConstraintSet{}s under the hood
(\refCurrentConstraintSetHaskell{})\todo{Describe what a ConstraintSet actually
	is.}.
	
At the moment, these are not used in code generation, and are pending design for
usage in code generation as the translation from them into software is unclear
and may be interpreted differently by readers.

This model can, and should, eventually also be usable in code generation once
there is interest in creating runtime assertions of symbols.

\eztodo{Example of an EquationalConstraints/ConstraintSet in Haskell code, and
	the SRS.}

\subsection{Definition Realms}

\currentDefiningExprHaskell{}

\currentMultiDefnHaskell{}

The Theory Models and General Definition Models are unrefined, and may contain
multiple ways for a particular theoretical symbol to be defined. This is
captured in Drasil by \EquationalRealm{}s: modelled after realms\qtodo{Cite Dr.
Carette and Yasmines paper?}.

This model kind is intended specifically for retaining information about
conscious choices made along the way to create Instance Models.

An \EquationalRealm{} is based on a \MultiDefn{}
(\refCurrentMultiDefnHaskell{}), and is intended for forming \QDefinition{}s
through choosing definitions (encoded as \DefiningExpr{}s,
\refCurrentDefiningExprHaskell{}), through refinements, from the \MultiDefn{}s.

\eztodo{Example of an EquationalRealm/MultiDefn in Haskell code, and the SRS.}

\subsection{Differential Equations}

\DEModel{} is the simple \RelationConcept{}-style capture of differential
equation-related theories, and only exists as a placeholder until all
differential equation models are converted into one of the other \ModelKinds{}.

For related solving of differential equations, \DEModel{} implicitly relies on a
developer writing a related \ODEInfo{}\todo{ref Current ODEInfo} packet which
the code generator can use to solve the system.

Actively being reconstructed in Drasil \cite{Chen2022MEng} \footnote{Shortly
after I implemented \ModelKind{}, Dong continued working on exploring
\DEModel{}s and created \NewDEModel{} as a result.}, \NewDEModel{} is the
replacement for \DEModel{}, aiming to expose more information about
well-understood differential equations and related areas.

\NewDEModel{} will eventually be renamed to \DEModel{} once all existing
\DEModel{} models have been upgraded.

\intodo{Example of a DEModel/NewDEModel and a RelationConcept in Haskell code,
	the SRS, and the related ODEInfo and code.}

\subsection{Leftovers}

\imptodo{Leftover model kinds.}

\section{Theories Undiscussed}

\ModelKinds{} is an enumeration of the currently handled model types.

Each ``model'' is meant to expose information to the Haskell compiler and for
other fragments of knowledge to make use of.

\ModelKinds{} is obviously an incomplete enumeration, and will grow as the need
for more kinds of models arises.

Through incorporating \ModelKinds{} and reaping its benefits, we obtain,
approximately, the flow of mathematical knowledge as shown below, in
\refTheoriesWithModelKinds{}.

\theoriesWithModelKinds{}

Comparing \refTheoriesWithModelKinds{} with \refTheoriesWithoutModelKinds{}, we
observe a decrease in the scary orange colouring!

The focal difference in the two figures (and the difference between the work
pre-existing and current) lies in the understanding of a theory.

Previously, the ``theory'' was captured by the \RelationConcept{}s themselves,
captured fully by a single \Expr{} (the original universal version).

The mathematical knowledge of the theory was never explicitly captured, and
usage of theories was unsustainable due to reliance on brittle transformations
(\relToQD{}, \refOriginalRelToQDHaskell{}) and implicit expectations of the
written transcriptions.

Now, the theories and the mathematical knowledge are unified with information
exposed both by dissection of components as record entries, and by creating type
information for classifying theories and relevant information.

Notably, from the new encodings of the theories, we are still able to recreate
the original \Expr{}s (or, now \ModelExpr{}s) that once represented them.

\theoriesSideBySideModelKinds{}

\eztodo{What do we learn from doing this conversion, about the greater part
	about encoding knowledge? \ldots{}}

From this, we obtain a new general rule for future knowledge
dissection/capture/encoding: when extracting information about the formation of
certain language snippets and classifying that contextual information, we must
ensure that we have obtained a generic means (algorithm) for reproducing the
originating term from an instance of the new contextual information.

In other words, there should be a generic method to reproduce the original
information from the new information \textemdash{} this is finding areas where
we can add to the generation possibilities of Drasil.
