\chapter{Expression Language Division}
\label{chap:lang-division}

\begin{writingdirectives}
    \item What are Relations really?
    \item What is \Expr{}?
    \item How is \Expr{} used?
    \item How can we restrict \Expr{} terms to particular areas?
\end{writingdirectives}

In this chapter, we will discuss how Drasil captures relations and general
mathematical expressions, and the issues associated with the single universal
language approach Drasil takes.

\section{Relations}
\label{chap:lang-division:sec:relations}

In \Cref{chap:modelkinds}, we discussed how Drasil captures theories.
Specifically, we discussed how Drasil heavily relies on relations for defining
them. However, we never discussed the relation encoding: \Relation{}.

\originalRelation{}

\Relation{}s are actually \Expr{}s, mathematical ``expressions.''

\originalExprHaskell{}

\section{A Mathematical Language}
\label{chap:lang-division:sec:a-mathematical-language}

\Expr{} (\refOriginalExprHaskell{}) is an \acs{adt}, representing the \ACF{ast}
of a mathematical expression language. It was grown following the needs of
encoding the case studies in Drasil. As such, it contains a wide range of
``mathematical'' terms, including variables, numerics, derivatives, common
mathematical operations, and function applications. In addition to the example
expression (a relation) from \refOriginalLandPosTheoryDefinition{}, if, for
example, we wanted to transcribe \(3 e^{x + 2} = y\) in Drasil, we might write
\refPseudoExampleExpression{}. Notably, \refPseudoExampleExpression{} uses smart
constructors\footnote{The smart constructors used are all specialized to \Expr{}
and perform simplifications along the way (such as folding \(1 \cdot x\) into
\(x\)).} and infix functions to make the code readable. 

\pseudoExampleExpression{}

As already mentioned in \Cref{chap:modelkinds}, theories are a key component of
the code generation phase for any Drasil-encoded \acs{srs}
instance\footnote{Theories are where we get information about things to
generate!}. Taking \refCurrentLandPosIMQD{} as an example of a usable theory for
code generation, if we were to change the defining expression to some expression
involving definite description or a derivative, then converting the theory to
Java code is a bit more complicated. In some instances, conversion to usable
``code'' can also be merely impossible without extra information, or commitment
to an approximation formula at least (both options should not be imposed on
users by Drasil either!).

\subsection{A Problem}
\label{chap:lang-division:sec:a-mathematical-language:subsec:a-problem}

In other words, the transformation of \Expr{}s to ``code''\footnote{Through
\acs{gool}!} is not \textit{total} (i.e., not all possible expressions of the
\Expr{} language can be converted into a representational \acs{gool}
expression). Additionally, we lack static information about when instances of
expressions are actually usable in code generation. As such, we're currently
limited to relying on implicit information. Of course, in order to fix this
problem, we need to make the information \textit{explicit} in Drasil, and use it
appropriately. However, before we can make it explicit, we need to understand
the contexts in which Drasil needs mathematical expressions and how they are
used in those contexts.

Namely, there are 2 main use-cases of mathematical expressions in Drasil:
describing theories as part of an \acs{srs} that should appear in ``code,'' or
describing theories as part of an \acs{srs} that should appear in the generated
(textual) \acs{srs} artifacts. The ``code'' is expected to be a
computer-executable artifact. Thus, the code has clearly defined rules for a
usable program. Generated textual artifacts are checked for consistency by
readers and writers alike. However, the textual artifacts do have some amount of
``automated'' consistency checking done on them. More specifically, the textual
artifacts are generated from the same chunks used to generate the software
artifacts, and, by extension, the instances of theories that ``go into the
code'' should all be concrete. Specifically, the instance models should all be
concrete theories that can be unambiguously re-written in the form of an
executable program. The language associated with the output \acs{oo} languages
slightly differs from our common mathematical language (e.g., they typically
don't have curried functions). Thus, we have approximately 3 use-cases for
mathematical expressions in Drasil: in software, in writing concrete theories,
and in general mathematical discussion. Finally, to solve this issue, we need to
restrict terms to their appropriate usage contexts.

\section{Splitting}
\label{chap:lang-division:sec:splitting}

In order to appropriately restrict terms to their appropriate usage contexts, we
need to gain structural information about the expressions. Specifically, we
would like to do this using type information as it allows us to restrict usage
by type easily.

\languageDivision{}

As we've recognized 3 contexts in which mathematical expressions are used, we
may split the mathematical language accordingly, re-building the languages for
each context. We end up with 3 languages, as shown in \refLanguageDivision{}:
\Expr{} (\refCurrentExprHaskell{}), \ModelExpr{}
(\refCurrentModelExprHaskell{}), and \CodeExpr{} (\refCurrentCodeExprHaskell{}).
\Expr{} has its indefinite valued terms split off into \ModelExpr{}
(\refCurrentModelExprHaskell{})\footnote{Including, but not limited to,
derivatives, integrals, quantification, types as values, definitions (e.g.,
\(::=\)), and continuous ranges for summations and products.}, a deeply embedded
universal mathematical language. As we desire for it to be equally usable as the
\Expr{} used in instance models, it is essentially the original \Expr{} without
the language terms related to code nor indefinite valued terms. \ModelExpr{} is
approximately the ``old'' \Expr{} with nearly everything from the original
\Expr{}, except without code-oriented terms (as they should not be discussed in
the \acs{srs} documents at all!). Additionally, now, \ModelExpr{} becomes the
preferred mathematical language for \acs{srs} documents. Finally, code-related
terms are moved to a clone of the new \Expr{} language.

Now, we have 3 \acsp{gadt} available for different kinds of expression
languages, with ``mathematics'' as a common tie. One issue with splitting is
that we now force users of the languages to make a conscious choice about which
language they are using and which language they need to import into their
working files respectively. This can become quite frustrating given the amount
of overlap. Thus, in order to alleviate the stress involved with writing out the
same expression in different languages, we use a \ACF{ttf} encoding of the smart
constructors to build expressions. Using \Expr{} has a ``base'' shared language
between \ModelExpr{} and \CodeExpr{}, we can write \acs{ttf} encoding for them
individually that extends on \Expr{}s functionality
(\refCurrentExprTTFHaskell{}, \refCurrentModelExprTTFHaskell{},
\refCurrentCodeExprTTFHaskell{}). The \acs{ttf} encoding allows us to seamlessly
write expressions in any of the languages at the same time, allowing type
variability along the type constraints of any expression. The typeclasses used
in the languages may be used to create constriants on the language used.

While \ModelExpr{}s \acs{ttf} encoding strictly contains the terms unique to
\ModelExpr{}, it is possible (and is done normally) to convert \Expr{}s into
\ModelExpr{}s for usage in generating the \acs{srs} documents. Additionally,
since many theories need to be representable as a single \Relation{}, we may
create a typeclass to create enforcement (\refCurrentExpressHaskell{}). By
instantiating it for various types, we are explaining how those terms can be
interpreted as a \ModelExpr{}.

\currentExpressHaskell{}
 
\section{Back to Theories}
\label{chap:lang-division:sec:back-to-theories}

Now that we've split up the expression languages, we may restrict their usage to
appropriate theory contexts (in \ModelKinds{} as per \Cref{chap:modelkinds}).
Approximately, we can ``upgrade'' \ModelKinds according to
\refPseudoPartialModelKindsUpgrade{} \footnote{Note that we also need to
slightly update \QDefinition{}s: \refCurrentQDefinitionHaskell{} to create a
type parameter for the used expression type.}, creating a type argument in
\ModelKinds{} so that instance models can restrict to carry ``\ModelKinds{}
\Expr{}'' while the other theory types may carry ``\ModelKinds{}
\ModelExpr{}''\footnote{However, using \Expr{} and \ModelExpr{} is not quite
accurately representative of ``usable in code'' versus ``not,'' which we are
attempting to fix \cite{DrasilIssue2853AlternativeModelKinds}}. This allows us
to ensure that all expressions written in Drasil for instance models have an
semantic counterpart that they can be translated into for code generation in
various \acs{oo} languages. Furthermore, now we may return to \ModelKinds{} and
continue uncovering the various \textit{kinds} of theories currently discussed
in Drasils case studies.

\pseudoPartialModelKindsUpgrade{}
