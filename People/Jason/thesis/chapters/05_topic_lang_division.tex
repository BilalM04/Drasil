\chapter{Expression Language Division}
\label{chap:lang-division}

\begin{writingdirectives}
    \item What are Relations really?
    \item What is \Expr{}?
    \item How is \Expr{} used?
    \item How can we restrict \Expr{} terms to particular areas?
\end{writingdirectives}

In this chapter, we will discuss how Drasil captures relations and general
mathematical expressions, and the issues associated with the single universal
language approach Drasil takes.

\section{Relations}
\label{chap:lang-division:sec:relations}

In \Cref{chap:modelkinds}, we discussed how Drasil captures theories.
Specifically, we discussed how Drasil heavily relies on relations for defining
them. However, we never discussed the relation encoding: \Relation{}.

\originalRelation{}

\Relation{}s are actually \Expr{}s, mathematical ``expressions.''

\originalExprHaskell{}

\section{A Mathematical Language}
\label{chap:lang-division:sec:a-mathematical-language}

\Expr{} (\refOriginalExprHaskell{}) is an \acs{adt}, representing the \ACF{ast}
of a mathematical expression language. It was grown following the needs of
encoding the case studies in Drasil. As such, it contains a wide range of
``mathematical'' terms, including variables, numerics, derivatives, common
mathematical operations, and function applications. In addition to the example
expression (a relation) from \refOriginalLandPosTheoryDefinition{}, if, for
example, we wanted to transcribe \(3 e^{x + 2} = y\) in Drasil, we might write
\refPseudoExampleExpression{}.

\pseudoExampleExpression{}

Notably, \refPseudoExampleExpression{} uses smart constructors\footnote{The
smart constructors used are all specialized to \Expr{} and perform
simplifications along the way (such as folding \(1 \cdot x\) into \(x\)).} and
infix functions to make the code readable. 

As already mentioned in \Cref{chap:modelkinds}, theories are a key component of
the code generation phase for any Drasil-encoded \acs{srs}
instance\footnote{Theories are where we get information about things to
generate!}. Taking \refOriginalLandPosIMQD{} as an example of a usable theory
for code generation, if we were to change the defining expression to some
expression involving definite description or a derivative, then converting the
theory to Java code is a bit more complicated. In some instances, conversion to
usable ``code'' can also be merely impossible without extra information, or
commitment to an approximation formula at least (both options should not be
imposed on users by Drasil either!).

\subsection{A Problem}
\label{chap:lang-division:sec:a-mathematical-language:subsec:a-problem}

In other words, the transformation of \Expr{}s to ``code''\footnote{Through
\acs{gool}!} is not \textit{total} (i.e., not all possible expressions of the
\Expr{} language can be converted into a representational \acs{gool}
expression). Additionally, we lack static information about when instances of
expressions are actually usable in code generation. As such, we're currently
limited to relying on implicit information. Of course, in order to fix this
problem, we need to make the information \textit{explicit} in Drasil, and use it
appropriately. However, before we can make it explicit, we need to understand
the contexts in which Drasil needs mathematical expressions and how they are
used in those contexts.

Namely, there are 2 main situations for using mathematical expressions in
Drasil: describing theories as part of an \acs{srs} that should appear in
``code,'' or describing theories as part of an \acs{srs} that should appear in
the generated (textual) \acs{srs} artifacts. Thankfully, since textual artifacts
don't typically undergo an automatic checking process for anything other than
grammar, we need not concern about the transformation of
expressions\footnote{Though unneeded because Drasil focuses on well-understood
ideas, if desired, we can create new textual markup for any terms output.}.

\imptodo{Continue writing here!}

\begin{enumerate}
    \item A solution? Splitting it up
    \begin{enumerate}
        \item CodeExpr
        \item Expr
        \item ModelExpr
    \end{enumerate}
\end{enumerate}

At the moment, it is possible to describe mathematical expressions that are
completely unusable in \acs{gool} because \acsp{gool} primary targets are
languages that rely on expressions with, at least, definite values.

Of course, \Expr{} already contains terms that are without definite values.

For example, \Expr{} (\refOriginalExprHaskell{}) discusses derivations,
integrations, spaces as primitive/literal values (largely symbolic, and
unavailable in \acs{oo} languages), definition statements, and infinite series.
Realistically, this information already \textit{exists} in Drasil, but it is not
strongly enforced at Drasils Haskell-level compile-time.





In order to ensure that developers can only write ``usable'' grounded theories
(``InstanceModels'') for the code generator to use, we have chosen to expose
this information to the compiler.

Specifically, we have chosen to expose it via language division and type
information.

\languageDivision{}

\Expr{} has its indefinite values split off into \ModelExpr{}
(\refCurrentModelExprHaskell{})\todo{List notable terms moved, Deriv, Continuous
vs Discrete ranges, Space, etc}, a deeply embedded universal mathematical
language.

As we desire for it to be equally usable as \Expr{}, it is, essentially, the
original \Expr{} without the language terms related to ``code.''

In order to alleviate the stress involved with writing out the same expression
in two (2) different languages, we use a \ACF{ttf} encoding of the two (2)
languages: \refCurrentExprTTFHaskell{} and \refCurrentModelExprTTFHaskell{}. 

The \acs{ttf} encoding allows us to seamlessly write expressions in either, or
both, languages at the same time. 

\ModelExpr{}s \acs{ttf} encoding strictly contains the terms unique to
\ModelExpr{}.

As such, the \acs{ttf} encoding won't allow terms from \ModelExpr{} to be
interpreted into \Expr{} unless they have a definite value because it will be
impossible to describe the terms unique to \ModelExpr{} in terms of the \Expr{}
language.

However, it is possible (and is done normally) to convert \Expr{}s into
\ModelExpr{}s for usage in generating the \acs{srs} documents, which primarily
expect \ModelExpr{}s for transcribing mathematical expressions.

Furthermore, with \ModelExpr{}, we may use instances of \Express{}
(\refCurrentExpressHaskell{}) to define how various chunks can be described
visually, using this mathematical modelling language.

\currentExpressHaskell{}

Continuing, we've noticed that there are residual terms left in \Expr{} that
don't quite relate to mathematics, but to ``code'' specifically (here, ``code''
meaning the \acs{oo} ``code'').

As such, we continue the division by moving those less related into their own
language, specifically tailored to ``code'' expressions: \CodeExpr{} (\todo{ref
Current CodeExpr Haskell}).



Finally, we end up with 3 languages, as shown in \refLanguageDivision{}: \Expr{}
(\refCurrentExprHaskell{}), \ModelExpr{} (\refCurrentModelExprHaskell{}), and
\CodeExpr{} (\todo{ref Current CodeExpr Haskell}).

Each language has its own specific domain, and, although there is some overlap
between each, we are able to enforce weaker rules on each formation through
their \acs{ttf} instances if needed.
