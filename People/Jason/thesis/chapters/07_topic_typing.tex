\chapter{Typing the Expression Language}
\label{chap:typed-expr}

\begin{writingdirectives}
      \item How is \Expr{} used?
      \item What are current problems with \Expr{} usage?
      \item What does it mean for expressions to be well-formed/well-typed?
      \item What is a type system? How can we build one for \Expr{}?
            \begin{itemize}
                  \item ``Safety = Preservation + Progress'' \cite{Harper2016}
                  \item What is a bidirectional type system? Why bidirectional
                        over a normal ``simply-typed'' system?
                  \item How can this be implemented in Drasil?
            \end{itemize}
      \item What errors did the type checker currently find?
\end{writingdirectives}

In \Cref{chap:lang-division}, we discussed Drasils single mathematical
expression language, and split it into three variants, each specialized for
their intended usage context. As a result, we don't need to be concerned about
encountering terms inapplicable to the various contexts. However, we did not
speak about what it means for expressions to be considered \textit{well-formed}
for each context. In this chapter, we will focus on improving well-formedness
for the most important context: grounded theories used for code generation.

\section{Expressions, Instance Models, and Data Definitions}
\label{chap:typed-expr:sec:expressions-instance-models-and-data-definitions}

To generate code, Drasil's code generator relies on a series of grounded
theories as part of it's input. There are two kinds of theories that the code
generator uses from the abstracted \acs{srs} template: instance models and data
definitions. Data definitions are, as the name suggests, concrete symbol
definitions using expressions (similar to the \EquationalModel{} \ModelKind{}
variant, discussed in
\Cref{chap:more-theory-kinds:sec:classify-all-the-theories:subsec:equational-models}).
On the other hand, instance models may contain data definitions or any of the
other applicable \ModelKinds{} variants (discussed in
\Cref{chap:more-theory-kinds}, albeit currently limited\footnote{For our
purposes, it's enough to assume that they can expose any number of expressions
usable in code generation.}). In order for the expressions they expose/form to
be usable in code generation, the expressions must be representable in
\acs{gool} somehow\footnote{Since all code generation for Drasil currently goes
through \acs{gool}.}. Thanks to \Cref{chap:lang-division}, \Expr{} has become
the expression language that currently limits mathematical expressions in both
instance models and data definitions to ones with definite values that can be
directly computed on pencil and paper, and in most modern programming languages.
However, translatability to \acs{gool} does not necessarily mean that all the
expressions are actually coherent and usable. At the moment, it is possible to
give Drasils instance models and data definitions invalid \Expr{}s and have
Drasil generate code.

\pseudoExampleLandPosQDBadTyping{}

Take \refCurrentLandPosIMHaskell{} for example. The defining expression of
\(p_\text{land}\), \inlineHs{E.landPosExpr}, is of type \Expr{} and limited to
terms that can be naively translated to \acs{gool} without external knowledge.
If we were to change the defining expression to something incoherent (such as
\(1 + \texttt{``Drasil''}\)\footnote{The sum of the number 1 and string
``Drasil''}, \refPseudoExampleLandPosQDBadTyping{}), we end up with (a) an
algorithm that doesn't exactly make sense, and (b) a generated software source
code that does what we wanted it to do
(\refPseudoExampleLandPosQDBadTypingJavaCode{}), but which isn't actually
compilable software (\refPseudoExampleLandPosQDBadTypingJavaCodeCompErr{}).
Despite the examples simplicity, assuming it was derived from other theories
that somehow went awry, then we should have caught the type error before we
generated code.

\pseudoExampleLandPosQDBadTypingJavaCode{}

\pseudoExampleLandPosQDBadTypingJavaCodeCompErr{}

\refPseudoExampleLandPosQDBadTypingJavaCodeCompErr{} provides us with a
meaningful error message: ``String cannot be converted to double.'' To fix this
issue, we would need to change the string to something valid, a number at least
because Java also performs a secret cast, interpreting the \(1\) as a double,
despite our encoding having it be an integer. All code Drasil generates should
be reliably compile-able and usable, and all errors should be noted as Drasil is
used. The issue here lies in that the initial expression was incoherent (and the
Java code was \textit{ill-typed}). So, now, how can we avoid this situation
altogether? We need all expressions to be \textit{well-formed}.

Ultimately, the issue lies in that \Expr{} is not type-safe \cite{Harper2016}
and that we don't capture any knowledge about what it means for expressions to
be \textit{well-typed} (i.e., well-formed). In other words, \Expr{} is not
closed under \textit{preservation}\footnote{\textit{Preservation} is a rule that
evaluation of a language should preserve typing of expressions
\cite{Harper2016}.} and \textit{progress}\footnote{\textit{Progress} is a rule
that says that any well-typed expression is either a value or something that can
be further evaluated \cite{Harper2016}.} \cite{Harper2016}, which means that
during evaluation\footnote{Of course, ``evaluation'' here is also related to the
evaluation of \acs{gool}-generated code.} of expressions, illegal instructions
and type mismatches are possible. Thus, we must make \Expr{} type-safe.

\section{Type-Safe Expressions}
\label{chap:typed-expr:sec:type-safe-expressions}

In order to make \Expr{} type-safe, we must build a type system for it to
restrict valid \Expr{} terms. A system of typing rules that dictate what
well-formed expressions will allow us to determine which expressions are
well-typed or not.

\imptodo{Since Drasil is deeply embedded in Haskell, we were initially tempted
      to use a \acs{gadt} and typed \acs{ttf}, but it comes with too many
      issues.}

\subsection{Example: A \textquotedblleft{}Simple\textquotedblright{} Language}
\label{chap:typed-expr:sec:type-safe-expressions:subsec:example-a-simple-language}

For example, if we had a small ``simple'' language, \(\bb{L}\), that contains
integer and boolean values, with functionality for addition, ``less than''
comparison, conjunction, and if-then-else (ternary operators)\footnote{Assume
the definitions of the functions be total and understood/used under the
conventional sense that mathematicians so often do.}, we might write the syntax
inductively, as follows\footnote{Note that I will be using a traditional
math-oriented syntax definition here, but if we were to transcribe it in
Haskell, we may find differences.}:

\begin{longtable}{ r c c l}
      \(\bb{L}(l)\) & ::=       & \(n\)                                                        & Integers (where \(n\) is any integer) \\
                    & \(\vert\) & \texttt{true}                                                & True                                  \\
                    & \(\vert\) & \texttt{false}                                               & False                                 \\
                    & \(\vert\) & \(l_1\ \texttt{+}\ l_2\)                                     & Addition                              \\
                    & \(\vert\) & \(l_1\ \texttt{<}\ l_2\)                                     & ``Less than'' comparison              \\
                    & \(\vert\) & \(l_1\ \texttt{\land}\ l_2\)                                 & Conjunction                           \\
                    & \(\vert\) & \(\texttt{if}\ l_1\ \texttt{then}\ l_2\ \texttt{else}\ l_3\) & if-then-else (ternary ``if'')         \\
\end{longtable}

Now, we can form expressions, such as:

\begin{equation}
      10
      \label{ex:sl:s:good1}
\end{equation}

\begin{equation}
      23 + (400\ \texttt{+}\ 4000)
      \label{ex:sl:s:good2}
\end{equation}

\begin{equation}
      \texttt{if}\ \texttt{true}\ \texttt{then}\ 95\ \texttt{else}\ 96
      \label{ex:sl:s:good3}
\end{equation}

\begin{equation}
      42\ \texttt{+}\ \texttt{false}
      \label{ex:sl:s:bad1}
\end{equation}

\begin{equation}
      \texttt{if}\ (0\ \texttt{<}\ \texttt{false})\ \texttt{then}\ 1\ \texttt{else}\ \texttt{true}
      \label{ex:sl:s:bad2}
\end{equation}

% Forcibly rename the "equation" environment tags to "expression" for the sake
% of the below discussion.
\Crefname{equation}{Expression}{Expressions}

Now, let's evaluate these expressions.
\Cref{ex:sl:s:good1,ex:sl:s:good2,ex:sl:s:good3} can be calculated with a
conventional understanding of the operations, respectively, as \(10\), \(4423\),
and \(95\). However, \Cref{ex:sl:s:bad1,ex:sl:s:bad2} are worrisome. Regarding
\Cref{ex:sl:s:bad1}, we don't have any conventional sense of addition on
integers with booleans, so evaluation is unclear. In \Cref{ex:sl:s:bad2}, we
have two issues: we're trying to relate an integer with a boolean value, and our
if-then-else construction returns differently-typed values depending on the
condition.

\Crefname{equation}{Equation}{Equations}

Other than modifying the syntax into a convoluted mess to avoid issues like
these (which won't be easy, and might not be possible), we look to type systems
to make all expressions of \(\bb{L}\) sound. The key is in understanding that
there are different ``kinds'' (\textit{types}) of values (\textit{terms}), and
forming a system of figuring out which ones are valid (well-typed) or not
(ill-typed). Thus, first, we must analyze and capture our universe of types of
\(\bb{L}\), \(\tau\):

\begin{longtable}{ r c c l}
      \(\Tau(\tau)\) & ::=       & \(\bb{B}\) & Booleans \\
                     & \(\vert\) & \(\bb{Z}\) & Integers
\end{longtable}

Note that we are restricting the numeric-related operations to strictly
integers. The restriction is only there for simplification of numerics. \(\tau\)
is an enumeration of all permissible \textit{types} of \textit{terms} we can
have in \(\bb{L}\).

Next, we need to add the typing rules. They will restrict our syntax to only
those constructions which are semantically valid. We will do so using inference
judgments, as follows\footnote{Note that since there are no variables, there is
no need to have a context \(\Gamma\) on the left-hand side of each typing
judgment.}:

\begin{equation}
      \left.
      \infer{n : \bb{Z}}{}
      \right.
      \qquad
      \text{(where \(n\) is any integer.)}
      \label{eq:exTR:int}
\end{equation}

\begin{equation}
      \left.
      \infer{\texttt{true} : \bb{B}}{}
      \right.
      \qquad
      \text{True}
      \label{eq:exTR:true}
\end{equation}

\begin{equation}
      \left.
      \infer{\texttt{false} : \bb{B}}{}
      \right.
      \qquad
      \text{False}
      \label{eq:exTR:false}
\end{equation}

\begin{equation}
      \left.
      \infer{(a\ \texttt{+}\ b) : \bb{Z}}
      {a : \bb{Z}  &  b : \bb{Z}}
      \right.
      \qquad
      \text{Addition}
      \label{eq:exTR:addition}
\end{equation}

\begin{equation}
      \left.
      \infer{(a\ \texttt{<}\ b) : \bb{B}}
      {a : \bb{Z}  &  b : \bb{Z}}
      \right.
      \qquad
      \text{``Less than'' comparison}
      \label{eq:exTR:lessThan}
\end{equation}

\begin{equation}
      \left.
      \infer{(a\ \texttt{\wedge}\ b) : \bb{B}}
      {a : \bb{B}  &  b : \bb{B}}
      \right.
      \qquad
      \text{Conjunction}
      \label{eq:exTR:conjunction}
\end{equation}

\begin{equation}
      \left.
      \infer{(\texttt{if}\ b\ \texttt{then}\ x\ \texttt{else}\ y) : \tau}
      {b : \bb{B}  &  x : \tau  &  y : \tau}
      \right.
      \qquad
      \text{if-then-else (ternary ``if'')}
      \label{eq:exTR:ifThenElse}
\end{equation}

So as long as we follow these typing rules while we build our expressions, when
we try to evaluate any of these expressions, we should not arrive at invalid
expressions where evaluation cannot be completed. In other words, so as long as
expressions conform to these typing rules, the language is type-safe:
preservation and progress hold.

Now, we'd like to build a similar system for \Expr{}. However, the
typing-judgment style is not future-proof\qtodo{@JC: can I cite our conversation
here?}, and we'd also like to avoid any potential issues with it. Thus, we look
to building a \textit{bidirectional} type system \cite{Christiansen2013}.

\subsection{Bidirectional Typing}
\label{chap:typed-expr:sec:type-safe-expressions:subsec:bidirectional-typing}

A bidirectional type system is very similar to the traditional typing-judgment
style, except that it replaces typing judgments with two others: a
\textit{checking} judgment and an \textit{inference} judgment
\cite{Christiansen2013}. The checking judgment, \(\Gamma{} \vdash{} e \Leftarrow
\tau{}\), says that the expression \(e\) can be \textit{checked} to be of the
type \(\tau\) within the context \(\Gamma\). The inference judgment, \(\Gamma{}
\vdash{} e \Rightarrow \tau{}\), says that, within the context \(\Gamma\), we
can \textit{infer} the type of expression \(e\), \(\tau\).

Notably, A bidirectional type system allows us to future-proof the type system
we build for \Expr{}, and, later, scale up to the task of typing \ModelExpr{},
where we might need to handle ambiguous type cases that might not be as easy to
deal with in a regular simply-typed system. Hence, we would prefer to build one
from the start.\todo{This subsection seems a bit weak.}

\section{Typing the Expression Language}
\label{chap:typed-expr:sec:typing-the-expression-language}

\begin{pseudohaskell}{Modelling Bidirectional Typing}{modellingBidirectionalTyping}
type TypeError = String

-- | We can only type check 'UID's within a type context relating 'UID's to
-- types since they don't carry any type information.
type TypingContext t = M.Map UID t

inferFromContext :: TypingContext t -> UID -> Either t TypeError
inferFromContext cxt u = maybe
    (Right $ "`" ++ show u ++ "` lacks type binding in context")
    Left
    (M.lookup u cxt)

check :: Typed e t => TypingContext t -> e -> t -> Either t TypeError
check cxt e t = either
    (\infT -> if t == infT
      then Left t
      else Right $ "Inferred type `" ++ show t ++ "` does not match expected type `" ++ show infT ++ "`")
    Right
    (infer cxt e)

class (Eq t, Show t) => Typed e t where
  infer :: TypingContext t -> e -> Either t TypeError
\end{pseudohaskell}

\imptodo{Continue writing here!}



% `infer` is meant to pull type information from 'e's for a specific 'type'
% typeset, 't'. Since we don't have any sort of parameter types in our Expr, I
% chose to keep the 'check' function out of the `Typed` typeclass, but perhaps
% this wasn't the best choice since, to my understanding, infer and check can be
% based on each other (and it's helpful to base them off each other specifically
% in cases where ambiguous types exist). However, pushing 'check' into 'infer'
% isn't particularly difficult.

% Now, why a typeclass? Because we want to be able to type-check various things,
% which might contain systems, with respect to particular various type contexts,
% so having a single name is simpler since they will always be type-checked with
% respect to different types. It's also the same concept, just across different
% expression languages and type systems.

% Now, why the `type TypingContext t = M.Map UID t`? This is because of Expr, but
% I think it's a good thing. Since Expr contains references to `UID`s for certain
% things, such as function calls, symbols, intervals, etc., we need to have a
% typing context so that we can infer the type of various, typed, things. Now,
% this really means that we have to do type checking with the ChunkDB in scope so
% that we can check its symbol table for the types of other UIDs, but I think it
% wouldn't be 'right' to have the ChunkDB in scope, since it's not necessarily
% what we care about, and it also adds a mode of inflexibility (i.e., that we
% can't swap out the types of UIDs or easily do it in smaller places without the
% extra overhead of a ChunkDB instance). Additionally, if we were to go directly
% with a ChunkDB, then it would mean that a ChunkDB would need to be formed
% _before_ we add each new chunk (which is an issue with the current system, but
% less so with the "Upgraded ChunkDB" +
% https://github.com/JacquesCarette/Drasil/issues/2873#issuecomment-957059049 ).
% Thus, we keep it separate, and use a TypingContext instead, to keep track of UID
% type information.

% However, we do ultimately build our TypingContext from the ChunkDBs because I
% wanted to check all of our IMs at once, and all expressions they expose.




% So, now we can add type information to `Expr`, with respect to `Space` as it's
% type-system. I won't add the code here, but I'm referring to building the typing
% rules for inferring the type of an Expr-expression with respect to a
% `Space`-based type-system.




% Here's where the issue with ChunkDBs are highlighted a bit more. Since we don't
% build our ChunkDBs gradually (yet), we would need to create type contexts for
% each chunk as we build them so that they can be type-checked. Thus, to simplify,
% we don't. Rather, we type-check after ChunkDB creation so that we can check
% everything at once, in one go. However, I don't want to hard-code type checking
% for just InstanceModels, so I created a typeclass for things that need to be
% type-checked. Notably, at times, chunks will have a single expression but then
% also expose different kinds of expressions, such as @cd155's NewDEModel, which
% exposes a system of equations.

% ```
% class Typed e t => TypeChecks c e t where
%   -- Why is this a list, you ask? So that we can have multiple expressions type
%   -- checked at once, which a chunk may or may not expose.
%   typeCheckExpr :: c -> [(e, t)]
% ```

% The typeclass is with respect to a particular expression language and
% type-system, but it's not difficult to make it type-system and
% expression-language agnostic, but I think that is something that should be
% automated instead (a case where we would want Drasil to have a
% meta-understanding of this system). 

% Now, we just need to instantiate this for InstanceModels, ModelKinds, and
% everything they are based on.




% So, to sum up, with this system, we have:

% - type checking on the expression level with respect to any type system, and
% type checking done for anything we want to type check which exposes any number
% of things to type-check

% - type checking done post-ChunkDB-creation due to issues with creating a typing
% context for each possible expression without adding too much overhead to
% developers

% - a 'simple' version of bidirectional typing

% One note about the type-checking is that we don't cause a program panic (yet),
% so we could technically merge this and enable the panic later. Of course, we
% might just change how this goes depending on what we think about this.

