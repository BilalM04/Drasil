\chapter{Typing the Expression Language}
\label{chap:typed-expr}

\begin{writingdirectives}
      \item How is \Expr{} used?
      \item What are current problems with \Expr{} usage?
      \item What does it mean for expressions to be well-formed/well-typed?
      \item How does a type system work? How can we build one for \Expr{}?
            \begin{itemize}
                  \item ``Safety = Preservation + Progress'' \cite{Harper2016}
                  \item Why bidirectional type rules over a normal declarative
                        style?
                  \item How can this be implemented in Drasil?
            \end{itemize}
      \item What errors did the type checker currently find?
\end{writingdirectives}

In \Cref{chap:lang-division}, we discussed Drasils single mathematical
expression language and split it into three variants, each specialized for their
intended usage context. As a result, users don't need to worry about using terms
inapplicable in various contexts. However, an issue remains with expressions:
Drasils standard mathematical language (\Expr{}) remains untyped, and, thus
Drasil does not detect malformed expressions, allowing users to make errors that
affect both the problem descriptions in the \acs{srs} and the usability of
generated software. In this chapter, we will focus on improving well-formedness
for the most important context: grounded theories used for code generation.

\section{Expressions, Instance Models, and Data Definitions}
\label{chap:typed-expr:sec:expressions-instance-models-and-data-definitions}

To generate code, Drasil's code generator relies on a series of grounded
theories as part of it's input. There are two kinds of theories that the code
generator uses from the abstracted \acs{srs} template: instance models and data
definitions. Data definitions are, as the name suggests, concrete symbol
definitions using expressions (similar to the \EquationalModel{} \ModelKind{}
variant, discussed in
\Cref{chap:more-theory-kinds:sec:classify-all-the-theories:subsec:equational-models}).
On the other hand, instance models may contain data definitions or any of the
other applicable \ModelKinds{} variants (discussed in
\Cref{chap:more-theory-kinds}, albeit currently limited\footnote{For our
purposes, it's enough to assume that they can expose any number of expressions
usable in code generation.}). In order for the expressions they expose/form to
be usable in code generation, the expressions must be representable in
\acs{gool} somehow\footnote{Since all code generation for Drasil currently goes
through \acs{gool}.}. Thanks to \Cref{chap:lang-division}, \Expr{} has become
the expression language that currently limits mathematical expressions in both
instance models and data definitions to ones with definite values that can be
directly computed on pencil and paper, and in most modern programming languages.
However, translatability to \acs{gool} does not necessarily mean that all the
expressions are actually coherent and usable. At the moment, it is possible to
give Drasils instance models and data definitions invalid \Expr{}s and have
Drasil generate code.

\pseudoExampleLandPosQDBadTyping{}

Take \refCurrentLandPosIMHaskell{} for example. The defining expression of
\(p_\text{land}\), \inlineHs{E.landPosExpr}, is of type \Expr{} and limited to
terms that can be naively translated to \acs{gool} without external knowledge.
If we were to change the defining expression to something incoherent (such as
\(1 + \texttt{``Drasil''}\)\footnote{The sum of the number 1 and string
``Drasil''}, \refPseudoExampleLandPosQDBadTyping{}), we end up with (a) an
algorithm that doesn't exactly make sense, and (b) a generated software source
code that does what we wanted it to do
(\refPseudoExampleLandPosQDBadTypingJavaCode{}), but which isn't actually
compilable software (\refPseudoExampleLandPosQDBadTypingJavaCodeCompErr{}).
Despite the examples simplicity, assuming it was derived from other theories
that somehow went awry, then we should have caught the type error before we
generated code.

\pseudoExampleLandPosQDBadTypingJavaCode{}

\pseudoExampleLandPosQDBadTypingJavaCodeCompErr{}

\refPseudoExampleLandPosQDBadTypingJavaCodeCompErr{} provides us with a
meaningful error message: ``String cannot be converted to double.'' To fix this
issue, we would need to change the string to something valid, a number at least
because Java also performs a secret cast, interpreting the \(1\) as a double,
despite our encoding having it be an integer. All code Drasil generates should
be reliably compile-able and usable, and all errors should be noted as Drasil is
used. The issue here lies in that the initial expression was incoherent (and the
Java code was \textit{ill-typed}). So, now, how can we avoid this situation
altogether? We need all expressions to be \textit{well-formed}. However, Drasil
doesn't have a working understanding of what it means for expressions to be
well-formed.

Ultimately, the issue lies in that \Expr{} is not type-safe \cite{Harper2016}
and that we don't capture any knowledge about what it means for expressions to
be \textit{well-typed} (i.e., well-formed). In other words, \Expr{} is not
closed under \textit{preservation}\footnote{\textit{Preservation} is a rule that
evaluation of a language should preserve typing of expressions
\cite{Harper2016}.} and \textit{progress}\footnote{\textit{Progress} is a rule
that says that any well-typed expression is either a value or something that can
be further evaluated \cite{Harper2016}.} \cite{Harper2016}, which means that
during evaluation\footnote{Of course, ``evaluation'' here is also related to the
evaluation of \acs{gool}-generated code.} of expressions, illegal instructions
and type mismatches are possible. Thus, we must make \Expr{} type-safe.

\section{Type-Safe Expressions}
\label{chap:typed-expr:sec:type-safe-expressions}

In order to make \Expr{} type-safe, we must build a type system for it so that
we can obtain information about which \Expr{} terms are coherent/valid or not. A
system of typing rules that dictate what well-formed expressions will allow us
to determine which expressions are well-typed.

\imptodo{Since Drasil is deeply embedded in Haskell, we were initially tempted
      to use a \acs{gadt} and typed \acs{ttf}, but...}

\subsection{Example: A \textquotedblleft{}Simple\textquotedblright{} Language}
\label{chap:typed-expr:sec:type-safe-expressions:subsec:example-a-simple-language}

For example, if we had a small ``simple'' language, \(\bb{L}\), that contains
integer and boolean values, with functionality for addition, ``less than''
comparison, conjunction, and if-then-else (ternary operators)\footnote{Assume
the definitions of the functions be total and understood/used under the
conventional sense that mathematicians so often do.}, we might write the syntax
inductively, as follows\footnote{Note that I will be using a traditional
math-oriented syntax definition here, but if we were to transcribe it in
Haskell, we may find differences.}:

\begin{longtable}{ r c c l}
      \(\bb{L}(l)\) & ::=       & \(n\)                                                        & Integers (where \(n\) is any integer) \\
                    & \(\vert\) & \texttt{true}                                                & True                                  \\
                    & \(\vert\) & \texttt{false}                                               & False                                 \\
                    & \(\vert\) & \(l_1\ \texttt{+}\ l_2\)                                     & Addition                              \\
                    & \(\vert\) & \(l_1\ \texttt{<}\ l_2\)                                     & ``Less than'' comparison              \\
                    & \(\vert\) & \(l_1\ \texttt{\land}\ l_2\)                                 & Conjunction                           \\
                    & \(\vert\) & \(\texttt{if}\ l_1\ \texttt{then}\ l_2\ \texttt{else}\ l_3\) & if-then-else (ternary ``if'')         \\
\end{longtable}

Now, we can form expressions, such as:

\begin{equation}
      10
      \label{ex:sl:s:good1}
\end{equation}

\begin{equation}
      23 + (400\ \texttt{+}\ 4000)
      \label{ex:sl:s:good2}
\end{equation}

\begin{equation}
      \texttt{if}\ \texttt{true}\ \texttt{then}\ 95\ \texttt{else}\ 96
      \label{ex:sl:s:good3}
\end{equation}

\begin{equation}
      42\ \texttt{+}\ \texttt{false}
      \label{ex:sl:s:bad1}
\end{equation}

\begin{equation}
      \texttt{if}\ (0\ \texttt{<}\ \texttt{false})\ \texttt{then}\ 1\ \texttt{else}\ \texttt{true}
      \label{ex:sl:s:bad2}
\end{equation}

% Forcibly rename the "equation" environment tags to "expression" for the sake
% of the below discussion.
\Crefname{equation}{Expression}{Expressions}

Now, let's evaluate these expressions.
\Cref{ex:sl:s:good1,ex:sl:s:good2,ex:sl:s:good3} can be calculated with a
conventional understanding of the operations, respectively, as \(10\), \(4423\),
and \(95\). However, \Cref{ex:sl:s:bad1,ex:sl:s:bad2} are worrisome. Regarding
\Cref{ex:sl:s:bad1}, we don't have any conventional sense of addition on
integers with booleans, so evaluation is unclear. In \Cref{ex:sl:s:bad2}, we
have two issues: we're trying to relate an integer with a boolean value, and our
if-then-else construction returns differently-typed values depending on the
condition.

\Crefname{equation}{Equation}{Equations}

Other than modifying the syntax into a convoluted mess to avoid issues like
these (which won't be easy, and might not be possible), we look to type systems
to make all expressions of \(\bb{L}\) sound. The key is in understanding that
there are different ``kinds'' (\textit{types}) of values (\textit{terms}), and
forming a system of figuring out which ones are valid (well-typed) or not
(ill-typed). Thus, first, we must analyze and capture our universe of types of
\(\bb{L}\), \(\tau\):

\begin{longtable}{ r c c l}
      \(\Tau(\tau)\) & ::=       & \(\bb{B}\) & Booleans \\
                     & \(\vert\) & \(\bb{Z}\) & Integers
\end{longtable}

Note that we are restricting the numeric-related operations to strictly
integers. The restriction is only there for simplification of numerics. \(\tau\)
is an enumeration of all permissible \textit{types} of \textit{terms} we can
have in \(\bb{L}\).

Next, we need to add the typing rules. They will restrict our syntax to only
those constructions which are semantically valid. We will do so using inference
judgments, as follows\footnote{Note that since there are no variables, there is
no need to have a context \(\Gamma\) on the left-hand side of each typing
judgment.}:

\begin{equation}
      \left.
      \infer{n : \bb{Z}}{}
      \right.
      \qquad
      \text{(where \(n\) is any integer.)}
      \label{eq:exTR:int}
\end{equation}

\begin{equation}
      \left.
      \infer{\texttt{true} : \bb{B}}{}
      \right.
      \qquad
      \text{True}
      \label{eq:exTR:true}
\end{equation}

\begin{equation}
      \left.
      \infer{\texttt{false} : \bb{B}}{}
      \right.
      \qquad
      \text{False}
      \label{eq:exTR:false}
\end{equation}

\begin{equation}
      \left.
      \infer{(a\ \texttt{+}\ b) : \bb{Z}}
      {a : \bb{Z}  &  b : \bb{Z}}
      \right.
      \qquad
      \text{Addition}
      \label{eq:exTR:addition}
\end{equation}

\begin{equation}
      \left.
      \infer{(a\ \texttt{<}\ b) : \bb{B}}
      {a : \bb{Z}  &  b : \bb{Z}}
      \right.
      \qquad
      \text{``Less than'' comparison}
      \label{eq:exTR:lessThan}
\end{equation}

\begin{equation}
      \left.
      \infer{(a\ \texttt{\wedge}\ b) : \bb{B}}
      {a : \bb{B}  &  b : \bb{B}}
      \right.
      \qquad
      \text{Conjunction}
      \label{eq:exTR:conjunction}
\end{equation}

\begin{equation}
      \left.
      \infer{(\texttt{if}\ b\ \texttt{then}\ x\ \texttt{else}\ y) : \tau}
      {b : \bb{B}  &  x : \tau  &  y : \tau}
      \right.
      \qquad
      \text{if-then-else (ternary ``if'')}
      \label{eq:exTR:ifThenElse}
\end{equation}

So as long as we follow these typing rules while we build our expressions, when
we try to evaluate any of these expressions, we should not arrive at invalid
expressions where evaluation cannot be completed. In other words, so as long as
expressions conform to these typing rules, the language is type-safe:
preservation and progress hold.

Now, we'd like to build a similar system for \Expr{}. However, one of the issues
with the traditional declaration-style is that expressions made without explicit
type annotations might have ambiguous types should we try to infer one
\cite{nlab:bidirectional_typechecking}. While we don't have expect any of these
scenarios to occur with \Expr{}, we might if we also added type-checking to
\ModelExpr{}, where we would like to have higher-order functions and function
abstractions. Thus, we prefer to build the typing rules with a modern,
future-proof scheme that will scale against our expectations\qtodo{@JC: can I
cite our conversation here?}: \textit{bidirectionally}.

\subsection{Bidirectional Type Rules}
\label{chap:typed-expr:sec:type-safe-expressions:subsec:bidirectional-type-rules}

Bidirectional typing rules break the declarative typing judgments into two
typing judgments: a \textit{check} judgment and an \textit{inference} judgment
\cite{Christiansen2013}. The checking judgment, \(\Gamma{} \vdash{} e \Leftarrow
\tau{}\), says that the expression \(e\) can be \textit{checked} to be of the
type \(\tau\) within the context \(\Gamma\). The inference judgment, \(\Gamma{}
\vdash{} e \Rightarrow \tau{}\), says that, within the context \(\Gamma\), we
can \textit{infer} the type of expression \(e\), \(\tau\). Checking and
inferencing may be mutually recursive \textemdash{} this is helpful for type
checking in cases where expressions are ambiguous and may take on many shapes
(i.e., may be polymorphic) \cite{nlab:bidirectional_typechecking}.

\section{Typing the Expression Language}
\label{chap:typed-expr:sec:typing-the-expression-language}

With our goal in mind and our tools in hand, we need to capture two things about
\Expr{}:
\begin{itemize}
      \item the type universe its term belong to,
      \item and the bidirectional typing rules and algorithm.
\end{itemize}

\subsection{Type Universe}
\label{chap:typed-expr:sec:typing-the-expression-language:subsec:type-universe}

Thankfully, there already exists an unused type universe, \Space{}
(\refOriginalSpaceHaskell{}), in Drasil that we can extend\todo{Move below
pseudohaskell snippet of Space to the appendix, and reference it here} and start
using as intended.

\begin{longtable}{ r c c l}
      \(\texttt{Space}(s)\) & ::=       & \(\bb{Z}\)                                  & Integers   \\
                            & \(\vert\) & \(\bb{Q}\)                                  & Rationals  \\
                            & \(\vert\) & \(\bb{R}\)                                  & Reals      \\
                            & \(\vert\) & \(\bb{N}\)                                  & Naturals   \\
                            & \(\vert\) & \(\bb{B}\)                                  & Booleans   \\
                            & \(\vert\) & \(\texttt{Ch}\)                             & Characters \\
                            & \(\vert\) & \(\texttt{String}\)                         & Strings    \\
                            & \(\vert\) & \(\texttt{Vector}(s)\)                      & Vectors    \\
                            & \(\vert\) & \(\texttt{Matrix}(s)\)                      & Matrices   \\
                            & \(\vert\) & \((s_1, s_2, \ldots{}, s_n) \rightarrow s\) & Functions  \\
\end{longtable}

\begin{pseudohaskell}{Type Universe}{pseudoTypeUniverse}
data Space =
    Integer
  | Rational
  | Real
  | Natural
  | Boolean
  | Char
  | String
  | Radians
  | Vect Space -- TODO: Length for vectors?
  | Matrix Int Int Space
  | Array Space
  | Actor String
  | DiscreteD [Double]
  | DiscreteS [String] --ex. let Meal = {"breakfast", "lunch", "dinner"}
  | Function (NE.NonEmpty Primitive) Primitive
  | Void
  deriving (Eq, Show)
\end{pseudohaskell}

\subsection{Type Rules}
\label{chap:typed-expr:sec:typing-the-expression-language:subsec:type-rules}

\imptodo{typing rules, once solidified}

Finally, after having built our type universe and typing rules, we may implement
the bidirectional type checking and inferencing in Drasil.

\subsection{Implementation}
\label{chap:typed-expr:sec:typing-the-expression-language:subsec:implementation}

Thus, we need to build out the typing context, \(\Gamma\). \(\Gamma\) is the set
of expression terms for which we already know the type of. While \(\Gamma\)
might include whole expressions, the most important information we need while
traversing \Expr{}s is information about the types associated with \UID{}s
(since \Expr{}s, when referring to chunks, only carry \acs{uid} information,
such as for symbols and function applications). Since each \UID{} relates to a
symbol with a unique type, we can build a map that carries everything for us.

\begin{pseudohaskell}{Typing Context, \(\Gamma\)}{pseudoTypingContext}
type TypingContext t = M.Map UID t
\end{pseudohaskell}

Now we may build our type checker. As we will want to implement type checking
for any expression types (such as for \CodeExpr{} and \ModelExpr{} eventually)
with respect to any type universe (not just \Space{}), we prefer to build the
bidirectional type checker with a typeclass\footnote{Note: we needed to enable
the multi-parameter type-classes \acs{ghc} language extension to create and use
this type class, at times with the flexible contexts extension too.}\todo{cite
flexible contexts and multi-param type-classes in footnote}, instantiated as
needed. Using a typeclass with 2 parameters (\(e\) and \(t\)) allows us to build
out a bidirectional type checker with respect to any language, \(e\), and type
universe, \(t\).

\begin{pseudohaskell}{Modelling Bidirectional Type Checking}{pseudoModellingBidirectionalTypeChecking}
-- | Build a bidirectional type checker for your expression language, e, with
--   respect to a specific type universe, t.
class (Eq t, Show t) => Typed e t where
  
  -- | Given a typing context and an expression, infer a unique type or explain
  --   what went awry.
  infer :: TypingContext t -> e -> Either t TypeError

  -- | Given a typing context, an expression, and an expected type, check if the
  --   expression can satisfy the expectation.
  check :: TypingContext t -> e -> t -> Either t TypeError
\end{pseudohaskell}

At the moment, \inlineHs{TypeError} is merely a type alias for a
\inlineHs{String}, for which we manually typeset in a reasonably okay fashion.
Eventually, it should be replaced with a whole ``breadcrumbs''-like system that
elegantly displays a traversal over an expression, showing where type checking
may have gone awry and why an expression is ill-typed.

Now we may build out the bidirectional type checker for \Expr{}: \todo{insert
code snippet for Typed instance for Expr \& Space}. All that's left is to
actually use the type checker.

While we would prefer to localize type-checking to the instant applicable chunks
are created (and expressions too), we unfortunately aren't able to. As
expressions are formed and symbols are referenced, the whole symbol type context
is missing. At the moment, Drasil gathers all chunks at once, registers them in
memory, and then performs various ``checks'' and generation steps to produce
software artifacts. In order to build the type context, we would need to build
it manually, in a very tedious fashion, for each expression we build. However,
this idea does not scale very well. In order to localize type-checking without
the extra work, we would need to make our chunk registration gradual and add a
feature for exposing assertions that needs to be asserted/proven before
registration in memory\footnote{We will take steps towards this in
\Cref{chap:storingChunks}, but this task will largely be left for future work.}.
To make a compromise, we will settle for type-checking just before code and
\acs{srs} generation, so that we can notify Drasil-users of any issues and stop
generation. With this information in mind, we need to be able to extract all
expressions and expected types, and relations from our \InstanceModel{}s and
\DataDefinition{}s.

\begin{pseudohaskell}{Requiring Type-checking Constraint}{pseudoRequiringTypecheckingConstraint}
-- | For all containers, c, which contain typed expressions, e, against a
--   specific type universe, t, expose all expressions and relations that need 
--   to be type-checked.
class Typed e t => RequiresChecking c e t where
  -- | All things that need type checking.
  requiredChecks :: c -> [(e, t)]
\end{pseudohaskell}

With \inlineHs{RequiresChecking}, we have a typeclass for any instance of a
type, \(c\), which may contain any number of expressions of type \(e\) that are
expected to be type-checked w.r.t. a specific type from a type universe \(t\).
By instantiating this typeclass for \DataDefinition{}s, we expose a single
relation to be type-checked: that a specific \QDefinition{} is well-formed.
Interestingly, by instantiating this typeclass for \InstanceModel{}s, we
potentially expose more than one expression, depending on the \ModelKind{}
variant. Recall from \Cref{chap:modelkinds} that any of our theories (including
\InstanceModel{}s) may take on any of our theory kinds (\ModelKinds{}). For the
complicated theories that might stack have a stack of expressions (such as
equational realms,
\Cref{chap:more-theory-kinds:sec:classify-all-the-theories:subsec:equational-realms}),
we are able to type-check them all, individually. For other theories, such as
the new \acs{ode} model variant, \NewDEModel{} (\DifferentialModel{}), we may
also have a solution system of equations \cite{Chen2022MEng} that need to be
type-checked. Moving on, we may finally plug in our type-checker!

\begin{pseudohaskell}{Type-checking a System}{pseudoTypeCheckingASystem}
typeCheckSI :: SystemInformation -> IO ()
typeCheckSI
  (SI _ _ _ _ _ _ ims dds _ _ _ _ _ _ chks _ _)
  = do
    -- build a variable context (a map of UIDs to "Space"s [types])
    let cxt = M.map (\(dict, _) -> dict ^. typ) (symbolTable chks)

    -- dump out the list of variables
    putStr "Symbol Table: "
    print $ M.toList cxt

    putStrLn "=====[ Start type checking ]====="
    let
      exprSpaceTups :: (HasUID t, RequiresChecking t Expr Space) => [t] -> [(UID, [(Expr, Space)])] 
      exprSpaceTups = map (\t -> (t ^. uid, requiredChecks t))

    -- grab all type-check-able expressions (w.r.t. Space) from DDs and IMs
    let toChk = exprSpaceTups ims ++ exprSpaceTups dds

    let (notChkd, chkd) = partition (\(_, exsps) -> null exsps) toChk

    mapM_ (\(t, _) -> putStrLn $ "WARNING: `" ++ show t ++ "` does not expose any expressions to type check.") notChkd

    -- type check them
    let chkdd = map (second (map (uncurry (check cxt)))) chkd

    -- format 'ok' messages and 'type error' messages, as applicable
    let formattedChkd :: [Either [Char] ([Char], [Either Space TypeError])]
        formattedChkd = map 
                          (\(t, tcs) -> if any isRight tcs
                            then Right ("`" ++ show t ++ "` exposes ill-typed expressions!", filter isRight tcs)
                            else Left $ "`" ++ show t ++ "` OK!") 
                          chkdd

    mapM_ (either
            putStrLn
            (\(tMsg, tcs) -> do
              putStrLn tMsg
              mapM_ (\(Right s) -> do
                putStr "  - ERROR: " -- TODO: we need to be able to dump the expression to the console so that we can identify which expression caused the issue
                putStrLn $ temporaryIndent "  " s) tcs
              )
      ) formattedChkd
    putStrLn "[ Finished type checking ]"
\end{pseudohaskell}

By using this function anywhere before our code generation step, we will be able
to type-check all of our instance models and data definitions exposed relations
and expressions. As of writing, we found enough such that it's best to keep
type-checking done en masse, as it is right now, and without causing a compiler
panic for our case studies. Notably, by adding type-checking to Drasil, we also
bring into question the coherence of our \acs{srs} documents. By forcing the
\acs{srs} abstraction to provide sufficiently coherent information to generate
code, we also have an equal assurance that the \acs{srs} is sufficiently
coherent for developers to manually build similar software artifacts.

\imptodo{Continue writing here!}







% Now, why the `type TypingContext t = M.Map UID t`? This is because of Expr, but
% I think it's a good thing. Since Expr contains references to `UID`s for certain
% things, such as function calls, symbols, intervals, etc., we need to have a
% typing context so that we can infer the type of various, typed, things. Now,
% this really means that we have to do type checking with the ChunkDB in scope so
% that we can check its symbol table for the types of other UIDs, but I think it
% wouldn't be 'right' to have the ChunkDB in scope, since it's not necessarily
% what we care about, and it also adds a mode of inflexibility (i.e., that we
% can't swap out the types of UIDs or easily do it in smaller places without the
% extra overhead of a ChunkDB instance). Additionally, if we were to go directly
% with a ChunkDB, then it would mean that a ChunkDB would need to be formed
% _before_ we add each new chunk (which is an issue with the current system, but
% less so with the "Upgraded ChunkDB" +
% https://github.com/JacquesCarette/Drasil/issues/2873#issuecomment-957059049 ).
% Thus, we keep it separate, and use a TypingContext instead, to keep track of UID
% type information.

% However, we do ultimately build our TypingContext from the ChunkDBs because I
% wanted to check all of our IMs at once, and all expressions they expose.





% So, to sum up, with this system, we have:

% - type checking on the expression level with respect to any type system, and
% type checking done for anything we want to type check which exposes any number
% of things to type-check

% - type checking done post-ChunkDB-creation due to issues with creating a typing
% context for each possible expression without adding too much overhead to
% developers

% - a 'simple' version of bidirectional typing

% One note about the type-checking is that we don't cause a program panic (yet),
% so we could technically merge this and enable the panic later. Of course, we
% might just change how this goes depending on what we think about this.

