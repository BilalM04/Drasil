\begin{center}
    \textbf{Sorts Legend}
    \begin{tabular}{ l l }
        \textbf{Numerics($\Tau$)} &: any numeric type \\
        \textbf{NumericsWithNegation($\Tau$)} &: any signed numeric type
    \end{tabular}
    
    \todo{These might need to be replaced with variants for Reals/Integers}
\end{center}

\textbf{Vectors}

As of right now, Drasil/GOOL only supports lists and arrays as ``code types'', 
which would be the representations used for representing ``vectors'' in Drasil.

\todo{Do we want to have the length of our vectors as a type argument?}

For now, the below type rules define vectors with Haskell lists. We can choose to
create our own type with the length of the vector as a parameter -- likely going
``too far into Haskell''.

\textbf{Functions}

Presently, functions are defined through ``QDefinitions'', where a list of
UIDs used in an expression are marked as the parameters of the function. Function
``calls''/applications are captured in ``Expr'' (the expression language) by
providing a list of input expressions and a list of named inputs (expressions) -- 
$f(x,y,z,a="b")$.

\todo{define criteria for what a well-formed expression language should provide}

\todo{Quantities discussion -- remaining untyped}

A few solutions:

\begin{enumerate}

    \item Leave expressions in general untyped in Haskell, and rely on calculating
          the ``space'' of an expression dynamically to ensure that expressions are
          well-formed. If runtime (drasil's compiling-knowledge-time) type analysis
          is ever needed, this will prove much easier to use in general.
    
    \item Push the typing rules into Haskell via Generalized Algebraic Data Types (GADTs).
          Here, a larger question appears regarding functions -- how should we handle
          function creation, application, and typing?
          
          \begin{enumerate}

              \item Currying and applying arguments (allowing partial function applications):
                    This would work well if we only generated functional languages, but it might
                    prove problematic for GOOL if expressions are left with partial function
                    applications.

          \end{enumerate}
          
\end{enumerate}

\textbf{Type Rules}

\begin{enumerate}

    \item Completeness:
        \newrule{}
            {\ofTy{Complete[]}{Completeness}}
        
        \newrule{}
            {\ofTy{Incomplete[]}{Completeness}}

    \item AssocOp:
        \begin{enumerate}
            \item Numerics:
                \newrule{\numericTy{x}}
                    {\ofTy{Add[]}{AssocOp x}}
        
                \newrule{\numericTy{x}}
                    {\ofTy{Mul[]}{AssocOp x}}
    
            \item Bool:
                \newrule{}
                    {\ofTy{And[]}{AssocOp Bool}}
        
                \newrule{}
                    {\ofTy{Or[]}{AssocOp Bool}}
        \end{enumerate}

    \item UnaryOp:
        \begin{enumerate}
            \item Numerics:
                \newrule{\negNumericTy{x}}
                    {\ofTy{Neg[]}{UnaryOp x x}}

                \newrule{\negNumericTy{x}}
                    {\ofTy{Abs[]}{UnaryOp x x}}
                
                \newrule{\numericTy{x}}
                    {\ofTy{Exp[]}{UnaryOp x Real}}
                
                For Log, Ln, Sin, Cos, Tan, Sec, Csc, Cot, Arcsin, Arccos, Arctan, and Sqrt, please use the following template, replacing ``$\$TRG$'' with the desired operator:
                \newlblrule{}
                    {\ofTy{\$TRG[]}{UnaryOp Real Real}}{eqn:unOpTemplate}

                \newrule{}
                    {\ofTy{RtoI[]}{UnaryOp Real Integer}}
                
                \newrule{}
                    {\ofTy{ItoR[]}{UnaryOp Integer Real}}
            
                \newrule{}
                    {\ofTy{Floor[]}{UnaryOp Real Integer}}

                \newrule{}
                    {\ofTy{Ceil[]}{UnaryOp Real Integer}}
                
                \newrule{}
                    {\ofTy{Round[]}{UnaryOp Real Integer}}
                
                \newrule{}
                    {\ofTy{Trunc[]}{UnaryOp Real Integer}}
                
            \item Vectors:
                \newrule{\negNumericTy{x}}
                    {\ofTy{NegV[]}{UnaryOp [x] [x]}}

                \newrule{\numericTy{x}}
                    {\ofTy{Norm[]}{UnaryOp [x] Real}}

                \newrule{\ty{x}}
                    {\ofTy{Dim[]}{UnaryOp [x] Integer}}

            \item Booleans:
                \newrule{}
                    {\ofTy{Not[]}{UnaryOp Bool Bool}}

        \end{enumerate}

    \item BinaryOp:
        \begin{enumerate}
            \item Arithmetic:
                \newrule{}
                    {\ofTy{FracI[]}{BinaryOp Integer Integer Integer}}
 
                \newrule{}
                    {\ofTy{FracR[]}{BinaryOp Real Real Real}}

                \todo{modulo, remainder, etc.}

            \item Bool:
                \newrule{}
                    {\ofTy{Impl[]}{BinaryOp Bool Bool Bool}}
                
                \newrule{}
                    {\ofTy{Iff[]}{BinaryOp Bool Bool Bool}}
                
            \item Equality:
                \newrule{\ty{x}}
                    {\ofTy{Eq[]}{BinaryOp x x Bool}}
        
                \newrule{\ty{x}}
                    {\ofTy{NEq[]}{BinaryOp x x Bool}}
            
            \item Ordering:
                \newrule{\numericTy{x}}
                    {\ofTy{Lt[]}{BinaryOp x x Bool}}
        
                \newrule{\numericTy{x}}
                    {\ofTy{Gt[]}{BinaryOp x x Bool}}
            
                \newrule{\numericTy{x}}
                    {\ofTy{LEq[]}{BinaryOp x x Bool}}
        
                \newrule{\numericTy{x}}
                    {\ofTy{GEq[]}{BinaryOp x x Bool}}
            
            \item Indexing:
                \newrule{\ty{x}}
                    {\ofTy{Index[]}{BinaryOp [x] Integer x}}
            
            \item Vectors: \todo{discuss vectors in general}
                \newrule{\numericTy{x}}
                    {\ofTy{Cross[]}{BinaryOp [x] [x] [x]}}
        
                \newrule{\numericTy{x}}
                    {\ofTy{Dot[]}{BinaryOp [x] [x] x}}
                
                \newrule{\numericTy{x}}
                    {\ofTy{Scale[]}{BinaryOp [x] x [x]}}

        \end{enumerate}
    
    \item RTopology:
        \newrule{}
            {\ofTy{Discrete[]}{RTopology}}

        \newrule{}
            {\ofTy{Continuous[]}{RTopology}}
    
    \item DomainDesc:
        \todo{oddity: topology appears as a constructor arg and signature arg but can desync -- can we just remove the constructor arg?}

        \newrule{\ofTy{top}{$\tau_1$} & \ofTy{bot}{$\tau_2$} & \ofTy{s}{Symbol} & \ofTy{rtop}{RTopology}}
            {\ofTy{BoundedDD[s, rtop, top, bot]}{DomainDesc Discrete $\tau_1$ $\tau_2$}}

        \newrule{\ty{topT} & \ty{botT} & \ofTy{s}{Symbol} & \ofTy{rtop}{RTopology}}
            {\ofTy{AllDD[s, rtop]}{DomainDesc Continuous topT botT}}

    \item Inclusive:
        \newrule{}
            {\ofTy{Inc[]}{Inclusive}}

        \newrule{}
            {\ofTy{Exc[]}{Inclusive}}

    \item RealInterval:
        \newrule{\ty{a} & \ty{b} & \ofTy{top}{(Inclusive, a)} & \ofTy{bot}{(Inclusive, b)}}
            {\ofTy{Bounded[top, bot]}{RealInterval a b}}

        \newrule{\ty{a} & \ty{b} & \ofTy{top}{(Inclusive, a)}}
            {\ofTy{UpTo[top]}{RealInterval a b}}

        \newrule{\ty{a} & \ty{b} & \ofTy{bot}{(Inclusive, b)}}
            {\ofTy{UpFrom[bot]}{RealInterval a b}}

\end{enumerate}
