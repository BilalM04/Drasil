\begin{itemize}
    \item UIDs
          \intodo{Expand}
    \item Multiple maps from UIDs to single types
          \intodo{Expand}
    \item Problems occur:
          \begin{itemize}
              \item UID collisions
              \item Difficult to ascertain what a specific chunk type is from a
                    UID
              \item ``ChunkDB'' is not a stable core across Drasil-like projects
                    (ones that thrive on the same ``knowledge-based programming''
                    ideology). ChunkDBs are essentially the ``scope'' of a system.
          \end{itemize}
    \item Solution:
          \begin{itemize}
              \item Merge the maps!
              \item The key would be the same; a UID.
              \item The value type?
              \item An existentially quantified Data.Typeable.Typeable!
              \item e.g., ``data Chunk = forall a. Typeable => Chunk a''
          \end{itemize}
    \item But wait! We're missing a few things from chunks:
          \begin{itemize}
              \item What knowledge does the chunk rely on already having been
                    ``registered'' in the database and ready?
              \item They should have UIDs; where's our guarantee?
              \item Debugging will be difficult; need an interface to dump all
                    information of a chunk quickly.
          \end{itemize}
    \item Ok, revise: ``data Chunk = forall a. (Typeable a, HasUID a,
          HasChunkRefs a, Dumpable a) => Chunk a''
    \item Ok, much better now.
    \item Or is it? Still many problems!
          \begin{itemize}
              \item How do we explain ``Data.Typeable''?
              \item And ``HasUID''?
              \item And ``HasChunkRefs''?
              \item And ``Dumpable''?
          \end{itemize}
    \item Well, at the very least, now we're able to merge the ``chunk'' maps and
          fix many of the pre-existing problems (we're almost there!). However,
          now we're relying too much on Haskell. How do we explain those parts?
    \item  \intodo{Also, what are UIDs? TBD!}
\end{itemize}

\section{Future Work}

\subsection{Encodings}

\begin{itemize}
    \item With the above new definition of ``chunks'', they still remain a very
          vague idea, and still \textit{deeply embedded} (a place to recognize an
          encoding might be appropriate!) in Haskell.
    \item What are the kinds of chunks that can exist? What can be in a chunk,
          and what are we missing from the existing list of chunks?
    \item The problem with that is that we lose a lot of information by writing
          Haskell, and leaving the knowledge in the form of Haskell.
    \item We need to de-embed all chunks so that we can obtain a tangible
          understanding of them.
    \item Through de-embedding the chunks, we will also be forced to de-embed
          everything with it. This is including the ways in which we transform
          and generate ``new''-ish knowledge (not necessarily new types/kinds of
          knowledge, but new instances of types).
\end{itemize}
