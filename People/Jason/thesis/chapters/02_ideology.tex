\chapter[Ideology]{Ideology\footnotemark}
\footnotetext{Or, at least, my understanding of a relevant software development ideology.}
\label{chap:ideology}

All software tells a story. Programs made to sanitize data contain a story of
what data needs adjusting and how it can be done. Programs made to store and
retrieve data from textual commands contain a story of how data can be stored
and retrieved. In these stories, we find we commonly use similar terminology and
ideas, which is why shared libraries exist. However, shared libraries typically
only share reusable code fragments, not necessarily the meta-level information
about what each component is and how it can be appropriately used. As such, some
might question the validity of the knowledge it pulls from. Additionally, the
library might not be readily accessible to your preferred programming language,
requiring you to create a \ACF{ffi}, which is often quite brittle and expensive
due to demanding complex compatibility analysis for each change. Hence, we often
look towards mature libraries and frameworks to underpin our projects, but
typically without strong guarantee that using the libraries together is safe.

For example, the sinking of the Vasa ship \cite{wiki:Vasa_ship} was partially
caused by different teams working together but using different ``feet'' units
(the Swedish foot is 12'' while the Amsterdam foot is 11'') resulting in
unexpected weight distribution, contributing to its demise. Similarly, when the
Mars Climate Orbiter travelled to Mars, it met its demise very early due to a
navigation issue \cite{Siddiqi2018}. The commands sent from Earth used English
units (specifically, pound-seconds) while the orbiter assumed that it would
receive commands using the metric system (Newton-seconds). As such, the orbiter
missed it's intended orbit altitude, falling into the Martian atmosphere, and
ultimately disintegrating due to atmospheric stress. Lockheed Martin built the
orbiter control tool without properly conforming to \acsp{nasa} \ACF{sis}.

In both examples, the issue lies in the \textit{communication} between the story
and the developers, highlighted by demise of both implementations. Of course,
most software is not critical, and issues in most software will not result in an
orbiter disintegrating in Martian atmosphere, but, there is something that we
can learn: communication and synchronization is vital for problems and execution
of their solutions. In both examples, experts already had a stable understanding
of the ``story'' and how things should have panned out every step of the way.
Experts knew how each individual component should have interacted and had sound
rationale for why and how it worked, and how all the components together fit the
requirements of the coherent and cohesive story.

\subsubsection{Thoughts of Generation}

For stories where the end product is software, unlike the Vasa, we can remedy
the communication issue partially by unifying it under one cohesive story.
\Aclp{srs} play a large role in unifying communication of software needs.
However, the communication of the software requirements into the final software
product is still brittle, as it typically heavily relies on manual labour to
translate it into software. It is not yet simple enough to reliably produce
error-free programs which satisfy a precisely defined set of requirements.

So, now we wonder: why is it still not simple enough? Our end-goal should be
assembly-line style engineering of the software \cite{well-understood}. Asides
from human-error, one large issue is the communication itself is very sparse in
meta-level information and doesn't contain any strong guarantees of coherence.
To remedy this, we look to codifying subsets of natural language (English) used
to communicate ideas, and the rules that ensure that phrases make sense. In
other words, we look towards additionally communicating the meaning of the words
we would write down in our software specifications documents. Through
sufficiently communicating all relevant pieces of information about a story and
how that story relates to software, we should then be able to \textit{generate}
conforming software artifacts. The generated software is then traceable to its
foundations and can be easily kept in synchronization (i.e., maintained) with
its story through merely re-generating it. Furthermore, similar to shared
libraries, reusability of codified knowledge is strong as well, because codified
terminology can also be similarly shared. However, unlike shared pieces of code,
shared pieces of knowledge is even more reusable, in that it can be translated
into other forms (including programming languages, where applicable).

To my understanding, Drasil \cite{Drasil2021} explores this ideology, focusing
on generating scientific software from user-described scientific problems using
Drasil-understood terminology (i.e., ones that a scientific domain expert
previously encoded).
