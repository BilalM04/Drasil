\chapter{Code Block Generation}
Jupyter Notebooks are valued for their effectiveness in writing and revising 
code for data research. They allow code to be written in discrete blocks (or 
``cells"), which can be executed separately, as opposed to writing and running 
a whole program \cite{jupyterNotebookUsage}. This allows for a mix of content 
types with code to better present information. 

In Chapter~\ref{chap:nbprinter}, we cover two types of metadata in Jupyter 
Notebooks: one type is necessary for forming the notebook, while the other is 
required to create cells for the contents. We explain how to generate the 
metadata and create a Markdown cell. When generating SRS, we do not need to 
worry about generating code blocks since SRS does not include any code. 
However, when creating lesson plans, we may want to integrate real examples 
that involve code. As we are now combining text and code in a document, we need 
to address the following questions before generating the right type of cell: i) 
what type of cell should we use, Markdown or code? and ii) how do we know when 
to end a cell and start a new one? That is, how do we determine where to split 
the contents into cells?
 
To begin, we need to consider the conceptual definition of a cell in Jupyter 
Notebooks. A cell is essentially a standalone unit of information or code that 
can be executed independently. In other words, it is a unit of content within 
the notebook \cite{cellsseparation}. A cell can contain either text or code and 
can span multiple lines. Understanding the relationship between cells and their 
contents is crucial for implementing an effective splitting strategy. By 
identifying natural boundaries within the text or code and recognizing the unit 
of the contents, we can determine where to split the contents into cells.

In this chapter, we will discuss different approaches and implementations for 
splitting the contents and generating the appropriate type of cells.

\section{Unit of Contents}
\subsection{Section-level}
When considering what would be the appropriate unit of content for splitting, 
one might first think of paragraphs or sections. In the source language of 
Drasil, since a document is made up of sections (as seen in 
Code~\ref{code:drasil-lang-document}), it may appear reasonable to split these 
sections into individual cells. However, the nested structure of Drasil 
documents, where each \macblue{Section} is composed of a list of 
\macblue{Contents} and \macblue{Section}s (as demonstrated in 
Code~\ref{code:section}), does not align well with the sequential flow of a 
Jupyter Notebook. To address this issue, we flatten the structure of the Drasil 
document by making each section and subsection an independent 
\macblue{Section}. 

For example, Code~\ref{code:IntroSec} defines the Introduction section, where 
the original nested structure (lines 1-12) comprises a list of subsections, 
while in the flattened version (lines 13-21), each subsection is self-contained 
and has its own type. Code~\ref{code:DocSection} further illustrates that each 
section is independent after the changes.

\begin{listing}[h]
	\caption{Source code for Definition of Introduction}
	\label{code:IntroSec}
	\begin{lstlisting}[language=haskell1]
	-- Nested Structure
	-- | Introduction section. Contents are top level 
	-- followed by a list of subsections.
	data IntroSec = IntroProg Sentence Sentence [IntroSub]
		
	-- | Introduction subsections.
	data IntroSub where
		IPurpose :: [Sentence] -> IntroSub
		IScope   :: Sentence -> IntroSub
		IChar    :: [Sentence] -> [Sentence] -> [Sentence] -> IntroSub
		IOrgSec  :: Sentence -> CI -> Section -> Sentence -> IntroSub
	
	-- Flatten Structure
	-- | Introduction section.
	data IntroSec = IntroProg Sentence Sentence
	
	-- | Introduction subsections.
	newtype IPurpose = IPurposeProg [Sentence] 
	newtype IScope = IScopeProg Sentence 
	data IChar = ICharProg [Sentence] [Sentence] [Sentence]
	data IOrgSec = IOrgProg Sentence CI Section Sentence
	\end{lstlisting}
\end{listing}

\begin{listing}[h]
	\caption{Pseudocode for Definition of DocSection}
	\label{code:DocSection}
	\begin{lstlisting}[language=haskell1]
		-- Nested Structure
		data DocSection = TableOfContents
										| RefSec RefSec
										| IntroSec IntroSec
										| StkhldrSec StkhldrSec
										...
		
		-- Flatten Structure
		data DocSection = TableOfContents TableOfContents
										| RefSec RefSec
										| TUnits TUnits
										| TSymb TSymb
										| TAandA TAandA
										| IntroSec IntroSec
										| IPurposeSub IPurposeSub
										| IScopeSub IScopeSub
										| ICharSub ICharSub
										| IOrgSub IOrgSub
										...
		
	\end{lstlisting}
\end{listing}
 
While flattening the structure of a document can allow for it to be split into 
individual cells by sections, there are limitations to this approach. Splitting 
the contents at the section level might not always be the most effective 
approach. It's possible that certain sections might be too long to fit 
comfortably in a single cell. Moreover, when working with documents that 
combine text and code (such as lesson plans), section-level splitting may not 
be appropriate due to the different types of cells needed for text and code. 
Therefore, a better approach is needed.

\subsection{LayoutObj-level}
In Jupyter Notebook, a cell can be seen as a self-contained unit of 
information, and it can contain multiple types of content, such as text, code, 
and figures. To determine the appropriate unit of content for splitting, we 
need to consider the content itself and what makes sense in terms of its 
structure and organization.  Although a cell might not always be the most 
appropriate unit of conent for splitting, it is somehow the lowest level of 
``display content" that conveys a coherent piece of information 
\cite{cellsseparation}. Therefore, splitting the content based on logical units 
of information might be a more effective approach rather than using sections as 
the sole criterion. 

In previous chapters, we discussed how Drasil handles different types of 
content through the use of the \macblue{RawContent} data type, which includes 
paragraphs, figures, equations, and other content types 
(Code~\ref{code:RawContent}). A Drasil \macblue{Section} can consist of a list 
of \macblue{RawContent}, allowing for the inclusion of different types of 
contents within a single section. Additionally, as we saw in 
Chapter~\ref{chap:nbprinter}, the document is printed in a specific document 
language using \macblue{LayoutObj}, which is derived from \macblue{RawContent}. 
Because each content type is handled explicitly by \macblue{LayoutObj}, we can 
take advantage of this and split each type of content into its own cell.

To implement this approach, we first need to ensure that each layout object 
is generated independently and is not nested with other layout objects. In 
Chapter~\ref{chap:nbprinter}, we discussed how \macblue{RawContent} is 
translated to a printable \macblue{LayoutObj}. The \macred{printLO} function in 
Code~\ref{code:LayoutObj} demonstrates how the printer renders each content 
type into a notebook format. However, it's worth noting that the current format 
of \macblue{LayourObj} is designed for SRS and may not be suitable for lesson 
plans. For instance, the \textbf{HDiv} type wraps sections and creates an HTML 
$<$div$>$ tag, and even an equation block is translated into the \textbf{HDiv}, 
as seen in Code~\ref{code:EqnblocktoTex]}. Moreover, the \textbf{Definition} 
type is designed for the definition or model defined in SRS and may not be 
required for lesson plans. To better accommodate lesson plan content types, we 
may need to create a new \macblue{LayoutObj} in the future when we have a 
better understanding of the lesson plan structure. \todo{future work}

Currently, we are using the existing \macblue{LayoutObj} to translate our 
lesson plan contents into printable layout object. Since these contents are not 
code and should be in Mardown, we print each required content type 
independently into a Markdown cell. To accomplish this, we use the 
\macred{markdownCell} function from Code~\ref{code:markdownCell}. This function 
generates the necessary metadata and creates the Markdown cell for each layout 
object, which is our unit of content. 

Code~\ref{code:printLO'} illustrates how each content type is rendered in 
notebook format in a Markdown cell. For layout objects that are not needed in 
lesson plans, we make them empty. We also separate equation blocks from 
\textbf{HDiv} with the equation tag to have more control over the structure.

\begin{listing}[h!]
	\caption{Source Code for printLO'}
	\label{code:printLO'}
	\begin{lstlisting}[language=haskell1, basicstyle=\small\ttfamily]
		-- printLO' is used for generating lesson plans
		printLO' :: LayoutObj -> Doc
		printLO' (HDiv ["equation"] layObs _) = markdownCell $ 
			vcat (map printLO' layObs)
		printLO' (Header n contents l) = markdownCell $ nbformat 
			(h (n + 1) <> pSpec contents) $$ refID (pSpec l)
		printLO' (Cell layObs) = vcat (map printLO' layObs)
		printLO' HDiv {} = empty
		printLO' (Paragraph contents) = markdownCell $ nbformat 
			(stripnewLine (show(pSpec contents)))
		printLO' (EqnBlock contents) = nbformat mathEqn
			where
				toMathHelper (PL g) = PL (\_ -> g Math)
				mjDelimDisp d = text "$$" <> stripnewLine (show d) <> text "$$" 
				mathEqn = mjDelimDisp $ printMath $ toMathHelper $ 
					TeX.spec contents
		printLO' (Table _ rows r _ _) = markdownCell $ 
			makeTable rows (pSpec r)
		printLO' (Definition dt ssPs l) = empty
		printLO' (List t) = markdownCell $ makeList t False
		printLO' (Figure r c f wp) = markdownCell $ makeFigure 
			(pSpec r) (pSpec c) (text f) wp
		printLO' (Bib bib) = markdownCell $ makeBib bib
		printLO' Graph{} = empty
	\end{lstlisting}
\end{listing}

\section{Code Block}